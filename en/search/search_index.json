{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting started \u00b6 Welcome to XenForo 2! This documentation aims to get you started with XenForo 2.0 development. Pre-requisites for this documentation assume you will be familiar with, amongst other things, PHP and MySQL. It is not essential to have experience with a previous version of XenForo, but it would be an advantage. On the subsequent pages we will walk you through a brief overview of how to setup a local server, getting ready for installation, doing a clean install of XenForo 2.0, and run through some of the concepts of XF2 development. What's new for developers? \u00b6 Although XenForo 2.0 adds a lot of improvements for your forums and its members, a significant amount of effort has been put into improving the underlying framework of XenForo. You can read more information about these changes in the following threads: What's new for developers in XenForo 2 (part 1) What's new for developers in XenForo 2 (part 2) Getting started \u00b6 Getting started with XF development is easy. You just need to download the files, upload them to a web server and trigger the install. If you don't have a web server, yet, don't worry, you can set one up on your local machine. Downloading XF 2.0 \u00b6 To download XF 2.0, just visit the Customer Area and log in as normal. Locate the correct license and click the \"Download XenForo\" link. Select the version you wish to download, the package type and accept the license agreement. Finally, click the Download button to download the files. XF 2.0 requirements \u00b6 The requirements for running XF 2.0 have changed since XF 1.5. The recommended requirements are as follows: PHP: 5.4.0+ MySQL: 5.5+ PHP extensions: MySQLi, GD (with JPEG support), PCRE, SPL, SimpleXML, DOM, JSON, iconv, ctype, cURL Download the requirements test script. Setting up a local server \u00b6 It's often more convenient to set up a local web server for development. There are generally two approaches for this: Install Apache (or nginx), MySQL (or MariaDB) and PHP yourself. Install a pre-built virtual machine Install a pre-built stack. Setting things up yourself is more complicated, but tends to give you more control over how everything is set up. Pre-built virtual machine \u00b6 There are a variety of pre-built virtual machines available on the Internet, which provide the advantage of having all of the necessary services to run XenForo neatly packaged into one place, without having to install and maintain them directly on your own computer. Some of the XenForo developers use a virtual machine called Scotch Box , which includes everything you need to run XenForo with zero configuration required. We have a step-by-step guide to getting a XenForo development server up and running - you can have a working virtual web and database server up and running in just a few minutes by running a handful of commands. Installing Scotch Box for use with XenForo Pre-built stack \u00b6 There are many pre-built stacks out there and they may vary in feature set, performance and reliability. Bitnami maintain a number of stacks, including LAMP , MAMP and WAMP stacks for use on Linux, Mac and Windows respectively. They all include a fully configured installation of Apache, MySQL and PHP and include PhpMyAdmin for managing MySQL. Uploading \u00b6 To install XF 2.0, you simply need to extract the ZIP file downloaded from the Customer Area and upload some of the files and directories within. Once extracted you will see a directory named upload . You need to go into that directory and upload the files and directories to your server's web root. This would usually be in a directory named public_html , htdocs or www . Creating src/config.php \u00b6 If using the CLI to install XF 2.0, you will need to create the config.php file manually. To do this, enter the src directory within the XF 2.0 files you uploaded to your server. Create a new file named config.php and populate it with the host, port, username, password and database name for your MySQL server. Note Make sure you create the config file in within the src directory. The library directory is only used for legacy purposes. Once finished, it should look like the following: <?php $config['db']['host'] = 'localhost'; $config['db']['port'] = '3306'; $config['db']['username'] = 'root'; $config['db']['password'] = 'mypassword'; $config['db']['dbname'] = 'xf2'; You're now ready to install! If you are using MySQL 5.5 and above and you wish to have full unicode support (for things like emoji) you should also add the following before install: $config['fullUnicode'] = true; A note on file permissions \u00b6 XenForo will need to write files to specific locations while running. In normal operation, this is limited to the data and internal_data directories (and their sub-directories). These file writes will be triggered by things like attachment uploads, so they will normally be triggered by the user PHP as running as within your web server. Therefore, it is necessary to ensure that permissions are set in these directories so that the web server can write to them. You will need to do this before installation can begin. When the CLI is involved, this situation gets trickier as there are now potentially two users that need to be able to write to the files. As such, it's important to take steps to avoid problems writing to these files. Here are a few options. Use the same user for the CLI and the web server. This may take the form of you switching to the web server user before running any installation or upgrade command (or any other that will write files). If available, consider applying ACLs to the data and internal_data directories. This concept varies by OS and configuration, but the general idea is described here . Force specific permissions on what is written by PHP. This can be done via the src/config.php file with a line like this: $config['chmodWritableValue'] = 0666; This approach is potentially the simplest for development purposes. Note that if you are developing add-ons, you may potentially have other locations that need to be written to by the CLI and web server users. Notably, this includes the _output directory within add-ons. In this situation, having your web server run as your CLI user may cause the least friction. If you go down any other route, you may need to ensure that your web server can write to your entire XenForo installation; this is not recommended in production. Installation \u00b6 The current way to install XF 2.0 is via the new CLI system. A lot of development processes can only be performed using the CLI so let's get stuck into using it to install XF 2.0. To run these commands, you will need access to a terminal/shell, the php CLI command and the current working directory should be the root of where you uploaded the XF 2.0 files. Warning To eliminate file permission problems, we recommend running the installer as the same user that PHP runs as via your web server. If you don't do this, you should take steps to ensure that permissions are set correctly. See the above section for more details. To start the install, just enter the below command: Terminal $ php cmd.php xf:install You will be asked a number of questions, such as the initial administrator username and password, board title. After this, the XF 2.0 database tables and master data will be imported. XF 2.0 is now installed! Reinstallation \u00b6 Occasionally it may be necessary to reinstall XF2. This is particularly true during the Development Preview stage which does not support upgrading. If you are ready to do a reinstall, download the new files (if applicable) as per the Downloading XF 2.0 section above. It should generally be possible to just merge and overwrite your existing files. If you're doing a full clean re-install, you may want to save a copy of your config.php file or re-create it as per the instructions in the Creating src/config.php . Before uploading the new files, you should delete the contents of your data and internal_data directories. Finally, you will just need to start the installation, similar to above. You will need to use the --clear option which will delete all of the existing xf_ tables. Terminal $ php cmd.php xf:install --clear Once the re-install has been completed, you should now be able to log back on. If you have been developing add-ons, and you have chosen to keep or backup your existing src/addons directory, you can restore your add-on data with the Import development output command. Warning Be careful if you choose to back up and restore your src/addons directory. The XF directory within contains the XF master data, and should not be restored from a backup to ensure you always have the most up to date version of the files. Performing a reinstall in this way is a destructive operation and it will remove all data you have created. Additionally, bear in mind that only tables with the xf_ prefix are cleared. This is a significant reason for the recommendation that all tables, even for add-ons, should be prefixed with xf_ . Verifying file integrity \u00b6 When you install XF2, we perform a file integrity check in the installation. If necessary, and you can't otherwise perform the check via the page in the Admin CP, you can run the CLI command to perform that check. Terminal $ php cmd.php xf:file-check [addon_id] If you wish to do a file health check on all files, including XF itself, just omit the [addon_id] argument. For XF only, just use XF in place of the argument, or for a specific add-on, just specify the add-on ID you wish to check. Add-on management commands \u00b6 In addition to the above commands for installing XF2, there are also several commands for managing add-ons. Install \u00b6 Terminal $ php cmd.php xf:addon-install [addon_id] Installs the specified add-on, as long as it is available, and passes the file health check. If development output is available, you will be asked to confirm if you wish to use that for the installation, instead of the exported data XML files. Upgrade \u00b6 Terminal $ php cmd.php xf:addon-upgrade [addon_id] Upgrades the specified add-on, as long as it is upgradeable, and passes the file health check. Can optionally perform import from development output. Rebuild \u00b6 Terminal $ php cmd.php xf:addon-rebuild [addon_id] Rebuilds the master data for the specified add-on, as long as it is rebuildable, and passes the file health check. This re-imports the add-on's data. Can optionally perform import from development output. Uninstall \u00b6 Terminal $ php cmd.php xf:addon-uninstall [addon_id] Uninstalls the specified add-on, as long as it is uninstallable.","title":"Getting started"},{"location":"#getting-started","text":"Welcome to XenForo 2! This documentation aims to get you started with XenForo 2.0 development. Pre-requisites for this documentation assume you will be familiar with, amongst other things, PHP and MySQL. It is not essential to have experience with a previous version of XenForo, but it would be an advantage. On the subsequent pages we will walk you through a brief overview of how to setup a local server, getting ready for installation, doing a clean install of XenForo 2.0, and run through some of the concepts of XF2 development.","title":"Getting started"},{"location":"#whats-new-for-developers","text":"Although XenForo 2.0 adds a lot of improvements for your forums and its members, a significant amount of effort has been put into improving the underlying framework of XenForo. You can read more information about these changes in the following threads: What's new for developers in XenForo 2 (part 1) What's new for developers in XenForo 2 (part 2)","title":"What's new for developers?"},{"location":"#getting-started_1","text":"Getting started with XF development is easy. You just need to download the files, upload them to a web server and trigger the install. If you don't have a web server, yet, don't worry, you can set one up on your local machine.","title":"Getting started"},{"location":"#downloading-xf-20","text":"To download XF 2.0, just visit the Customer Area and log in as normal. Locate the correct license and click the \"Download XenForo\" link. Select the version you wish to download, the package type and accept the license agreement. Finally, click the Download button to download the files.","title":"Downloading XF 2.0"},{"location":"#xf-20-requirements","text":"The requirements for running XF 2.0 have changed since XF 1.5. The recommended requirements are as follows: PHP: 5.4.0+ MySQL: 5.5+ PHP extensions: MySQLi, GD (with JPEG support), PCRE, SPL, SimpleXML, DOM, JSON, iconv, ctype, cURL Download the requirements test script.","title":"XF 2.0 requirements"},{"location":"#setting-up-a-local-server","text":"It's often more convenient to set up a local web server for development. There are generally two approaches for this: Install Apache (or nginx), MySQL (or MariaDB) and PHP yourself. Install a pre-built virtual machine Install a pre-built stack. Setting things up yourself is more complicated, but tends to give you more control over how everything is set up.","title":"Setting up a local server"},{"location":"#pre-built-virtual-machine","text":"There are a variety of pre-built virtual machines available on the Internet, which provide the advantage of having all of the necessary services to run XenForo neatly packaged into one place, without having to install and maintain them directly on your own computer. Some of the XenForo developers use a virtual machine called Scotch Box , which includes everything you need to run XenForo with zero configuration required. We have a step-by-step guide to getting a XenForo development server up and running - you can have a working virtual web and database server up and running in just a few minutes by running a handful of commands. Installing Scotch Box for use with XenForo","title":"Pre-built virtual machine"},{"location":"#pre-built-stack","text":"There are many pre-built stacks out there and they may vary in feature set, performance and reliability. Bitnami maintain a number of stacks, including LAMP , MAMP and WAMP stacks for use on Linux, Mac and Windows respectively. They all include a fully configured installation of Apache, MySQL and PHP and include PhpMyAdmin for managing MySQL.","title":"Pre-built stack"},{"location":"#uploading","text":"To install XF 2.0, you simply need to extract the ZIP file downloaded from the Customer Area and upload some of the files and directories within. Once extracted you will see a directory named upload . You need to go into that directory and upload the files and directories to your server's web root. This would usually be in a directory named public_html , htdocs or www .","title":"Uploading"},{"location":"#creating-srcconfigphp","text":"If using the CLI to install XF 2.0, you will need to create the config.php file manually. To do this, enter the src directory within the XF 2.0 files you uploaded to your server. Create a new file named config.php and populate it with the host, port, username, password and database name for your MySQL server. Note Make sure you create the config file in within the src directory. The library directory is only used for legacy purposes. Once finished, it should look like the following: <?php $config['db']['host'] = 'localhost'; $config['db']['port'] = '3306'; $config['db']['username'] = 'root'; $config['db']['password'] = 'mypassword'; $config['db']['dbname'] = 'xf2'; You're now ready to install! If you are using MySQL 5.5 and above and you wish to have full unicode support (for things like emoji) you should also add the following before install: $config['fullUnicode'] = true;","title":"Creating src/config.php"},{"location":"#a-note-on-file-permissions","text":"XenForo will need to write files to specific locations while running. In normal operation, this is limited to the data and internal_data directories (and their sub-directories). These file writes will be triggered by things like attachment uploads, so they will normally be triggered by the user PHP as running as within your web server. Therefore, it is necessary to ensure that permissions are set in these directories so that the web server can write to them. You will need to do this before installation can begin. When the CLI is involved, this situation gets trickier as there are now potentially two users that need to be able to write to the files. As such, it's important to take steps to avoid problems writing to these files. Here are a few options. Use the same user for the CLI and the web server. This may take the form of you switching to the web server user before running any installation or upgrade command (or any other that will write files). If available, consider applying ACLs to the data and internal_data directories. This concept varies by OS and configuration, but the general idea is described here . Force specific permissions on what is written by PHP. This can be done via the src/config.php file with a line like this: $config['chmodWritableValue'] = 0666; This approach is potentially the simplest for development purposes. Note that if you are developing add-ons, you may potentially have other locations that need to be written to by the CLI and web server users. Notably, this includes the _output directory within add-ons. In this situation, having your web server run as your CLI user may cause the least friction. If you go down any other route, you may need to ensure that your web server can write to your entire XenForo installation; this is not recommended in production.","title":"A note on file permissions"},{"location":"#installation","text":"The current way to install XF 2.0 is via the new CLI system. A lot of development processes can only be performed using the CLI so let's get stuck into using it to install XF 2.0. To run these commands, you will need access to a terminal/shell, the php CLI command and the current working directory should be the root of where you uploaded the XF 2.0 files. Warning To eliminate file permission problems, we recommend running the installer as the same user that PHP runs as via your web server. If you don't do this, you should take steps to ensure that permissions are set correctly. See the above section for more details. To start the install, just enter the below command: Terminal $ php cmd.php xf:install You will be asked a number of questions, such as the initial administrator username and password, board title. After this, the XF 2.0 database tables and master data will be imported. XF 2.0 is now installed!","title":"Installation"},{"location":"#reinstallation","text":"Occasionally it may be necessary to reinstall XF2. This is particularly true during the Development Preview stage which does not support upgrading. If you are ready to do a reinstall, download the new files (if applicable) as per the Downloading XF 2.0 section above. It should generally be possible to just merge and overwrite your existing files. If you're doing a full clean re-install, you may want to save a copy of your config.php file or re-create it as per the instructions in the Creating src/config.php . Before uploading the new files, you should delete the contents of your data and internal_data directories. Finally, you will just need to start the installation, similar to above. You will need to use the --clear option which will delete all of the existing xf_ tables. Terminal $ php cmd.php xf:install --clear Once the re-install has been completed, you should now be able to log back on. If you have been developing add-ons, and you have chosen to keep or backup your existing src/addons directory, you can restore your add-on data with the Import development output command. Warning Be careful if you choose to back up and restore your src/addons directory. The XF directory within contains the XF master data, and should not be restored from a backup to ensure you always have the most up to date version of the files. Performing a reinstall in this way is a destructive operation and it will remove all data you have created. Additionally, bear in mind that only tables with the xf_ prefix are cleared. This is a significant reason for the recommendation that all tables, even for add-ons, should be prefixed with xf_ .","title":"Reinstallation"},{"location":"#verifying-file-integrity","text":"When you install XF2, we perform a file integrity check in the installation. If necessary, and you can't otherwise perform the check via the page in the Admin CP, you can run the CLI command to perform that check. Terminal $ php cmd.php xf:file-check [addon_id] If you wish to do a file health check on all files, including XF itself, just omit the [addon_id] argument. For XF only, just use XF in place of the argument, or for a specific add-on, just specify the add-on ID you wish to check.","title":"Verifying file integrity"},{"location":"#add-on-management-commands","text":"In addition to the above commands for installing XF2, there are also several commands for managing add-ons.","title":"Add-on management commands"},{"location":"#install","text":"Terminal $ php cmd.php xf:addon-install [addon_id] Installs the specified add-on, as long as it is available, and passes the file health check. If development output is available, you will be asked to confirm if you wish to use that for the installation, instead of the exported data XML files.","title":"Install"},{"location":"#upgrade","text":"Terminal $ php cmd.php xf:addon-upgrade [addon_id] Upgrades the specified add-on, as long as it is upgradeable, and passes the file health check. Can optionally perform import from development output.","title":"Upgrade"},{"location":"#rebuild","text":"Terminal $ php cmd.php xf:addon-rebuild [addon_id] Rebuilds the master data for the specified add-on, as long as it is rebuildable, and passes the file health check. This re-imports the add-on's data. Can optionally perform import from development output.","title":"Rebuild"},{"location":"#uninstall","text":"Terminal $ php cmd.php xf:addon-uninstall [addon_id] Uninstalls the specified add-on, as long as it is uninstallable.","title":"Uninstall"},{"location":"add-on-structure/","text":"Add-on structure \u00b6 In previous versions of XF, there were very few standards and conventions surrounding add-on development. We have done a lot to change that in XF 2.0. Let's look at some of the changes: Add-on IDs and add-ons path \u00b6 Each installed add-on must have a unique ID, and this ID dictates where on the filesystem that an add-on should store its files. There are two possible formats for an add-on ID. The first \"simple\" type should be a single word and not contain any special characters. For example, Demo . Simple add-on IDs must adhere to the following rules: Must only contain a-z or A-Z Can contain 0-9 but not at the start of the ID Can not contain any special characters such as slashes, dashes or underscores The second contains a vendor prefix, so if you release add-ons under a specific brand or company, the add-on ID can indicate that. For example, SomeVendor/Demo . The vendor type add-on ID should adhere to the following rules: Must only contain a-z or A-Z Can contain a single / character but not at the start or the end Can contain 0-9 but not at the start of either part of the add-on ID Once you have decided what your add-on ID is, we know exactly where the files for this add-on will be stored. All XF 2.0 add-ons are stored within a subdirectory of the src/addons directory. If you have a simple add-on ID, e.g. Demo , the files for your add-on will be stored in the following location: src/addons/Demo . If you have a vendor based add-on ID, e.g. SomeVendor/Demo , the files will be stored in the following location: src/addons/SomeVendor/Demo . The add-on ID you choose will also become your class namespace prefix (see Namespaces for more information). Recommended version string format \u00b6 XF itself uses a MAJOR.MINOR.PATCH principle (e.g. 2.0.0 for the first stable XF2 release) to its version numbering and we recommend a similar approach is taken towards the versioning of your own add-ons. In basic terms, increment the MAJOR version when you make major feature changes, especially changes that break backwards compatibility MINOR version when you add functionality preferably in a backwards compatible manner, and PATCH version when you make backwards-compatible bug fixes Recommended version ID format \u00b6 Version IDs for add-ons are basic integers which are used for internal version comparisons. It allows us to more easily detect when one version is older than another. Each version of your add-on should increase the version ID by at least 1, but a convention we use internally for XF itself, is potentially useful also for add-ons. Our version IDs are in the format of aabbccde . aa represents the major version bb represents the minor version cc represents the patch version d represents the state, e.g. 1 for alpha releases, 3 for beta releases, 5 for release candidates and 7 for stable releases e represents the state version For example, an add-on with version string of 1.7.3 release candidate 4 would have an ID of 1070354 . The final stable release XF2 will have an ID of 2000070 . Version 1.5.0 Beta 3 of XF had an ID of 1050033 . Stable version 99.99.99 would have an ID of 99999970 ... and maybe you should slow down a bit \ud83d\ude09 Common add-on files and directories \u00b6 There are a number of files and directories within an add-on's directory that have a special purpose and meaning. addon.json file \u00b6 addon.json is a file which contains a number of pieces of information which are required to help XF 2.0 identify the add-on and display information about it in the Admin CP. At minimum, your addon.json file should look like this: { \"title\": \"My Add-on by Some Company\", \"version_string\": \"2.0.0\", \"version_id\": 2000070, \"dev\": \"Some Company\" } A basic file will be created for you automatically when creating the add-on. Including a valid addon.json file is mandatory for your addon to be recognized but you can always validate your addon.json file . Properties \u00b6 Property Description legacy_addon_id Used to enable automatic handling of addon ID changes when upgrading from XenForo 1 to XenForo 2. title The title of the addon. This will show in the Admin Panel. description A description of the addon. This will show in the Admin Panel. version_id The internal ID used by XenForo to track updates to your addon. This must be incremented every release. version_string The human-readable addon version. This will show in the Admin Panel instead of the version_id property. dev The name of the developer of the addon. This will show in the Admin Panel. dev_url If set, the developer's name will show in the Admin Panel as a hyperlink, with this as the target (href). faq_url If set, an FAQ hyperlink will show in the Admin Panel, with this as the target (href). support_url If set, a support hyperlink will show in the Admin Panel, with this as the target (href). extra_urls This allows you to display links to other things related to the add-on (perhaps a bug reports link, a manual - whatever you like). An array of JSON objects, where the key is the link text and the value is the link target (href). require A set of requirements that need to be met for XenForo to allow installation of the addon. See 'The requirements property' for more information. icon The icon of the resource. This can be a Font Awesome icon name (e.g. fa-shopping-bag , or the path to an image file.) The requirements property \u00b6 The require property is the standard way of blocking an add-on install or upgrade if the environment doesn't support or meet the requirements. You can use it to require other add-ons to be installed first, certain PHP extensions to be present or enabled and/or to enforce a minimum PHP version. Here's an example snippet: ... \"require\": { \"XF\": [2000010, \"XenForo 2.0.0+\"], \"php\": [\"5.4.0\", \"PHP 5.4.0+\"], \"php-ext/json\": [\"*\", \"JSON extension\"] } ... Each requirement, is a named array: The name of the array is the product ID (e.g. XF or php ). The first array element is the version of the product (e.g. 2000010 or 5.4.0 ). You can use use * to refer to any version of the product. The second element is the human-readable text of that requirement and this is what's used in messages (e.g. XenForo 2.0.0+ or PHP 5.4.0+ ). Here's a summary of the supported product IDs: Product/Requirement Name Refers to... Value XF The XenForo installation version. The XenForo version ID, for example 200010 . You can get your current XenForo version by checking the top of the /src/XF.php file for the $versionId definion or by printing the value of \\XF::$versionId . php The PHP version. The PHP version, for example 5.4.0 . It's recommended that you keep this as low as possible; updating a PHP version can be quite a complex task - especially if other add-ons conflict with newer PHP versions. php-ext/(extension name) A PHP extension - where (extension name) is the name of the extension. The PHP extension version. This is checked using the PHP version_compare function, so it even works for version strings in the official full PHP format like 7.1.19-1+ubuntu16.04.1+deb.sury.org+1 . (any addon ID) Any XenForo addon such as Demo/Addon . If you're unsure about an addon's ID, check it's addon.json file. The addon version ID. You can refer to the Recommended version ID format for more information. hashes.json file \u00b6 hashes.json is the new way to add support for the File health check system, and the best part is -- it's generated automatically! As part of the build process (more on that later) we will do a quick inventory of all your add-on's files and write the calculated hash of the file contents. Setup.php file \u00b6 Setup.php is the new home for any code you require to run during install, upgrade or uninstallation of your add-on. We will go into more detail about how to create a Setup class below . _data directory \u00b6 The _data directory is where the master data for your add-on is stored. Each add-on data type will have its own XML file (rather than a single one for all types). The hashes for these files are included inside hashes.json so we can ensure that an add-on has complete and consistent data before allowing an add-on to be installed. _output directory \u00b6 The _output directory is not required for a successful installation of an add-on, and shouldn't be included when releasing the add-on. This directory is purely for development purposes and is only used if development mode is enabled (see Enabling development mode ). Each item of add-on data is stored in a separate file. Mostly they are stored as JSON files, but in the case of phrases they are stored as TXT files and for templates they are stored as HTML/CSS/LESS files. All template types are editable in the filesystem directly, and changes made to these files are written back to the database automatically on load. Setup class \u00b6 To create a Setup class for your add-on, all you need to do is create a file named Setup.php in the root of your add-on directory. The Setup class should extend \\XF\\AddOn\\AbstractSetup which requires, at minimum, to implement install() , upgrade() and uninstall() methods. Here's what a simple add-on Setup class might look like: <?php namespace Demo; class Setup extends \\XF\\AddOn\\AbstractSetup { public function install(array $stepParams = []) { $this->schemaManager()->createTable('xf_demo', function(\\XF\\Db\\Schema\\Create $table) { $table->addColumn('demo_id', 'int'); }); } public function upgrade(array $stepParams = []) { if ($this->addOn->version_id < 1000170) { $this->schemaManager()->alterTable('xf_demo', function(\\XF\\Db\\Schema\\Alter $table) { $table->addColumn('foo', 'varchar', 10)->setDefault(''); }); } } public function uninstall(array $stepParams = []) { $this->schemaManager()->dropTable('xf_demo'); } } The Setup class also supports running each of the actions in different steps. To implement this behavior your Setup class can use the StepRunnerInstallTrait , StepRunnerUpgradeTrait and/or StepRunnerUninstallTrait traits . These implement the required methods automatically, and you just need to add the relevant steps, e.g. installStep1() , upgrade1000170Step1() , upgrade1000170Step2() and uninstallStep1() , where 1000170 etc. in the upgrade methods are the add-on version IDs (see Recommended version ID format ).","title":"Add-on structure"},{"location":"add-on-structure/#add-on-structure","text":"In previous versions of XF, there were very few standards and conventions surrounding add-on development. We have done a lot to change that in XF 2.0. Let's look at some of the changes:","title":"Add-on structure"},{"location":"add-on-structure/#add-on-ids-and-add-ons-path","text":"Each installed add-on must have a unique ID, and this ID dictates where on the filesystem that an add-on should store its files. There are two possible formats for an add-on ID. The first \"simple\" type should be a single word and not contain any special characters. For example, Demo . Simple add-on IDs must adhere to the following rules: Must only contain a-z or A-Z Can contain 0-9 but not at the start of the ID Can not contain any special characters such as slashes, dashes or underscores The second contains a vendor prefix, so if you release add-ons under a specific brand or company, the add-on ID can indicate that. For example, SomeVendor/Demo . The vendor type add-on ID should adhere to the following rules: Must only contain a-z or A-Z Can contain a single / character but not at the start or the end Can contain 0-9 but not at the start of either part of the add-on ID Once you have decided what your add-on ID is, we know exactly where the files for this add-on will be stored. All XF 2.0 add-ons are stored within a subdirectory of the src/addons directory. If you have a simple add-on ID, e.g. Demo , the files for your add-on will be stored in the following location: src/addons/Demo . If you have a vendor based add-on ID, e.g. SomeVendor/Demo , the files will be stored in the following location: src/addons/SomeVendor/Demo . The add-on ID you choose will also become your class namespace prefix (see Namespaces for more information).","title":"Add-on IDs and add-ons path"},{"location":"add-on-structure/#recommended-version-string-format","text":"XF itself uses a MAJOR.MINOR.PATCH principle (e.g. 2.0.0 for the first stable XF2 release) to its version numbering and we recommend a similar approach is taken towards the versioning of your own add-ons. In basic terms, increment the MAJOR version when you make major feature changes, especially changes that break backwards compatibility MINOR version when you add functionality preferably in a backwards compatible manner, and PATCH version when you make backwards-compatible bug fixes","title":"Recommended version string format"},{"location":"add-on-structure/#recommended-version-id-format","text":"Version IDs for add-ons are basic integers which are used for internal version comparisons. It allows us to more easily detect when one version is older than another. Each version of your add-on should increase the version ID by at least 1, but a convention we use internally for XF itself, is potentially useful also for add-ons. Our version IDs are in the format of aabbccde . aa represents the major version bb represents the minor version cc represents the patch version d represents the state, e.g. 1 for alpha releases, 3 for beta releases, 5 for release candidates and 7 for stable releases e represents the state version For example, an add-on with version string of 1.7.3 release candidate 4 would have an ID of 1070354 . The final stable release XF2 will have an ID of 2000070 . Version 1.5.0 Beta 3 of XF had an ID of 1050033 . Stable version 99.99.99 would have an ID of 99999970 ... and maybe you should slow down a bit \ud83d\ude09","title":"Recommended version ID format"},{"location":"add-on-structure/#common-add-on-files-and-directories","text":"There are a number of files and directories within an add-on's directory that have a special purpose and meaning.","title":"Common add-on files and directories"},{"location":"add-on-structure/#addonjson-file","text":"addon.json is a file which contains a number of pieces of information which are required to help XF 2.0 identify the add-on and display information about it in the Admin CP. At minimum, your addon.json file should look like this: { \"title\": \"My Add-on by Some Company\", \"version_string\": \"2.0.0\", \"version_id\": 2000070, \"dev\": \"Some Company\" } A basic file will be created for you automatically when creating the add-on. Including a valid addon.json file is mandatory for your addon to be recognized but you can always validate your addon.json file .","title":"addon.json file"},{"location":"add-on-structure/#properties","text":"Property Description legacy_addon_id Used to enable automatic handling of addon ID changes when upgrading from XenForo 1 to XenForo 2. title The title of the addon. This will show in the Admin Panel. description A description of the addon. This will show in the Admin Panel. version_id The internal ID used by XenForo to track updates to your addon. This must be incremented every release. version_string The human-readable addon version. This will show in the Admin Panel instead of the version_id property. dev The name of the developer of the addon. This will show in the Admin Panel. dev_url If set, the developer's name will show in the Admin Panel as a hyperlink, with this as the target (href). faq_url If set, an FAQ hyperlink will show in the Admin Panel, with this as the target (href). support_url If set, a support hyperlink will show in the Admin Panel, with this as the target (href). extra_urls This allows you to display links to other things related to the add-on (perhaps a bug reports link, a manual - whatever you like). An array of JSON objects, where the key is the link text and the value is the link target (href). require A set of requirements that need to be met for XenForo to allow installation of the addon. See 'The requirements property' for more information. icon The icon of the resource. This can be a Font Awesome icon name (e.g. fa-shopping-bag , or the path to an image file.)","title":"Properties"},{"location":"add-on-structure/#the-requirements-property","text":"The require property is the standard way of blocking an add-on install or upgrade if the environment doesn't support or meet the requirements. You can use it to require other add-ons to be installed first, certain PHP extensions to be present or enabled and/or to enforce a minimum PHP version. Here's an example snippet: ... \"require\": { \"XF\": [2000010, \"XenForo 2.0.0+\"], \"php\": [\"5.4.0\", \"PHP 5.4.0+\"], \"php-ext/json\": [\"*\", \"JSON extension\"] } ... Each requirement, is a named array: The name of the array is the product ID (e.g. XF or php ). The first array element is the version of the product (e.g. 2000010 or 5.4.0 ). You can use use * to refer to any version of the product. The second element is the human-readable text of that requirement and this is what's used in messages (e.g. XenForo 2.0.0+ or PHP 5.4.0+ ). Here's a summary of the supported product IDs: Product/Requirement Name Refers to... Value XF The XenForo installation version. The XenForo version ID, for example 200010 . You can get your current XenForo version by checking the top of the /src/XF.php file for the $versionId definion or by printing the value of \\XF::$versionId . php The PHP version. The PHP version, for example 5.4.0 . It's recommended that you keep this as low as possible; updating a PHP version can be quite a complex task - especially if other add-ons conflict with newer PHP versions. php-ext/(extension name) A PHP extension - where (extension name) is the name of the extension. The PHP extension version. This is checked using the PHP version_compare function, so it even works for version strings in the official full PHP format like 7.1.19-1+ubuntu16.04.1+deb.sury.org+1 . (any addon ID) Any XenForo addon such as Demo/Addon . If you're unsure about an addon's ID, check it's addon.json file. The addon version ID. You can refer to the Recommended version ID format for more information.","title":"The requirements property"},{"location":"add-on-structure/#hashesjson-file","text":"hashes.json is the new way to add support for the File health check system, and the best part is -- it's generated automatically! As part of the build process (more on that later) we will do a quick inventory of all your add-on's files and write the calculated hash of the file contents.","title":"hashes.json file"},{"location":"add-on-structure/#setupphp-file","text":"Setup.php is the new home for any code you require to run during install, upgrade or uninstallation of your add-on. We will go into more detail about how to create a Setup class below .","title":"Setup.php file"},{"location":"add-on-structure/#_data-directory","text":"The _data directory is where the master data for your add-on is stored. Each add-on data type will have its own XML file (rather than a single one for all types). The hashes for these files are included inside hashes.json so we can ensure that an add-on has complete and consistent data before allowing an add-on to be installed.","title":"_data directory"},{"location":"add-on-structure/#_output-directory","text":"The _output directory is not required for a successful installation of an add-on, and shouldn't be included when releasing the add-on. This directory is purely for development purposes and is only used if development mode is enabled (see Enabling development mode ). Each item of add-on data is stored in a separate file. Mostly they are stored as JSON files, but in the case of phrases they are stored as TXT files and for templates they are stored as HTML/CSS/LESS files. All template types are editable in the filesystem directly, and changes made to these files are written back to the database automatically on load.","title":"_output directory"},{"location":"add-on-structure/#setup-class","text":"To create a Setup class for your add-on, all you need to do is create a file named Setup.php in the root of your add-on directory. The Setup class should extend \\XF\\AddOn\\AbstractSetup which requires, at minimum, to implement install() , upgrade() and uninstall() methods. Here's what a simple add-on Setup class might look like: <?php namespace Demo; class Setup extends \\XF\\AddOn\\AbstractSetup { public function install(array $stepParams = []) { $this->schemaManager()->createTable('xf_demo', function(\\XF\\Db\\Schema\\Create $table) { $table->addColumn('demo_id', 'int'); }); } public function upgrade(array $stepParams = []) { if ($this->addOn->version_id < 1000170) { $this->schemaManager()->alterTable('xf_demo', function(\\XF\\Db\\Schema\\Alter $table) { $table->addColumn('foo', 'varchar', 10)->setDefault(''); }); } } public function uninstall(array $stepParams = []) { $this->schemaManager()->dropTable('xf_demo'); } } The Setup class also supports running each of the actions in different steps. To implement this behavior your Setup class can use the StepRunnerInstallTrait , StepRunnerUpgradeTrait and/or StepRunnerUninstallTrait traits . These implement the required methods automatically, and you just need to add the relevant steps, e.g. installStep1() , upgrade1000170Step1() , upgrade1000170Step2() and uninstallStep1() , where 1000170 etc. in the upgrade methods are the add-on version IDs (see Recommended version ID format ).","title":"Setup class"},{"location":"controller-basics/","text":"Controller basics \u00b6 At a basic level, Controllers are the code that is executed when you visit a page within XF. Controllers are generally responsible for handling user input and passing that user input to the appropriate place which, generally, would be to perform some sort of database action (Model) or load visual content (View). When a user clicks a link, the requested URL is routed to a specific controller and controller action. See Routing basics . For example, in XF if you click a URL like index.php?conversations/add you will be routed to the XF\\Pub\\Controller\\Conversation controller and to the add action. If you look at this class in the file system (see Autoloader for a description of how classes and file paths map to each other) you will notice that there are a number of methods named with a prefix of action . All of these methods indicate a specific controller action. So, to see the code involved when viewing the conversations/add page mentioned above, look in this file for public function actionAdd() . XF controllers are responsible for returning a reply object which generally consist of one of the following types: View reply \u00b6 This is one of the most common replies you will deal with during XF development. A controller which returns a view reply will usually require up to three arguments to be passed in. A view class (more on that below), a template name, and an array of $viewParams which is the data that should be available to the template. Here's a typical example of a controller action which returns a View reply: public function actionExample() { $hello = 'Hello'; $world = 'world!'; $viewParams = [ 'hello' => $hello, 'world' => $world ]; return $this->view('Demo:Example', 'demo_example', $viewParams); } The first argument is the short class name for a specific View class. This class may or may not exist (often it won't need to exist, we'll cover view classes more later) but it should have a roughly unique name for the controller and action. As with other Short class names , the particular short class name above will resolve to Demo\\Pub\\View\\Example . Again, Pub is inferred automatically from the controller type. The second argument is the template name. In this case, we're looking for a template named demo_example . The third argument is an array of template parameters/variables that should be available to the view. This array should generally be key => value pairs. The above example is passing two template params to the template. The key part of the array indicates the name of the variable available within the template. The value part of the array indicates the value. So, if we had the following contents in the demo_example template: {$hello} {$world} The template would output the following: Hello world! Redirect reply \u00b6 This reply is returned when you wish to redirect a user to a different URL after they have completed some sort of action. A common use case here is after a user has submitted data through a form you may wish to redirect them to a different page, for example returning a user to a list of items. Here's an example of a typical controller action that performs a redirect: public function actionRedirect() { return $this->redirect($this->buildLink('demo/example'), 'This is a redirect message.', 'permanent'); } The first argument is the URL to redirect to. This example will redirect the user to the index.php?demo/example URL. The second argument will only display if the form is submitted over an AJAX request which opts to prevent redirecting. The result will be a \"flash message\" which appears from the top of the screen with your chosen message. You do not have to supply your own message. If it is not provided it will default to \"Your changes have been saved\". The third argument defaults to temporary , but you can also opt to set this to permanent as per the example. The only difference here is the type of HTTP response code provided by the server. Temporary is ideal in most cases, and this will respond with a 303 code. permanent will issue a 301 response code. Although you can trigger a permanent redirect in this way, there's actually a specific method for this, which can be used as follows. It also takes a 'message' argument, but as above it is optional. public function actionRedirect() { return $this->redirectPermanently($this->buildLink('demo/example')); } Error reply \u00b6 As the name suggests, this reply is what you will return if you need to display an error to the user. It's somewhat simple, here's an example: public function actionError() { return $this->error('Unfortunately the thing you are looking for could not be found.', 404); } There are only two arguments supported here. The first is the error message you want to display, and the second is the HTTP response code you want the server to send. 404 would represent an appropriate response when something was not found. Message reply \u00b6 This reply is very much similar to the error reply, and supports the same arguments. The main difference is, in terms of appearance, the message displayed is not presented as an error. Exception reply \u00b6 It is sometimes necessary to interrupt the normal flow of your controller code, and reply with an Exception instead. Exception replies do not necessarily have to represent an error; for example, they can be used to force your controller to perform a redirect. However, typically, they will often be used to halt the flow of your controller to display an error, as in the following example: public function actionException() { throw $this->exception($this->error('An unexpected error occurred')); } Exception replies only accept a single argument, and actually that argument must be some other form of Reply object, such as an Error reply . This particular example throws an exception, and the entire controller code at that point will stop, and a standard error will be displayed. Note that exception replies must be \"thrown\" using throw rather than being \"returned\" with return . Reroute reply \u00b6 Under certain conditions, it is necessary to reroute a user to an entirely different controller or action within the same controller, without performing a full redirect, without changing the URL the user has landed on, and without having to duplicate the code of the target action. That looks a little bit like this: public function actionReroute() { return $this->rerouteController(__CLASS__, 'error'); } public function actionError() { return $this->error('Oops! Something went wrong!'); } In this particular example, if a user navigated to the index.php?demo/reroute URL, they would see the error reply from the actionError() method. They would not be redirected, nor would the URL in their browser change; they would simply just receive the reply from the error action. The reroute reply also supports a third argument which allows various parameters to be passed from one controller action to the other. This can either be an array or a ParameterBag object (more on that later). Modifying a controller action reply (properly) \u00b6 In the Extending classes section, we've already seen how simple it is to extend a class, but extra care needs to be taken when extending a controller action that already exists. Unless you have a specific need to override an existing action entirely, and replace it with something new (which is generally not recommended), instead you should be modifying the existing reply of the parent class. That is done quite simply, as an example let's modify the view reply from the View reply example above. public function actionExample() { $reply = parent::actionExample(); return $reply; } Assuming the above is added to an extended controller where the actionExample() method already exists, the above doesn't actually do anything other than return the original view reply. Let's now change the existing hello parameter to read \"Bonjour\" instead of \"Hello\". public function actionExample() { $reply = parent::actionExample(); if ($reply instanceof \\XF\\Mvc\\Reply\\View) { $reply->setParam('hello', 'Bonjour'); } return $reply; } Because a controller reply can actually represent a number of different objects that have different behaviors and methods, it is imperative that we only attempt to extend the correct reply type. We do that in the example above by checking to see if the parent $reply object is actually a View type. If we didn't do this, we extended this action and the controller action replies with a redirect instead, then there would likely be an error. Before extending this action visiting this page would display \"Hello world!\". After extending it, the view will now display \"Bonjour world!\".","title":"Controller basics"},{"location":"controller-basics/#controller-basics","text":"At a basic level, Controllers are the code that is executed when you visit a page within XF. Controllers are generally responsible for handling user input and passing that user input to the appropriate place which, generally, would be to perform some sort of database action (Model) or load visual content (View). When a user clicks a link, the requested URL is routed to a specific controller and controller action. See Routing basics . For example, in XF if you click a URL like index.php?conversations/add you will be routed to the XF\\Pub\\Controller\\Conversation controller and to the add action. If you look at this class in the file system (see Autoloader for a description of how classes and file paths map to each other) you will notice that there are a number of methods named with a prefix of action . All of these methods indicate a specific controller action. So, to see the code involved when viewing the conversations/add page mentioned above, look in this file for public function actionAdd() . XF controllers are responsible for returning a reply object which generally consist of one of the following types:","title":"Controller basics"},{"location":"controller-basics/#view-reply","text":"This is one of the most common replies you will deal with during XF development. A controller which returns a view reply will usually require up to three arguments to be passed in. A view class (more on that below), a template name, and an array of $viewParams which is the data that should be available to the template. Here's a typical example of a controller action which returns a View reply: public function actionExample() { $hello = 'Hello'; $world = 'world!'; $viewParams = [ 'hello' => $hello, 'world' => $world ]; return $this->view('Demo:Example', 'demo_example', $viewParams); } The first argument is the short class name for a specific View class. This class may or may not exist (often it won't need to exist, we'll cover view classes more later) but it should have a roughly unique name for the controller and action. As with other Short class names , the particular short class name above will resolve to Demo\\Pub\\View\\Example . Again, Pub is inferred automatically from the controller type. The second argument is the template name. In this case, we're looking for a template named demo_example . The third argument is an array of template parameters/variables that should be available to the view. This array should generally be key => value pairs. The above example is passing two template params to the template. The key part of the array indicates the name of the variable available within the template. The value part of the array indicates the value. So, if we had the following contents in the demo_example template: {$hello} {$world} The template would output the following: Hello world!","title":"View reply"},{"location":"controller-basics/#redirect-reply","text":"This reply is returned when you wish to redirect a user to a different URL after they have completed some sort of action. A common use case here is after a user has submitted data through a form you may wish to redirect them to a different page, for example returning a user to a list of items. Here's an example of a typical controller action that performs a redirect: public function actionRedirect() { return $this->redirect($this->buildLink('demo/example'), 'This is a redirect message.', 'permanent'); } The first argument is the URL to redirect to. This example will redirect the user to the index.php?demo/example URL. The second argument will only display if the form is submitted over an AJAX request which opts to prevent redirecting. The result will be a \"flash message\" which appears from the top of the screen with your chosen message. You do not have to supply your own message. If it is not provided it will default to \"Your changes have been saved\". The third argument defaults to temporary , but you can also opt to set this to permanent as per the example. The only difference here is the type of HTTP response code provided by the server. Temporary is ideal in most cases, and this will respond with a 303 code. permanent will issue a 301 response code. Although you can trigger a permanent redirect in this way, there's actually a specific method for this, which can be used as follows. It also takes a 'message' argument, but as above it is optional. public function actionRedirect() { return $this->redirectPermanently($this->buildLink('demo/example')); }","title":"Redirect reply"},{"location":"controller-basics/#error-reply","text":"As the name suggests, this reply is what you will return if you need to display an error to the user. It's somewhat simple, here's an example: public function actionError() { return $this->error('Unfortunately the thing you are looking for could not be found.', 404); } There are only two arguments supported here. The first is the error message you want to display, and the second is the HTTP response code you want the server to send. 404 would represent an appropriate response when something was not found.","title":"Error reply"},{"location":"controller-basics/#message-reply","text":"This reply is very much similar to the error reply, and supports the same arguments. The main difference is, in terms of appearance, the message displayed is not presented as an error.","title":"Message reply"},{"location":"controller-basics/#exception-reply","text":"It is sometimes necessary to interrupt the normal flow of your controller code, and reply with an Exception instead. Exception replies do not necessarily have to represent an error; for example, they can be used to force your controller to perform a redirect. However, typically, they will often be used to halt the flow of your controller to display an error, as in the following example: public function actionException() { throw $this->exception($this->error('An unexpected error occurred')); } Exception replies only accept a single argument, and actually that argument must be some other form of Reply object, such as an Error reply . This particular example throws an exception, and the entire controller code at that point will stop, and a standard error will be displayed. Note that exception replies must be \"thrown\" using throw rather than being \"returned\" with return .","title":"Exception reply"},{"location":"controller-basics/#reroute-reply","text":"Under certain conditions, it is necessary to reroute a user to an entirely different controller or action within the same controller, without performing a full redirect, without changing the URL the user has landed on, and without having to duplicate the code of the target action. That looks a little bit like this: public function actionReroute() { return $this->rerouteController(__CLASS__, 'error'); } public function actionError() { return $this->error('Oops! Something went wrong!'); } In this particular example, if a user navigated to the index.php?demo/reroute URL, they would see the error reply from the actionError() method. They would not be redirected, nor would the URL in their browser change; they would simply just receive the reply from the error action. The reroute reply also supports a third argument which allows various parameters to be passed from one controller action to the other. This can either be an array or a ParameterBag object (more on that later).","title":"Reroute reply"},{"location":"controller-basics/#modifying-a-controller-action-reply-properly","text":"In the Extending classes section, we've already seen how simple it is to extend a class, but extra care needs to be taken when extending a controller action that already exists. Unless you have a specific need to override an existing action entirely, and replace it with something new (which is generally not recommended), instead you should be modifying the existing reply of the parent class. That is done quite simply, as an example let's modify the view reply from the View reply example above. public function actionExample() { $reply = parent::actionExample(); return $reply; } Assuming the above is added to an extended controller where the actionExample() method already exists, the above doesn't actually do anything other than return the original view reply. Let's now change the existing hello parameter to read \"Bonjour\" instead of \"Hello\". public function actionExample() { $reply = parent::actionExample(); if ($reply instanceof \\XF\\Mvc\\Reply\\View) { $reply->setParam('hello', 'Bonjour'); } return $reply; } Because a controller reply can actually represent a number of different objects that have different behaviors and methods, it is imperative that we only attempt to extend the correct reply type. We do that in the example above by checking to see if the parent $reply object is actually a View type. If we didn't do this, we extended this action and the controller action replies with a redirect instead, then there would likely be an error. Before extending this action visiting this page would display \"Hello world!\". After extending it, the view will now display \"Bonjour world!\".","title":"Modifying a controller action reply (properly)"},{"location":"criteria/","text":"Criteria \u00b6 When XenForo needs to test something (user/page/post...) against some user selected conditions (criteria), it uses the Criteria system. Some places, where the Criteria system is used: Trophies User-group promotions Forum notices Addons can also use this system. Criteria types \u00b6 Consider the following criteria: User has/has no avatar User has more than 300 messages User is creating a thread right now Current user's selected navigation tab is \"Members\" The first two criteria refer to the user himself. The remaining ones refer to his current location on the forum. It appears we have different categories or types of criteria. There are two criteria types in XenForo out of the box: User criteria \u2014 handling criteria about the user himself Page criteria \u2014 handling criteria about user's current location + time criteria Some addons may also add their own criteria types. From the code perspective, criteria types are simply children of an abstract AbstractCriteria class. They contain code for handling the selected criteria of certain type. AbstractCriteria , in turn, provides a general methods to work with criteria regardless of their meaning. Criterion \u00b6 Criterion is a user selectable predefined condition. Why selectable? Because admins/users can select them (remember trophy creation process). Why predefined? Because XenForo already knows how to handle them (using criteria classes methods). Every criterion consists of two parts: rule and (optionally) data . Rule \u00b6 The criterion rule is simply a sting in snake case (words_are_separated_with_underscore_character). It has two essential purposes: It is used to distinguish criteria When performing matching, the rule is converted into a camel case name of a method that handles this criterion (see \"How criteria works\" ). Data \u00b6 It is just an optional array of additional criterion data. For example, \"User has posted at least X messages\" criterion has a data array with one element: a number of messages. How criteria system works \u00b6 In this sections, we describe how criteria system works from A to Z. Template \u00b6 It all starts from template code. Here is how criteria look inside templates: <xf:checkbox label=\"Criteria container\"> <!-- Criterion --> <xf:option name=\"foo_criteria[criterion_1_rule][rule]\" value=\"criterion_1_rule\" ... /> <!-- Criterion with data --> <xf:option name=\"bar_criteria[criterion_2_rule][rule]\" value=\"criterion_2_rule\" ... > <xf:... name=\"bar_criteria[criterion_2_rule][data][param_1]\" ... /> <xf:... name=\"bar_criteria[criterion_2_rule][data][param_2]\" ... /> </xf:option> </xf:checkbox> As you can see, criterion is simply a checkbox with optional input fields inside (criterion data). Let's analyze the code: foo_criteria and bar_criteria are the input containers and usually foo and bar parts refer to criteria type. For example, user_criteria[...] lets us know that this criteria belong to User criteria. value=\"criterion_1_rule\" and value=\"criterion_2_rule\" are, obviously, the rules of criteria. Note Keep in mind that criterion_1/2_rule in name attributes may not have to be criteria rules! These are just names for input containers. You can easily write <xf:option name=\"foo[bar][rule]\" value=\"criterion_rule\" /> and it will work correctly. The criterion rule will be criterion_rule , not bar . (Optionally) Storing selected criteria \u00b6 Inside the controller, the criteria form data from the previous section can be filtered, encoded and saved in database columns of mediumblob type for better days: $fooCriteriaInput = $this->filter('foo_criteria', 'array'); $barCriteriaInput = $this->filter('bar_criteria', 'array'); $form->basicEntitySave($bazEntity, [ 'foo_criteria' => $fooCriteriaInput, 'bar_criteria' => $barCriteriaInput ]); The example $bazEntity structure: public static function getStructure(Structure $structure) { $structure->table = 'xf_baz'; $structure->shortName = 'XF:Baz'; $structure->primaryKey = 'baz_id'; $structure->columns = [ 'baz_id' => ['type' => self::UINT, 'autoIncrement' => true], 'foo_criteria' => ['type' => self::JSON_ARRAY, 'default' => [], 'required' => 'please_select_criteria_that_must_be_met'], 'bar_criteria' => ['type' => self::JSON_ARRAY, 'default' => []] ]; return $structure; } Criteria object \u00b6 For using criteria system we need to create a criteria object from selected criteria form data. This can be done via app's criteria() method: /** @var \\Qux\\Criteria\\Foo $fooCriteria */ $fooCriteria = \\XF::app()->criteria('Qux:Foo', $bazEntity->foo_criteria); /** @var \\Qux\\Criteria\\Bar $barCriteria */ $barCriteria = \\XF::app()->criteria('Qux:Bar', $bazEntity->bar_criteria); From now, we can use all AbstractCriteria functionality plus everything we have additionally written in child Foo / Bar classes. Matching \u00b6 When we want to check, whether something (User) matches the selected criteria or not, we use isMatched method: $visitor= \\XF::visitor(); if ($fooCriteria->isMatched($visitor)) { // Visitor matches all selected criteria } else { // Visitor does not match one or more criteria } isMacthed() converts criterion rule into camel case name of a method with _match prefix: criterion_1_rule > _matchCriterion1Rule and tries to find such a method inside criteria type class ( Foo class in our example): // Qux/Criteria/Foo.php protected function _matchCriterion1Rule(array $data, \\XF\\Entity\\User $user) { /* ... Handling criteria ... */ return true; // User matches current criteria /* OR */ return false; // User does not match current criteria } If some method can't be found in class, isMatched() calls isUnknownMatched() which behaviour can be set in AbstractCriteria ancestors (returns false by default). If none criteria were selected, isMatched() returns $matchOnEmpty variable which equals true by default. You can change this behaviour by calling $crteriaObj->setMatchOnEmpty(false) before using isMatched() method: $visitor= \\XF::visitor(); $fooCriteria->setMatchOnEmpty(false); if ($fooCriteria->isMatched($visitor)) { // Visitor matches all selected criteria } else { // Visitor does not match one or more criteria } How criteria works (example) \u00b6 Imagine you want to award with a trophy all users who have an avatar and have received at least 5 likes. When creating a trophy, you select \"User has an avatar\" (rule has_avatar ) and \"User has received at least X likes\" (rule like_count ) criteria. The last one also has a data array with one element: a number of likes. Your selected criteria stores in user_criteria column in xf_trophy table. When XenForo decides to check, whether to award a user with a trophy or not, it converts rules into camel case method names: like_count > _matchLikeCount() has_avatar > _matchHasAvatar() Since both of selected criteria are User criteria, XenForo addresses the User criteria class and tries to find such methods in it: // XF/Criteria/User.php //... protected function _matchLikeCount(array $data, \\XF\\Entity\\User $user) { return ($user->like_count && $user->like_count >= $data['likes']); } //... protected function _matchHasAvatar(array $data, \\XF\\Entity\\User $user) { return $user->user_id && ($user->avatar_date || $user->gravatar); } //... If all addressed methods return true , our user matches the selected criteria and therefore will be awarded with a trophy. If some methods can't be found in User criteria class, XenForo calls isUnknownMatched() method, which in turn fires criteria_user event, allowing addon makers to add their custom criteria handlers (see \"Custom User/Page criterion example\" ). Extra criteria data \u00b6 Sometimes, when writing criteria template code, you need to access extra data, that is not passed with view params. This is what getExtraTemplateData() method exists. By default, it contains existing user groups, languages, styles, time zones. You can override this method in you custom criteria type class . Adding data in custom criteria type \u00b6 Override getExtraTemplateData() method in your custom criteria class: public function getExtraTemplateData() { $templateData = parent::getExtraTemplateData(); $additionalData = []; /** @var \\XF\\Repository\\Smilie $smilieRepo */ $smilieRepo = \\XF::repository('XF:Smilie'); $additionalData['smilies'] = $smilieRepo->findSmiliesForList()->fetch(); return array_merge($templateData, $additionalData); } Adding data to existing criteria types \u00b6 You can use criteria_template_data event listener to add you own extra criteria data: public static function criteriaTemplateData(array &$templateData) { /** @var \\XF\\Repository\\Smilie $smilieRepo */ $smilieRepo = \\XF::repository('XF:Smilie'); $templateData['smilies'] = $smilieRepo->findSmiliesForList()->fetch(); } \"helper_criteria\" template \u00b6 Whenever you as addon maker want to get a target user/admin a way to select User/Page/other addon's criteria (or even all at once), you can simply use helper_criteria . In short, helper_criteria is an admin template that allows to use criteria types checkbox-based interface in multiply places without copy-pasting the same code. helper_criteria contains macros of two types: *criteria_name*_tabs and *criteria_name*_panes for every criteria type. Example: user_tabs and user_panes macros for User criteria type. Tabs \u00b6 Tabs are used to distinguish different criteria types within the template they are used: When using tabs, the first one often contains fields/options that are not related to criteria. Then goes criteria tabs. In the image above, the first tab contains options for notice. First two tabs in the red box are related to User criteria type. The last one is related to Page criteria type. Tabs in helper_criteria are grouped under criteria types macros: <xf:macro name=\"foo_tabs\" arg-container=\"\" arg-active=\"\"> <xf:set var=\"$tabs\"> <a class=\"tabs-tab{{ $active == 'foo' ? ' is-active' : '' }}\" role=\"tab\" tabindex=\"0\" aria-controls=\"{{ unique_id('criteriaFoo') }}\">Foo criteria</a> <a class=\"tabs-tab{{ $active == 'foo_extra' ? ' is-active' : '' }}\" role=\"tab\" tabindex=\"0\" aria-controls=\"{{ unique_id('criteriaFooExtra') }}\">Foo criteria extra</a> </xf:set> <xf:if is=\"$container\"> <div class=\"tabs\" role=\"tablist\"> {$tabs|raw} </div> <xf:else /> {$tabs|raw} </xf:if> </xf:macro> In the code above, foo is a criteria type. It has two tabs, one for general foo criteria and another for extra foo criteria. Panes \u00b6 Panes simply contain criteria. Just like tabs, panes in helper_criteria are grouped under criteria types macros: <xf:macro name=\"foo_panes\" arg-container=\"\" arg-active=\"\" arg-criteria=\"!\" arg-data=\"!\"> <xf:set var=\"$panes\"> <li class=\"{{ $active == 'foo' ? ' is-active' : '' }}\" role=\"tabpanel\" id=\"{{ unique_id('criteriaFoo') }}\"> <xf:checkboxrow label=\"Criteria group 1\"> <xf:option name=\"foo_criteria[criterion_1_rule][rule]\" value=\"criterion_1_rule\" ... /> <xf:option name=\"foo_criteria[criterion_2_rule][rule]\" value=\"criterion_2_rule\" ... /> </xf:checkboxrow> <xf:checkboxrow label=\"Criteria group 2\"> <xf:option name=\"foo_criteria[criterion_3_rule][rule]\" value=\"criterion_3_rule\" ... /> <xf:option name=\"foo_criteria[criterion_4_rule][rule]\" value=\"criterion_4_rule\" ... /> </xf:checkboxrow> </li> </xf:set> <xf:if is=\"$container\"> <ul class=\"tabPanes\"> {$panes|raw} </ul> <xf:else /> {$panes|raw} </xf:if> </xf:macro> Using \"helper_criteria\" \u00b6 To use \"helper_criteria\" functionality, you need to include its macros. Preparing data \u00b6 This section can be skipped if you don't have your selected criteria saved somewhere in database or the criteria type you want to use does't require any extra data. First of all, you need to retrieve saved selected criteria and create a criteria object from them. In this section, we will be using Page criteria as an example: $savedCriteria = /* Retrieve it somehow... */ // Criteria object $criteria = $this->app()->criteria('XF:Page', $savedCriteria)->getCriteriaForTemplate(); // Criteria extra data $criteriaData = $criteria->getExtraTemplateData(); $viewParams = [ /* ... */ 'criteria' => $criteria, 'criteriaData' => $criteriaData ]; return $this->view(/* ... */, $viewParams); Including without tabs \u00b6 To include criteria without tabs you need to use an <xf:macro... tag with arg-container attribute set to 0 : <xf:macro template=\"helper_criteria\" name=\"page_panes\" arg-container=\"0\" arg-criteria=\"{$criteria}\" arg-data=\"{$criteriaData}\" /> If you don't have saved criteria, you can just pass empty array {{ [] }} to an arg-criteria attribute. Don't forget to replace page in page_panes to the name of criteria type you want to use. Keep in mind that all criteria is wrapped with <li> tag so you will need to apply some CSS styling ( list-style-type: none; for example). With tabs \u00b6 In order to use criteria tabs, you will need to organise the page. Stick to the following example structure: <xf:form ... class=\"block\"> <div class=\"block-container\"> <!-- Tabs --> <h2 class=\"block-tabHeader tabs hScroller\" data-xf-init=\"h-scroller tabs\" role=\"tablist\"> <span class=\"hScroller-scroll\"> <!-- Main tab where fields/options are located --> <a class=\"tabs-tab is-active\" role=\"tab\" tabindex=\"0\" aria-controls=\"MAIN_TAB_ID\">Main tab title</a> <!-- Criteria tabs --> <xf:macro template=\"helper_criteria\" name=\"page_tabs\" arg-userTabTitle=\"Custom tab name (optionally)\" /> </span> </h2> <!-- Panes --> <ul class=\"block-body tabPanes\"> <!-- Main pane --> <li class=\"is-active\" role=\"tabpanel\" id=\"MAIN_TAB_ID\"> <!-- Fields and options --> </li> <!-- Criteria panes --> <xf:macro template=\"helper_criteria\" name=\"page_panes\" arg-criteria=\"{$criteria}\" arg-data=\"{$criteriaData}\" /> </ul> <xf:submitrow sticky=\"true\" icon=\"save\" /> </div> </xf:form> Again, if you don't have any saved or even don't suppose to have it, pass {{ [] }} to an arg-criteria attribute. Adding custom criteria type to \"helper_criteria\" \u00b6 If you want to add a custom criteria type to helper_criteira template, you will need to create a template modification of helper_criteria template. Go to \"Appearance > Template modifications\" in ACP, switch to \"Admin\" tab and hit \"Add template modification\" button. We want to add our tab and pane at the very bottom of the template so switch \"Search type\" to \"Regular expression\". Type /$/ in \"Find\" field. Finally, add the tab and the pane macros code in \"Replace\" field. Example: <xf:macro name=\"foo_tabs\" arg-container=\"\" arg-active=\"\"> <xf:set var=\"$tabs\"> <a class=\"tabs-tab{{ $active == 'foo' ? ' is-active' : '' }}\" role=\"tab\" tabindex=\"0\" aria-controls=\"{{ unique_id('criteriaFoo') }}\">Foo criteria</a> <a class=\"tabs-tab{{ $active == 'foo_extra' ? ' is-active' : '' }}\" role=\"tab\" tabindex=\"0\" aria-controls=\"{{ unique_id('criteriaFooExtra') }}\">Foo criteria extra</a> </xf:set> <xf:if is=\"$container\"> <div class=\"tabs\" role=\"tablist\"> {$tabs|raw} </div> <xf:else /> {$tabs|raw} </xf:if> </xf:macro> <xf:macro name=\"foo_panes\" arg-container=\"\" arg-active=\"\" arg-criteria=\"!\" arg-data=\"!\"> <xf:set var=\"$panes\"> <li class=\"{{ $active == 'foo' ? ' is-active' : '' }}\" role=\"tabpanel\" id=\"{{ unique_id('criteriaFoo') }}\"> <xf:checkboxrow label=\"Criteria group 1\"> <xf:option name=\"foo_criteria[criterion_1_rule][rule]\" value=\"criterion_1_rule\" ... /> <xf:option name=\"foo_criteria[criterion_2_rule][rule]\" value=\"criterion_2_rule\" ... /> </xf:checkboxrow> <xf:checkboxrow label=\"Criteria group 2\"> <xf:option name=\"foo_criteria[criterion_3_rule][rule]\" value=\"criterion_3_rule\" ... /> <xf:option name=\"foo_criteria[criterion_4_rule][rule]\" value=\"criterion_4_rule\" ... /> </xf:checkboxrow> </li> </xf:set> <xf:if is=\"$container\"> <ul class=\"tabPanes\"> {$panes|raw} </ul> <xf:else /> {$panes|raw} </xf:if> </xf:macro> Now, you can use your criteria everywhere (see \"Using helper_criteria\" ). Custom User/Page criterion example \u00b6 Let's say we want to create a criterion for checking whether our user has X or more likes on single message or not. Since our criterion refers to user, we will be creating a criterion which belongs to User criteria. Adding template modification \u00b6 First of all, we need to add our criterion to User criteria list. Go to \"Template modifications\" page in ACP, select \"Admin\" tab and hit \"Add template modification\" button in the upper right corner. Warning If there is no \"Admin\" tab make sure you have enabled the development mode ! We will be modifying the helper_criteria template so write it to the \"Template\" field. In this example I will be using likes_on_single_message \"Modification key\" for this template modification. Our criterion is about likes on messages. This means it should be under \"Content and achievements\" section. This means we simply need to find <!--[XF:user:content_bottom]--> and replace it with the following code: <xf:option name=\"user_criteria[likes_on_single][rule]\" value=\"likes_on_single\" selected=\"{$criteria.likes_on_single}\" label=\"Likes on single message:\"> <xf:numberbox name=\"user_criteria[likes_on_single][data][likes]\" value=\"{$criteria.likes_on_single.likes}\" size=\"5\" min=\"0\" step=\"1\" /> </xf:option> $0 From this moment we can already see and even set a value for our criterion when creating trophies, notices and user-group promotions. Adding code event listener \u00b6 We have created our criterion. But it is unknown for XenForo, which will always return false when matching such criteria. We need to tell XenForo, what to do when it meets unknown criteria. Go to \"Development > Code event listener\" page and hit \"Add code event listener\" button. Select criteria_user in \"Listen to event\" field ( user because our criterion belongs to User criteria). In \"Execute callback\" field we should specify class and method to be called when matching criteria. Create a file Listener.php in addon root folder if you haven't already and add a new method criteriaUser there: <?php namespace YOUR_ADDON_ID; class Listener { public static function criteriaUser($rule, array $data, \\XF\\Entity\\User $user, &$returnValue) { } } You can fill \"Class\" and \"Method\" fields with YOUR_ADDON_ID\\Listener and criteriaUser , respectively. Handling criterion \u00b6 Since our criteriaUser method is fired for every unknown criteria, we need to make sure $rule equals likes_on_single (the rule we specified in HTML markup): public static function criteriaUser($rule, array $data, \\XF\\Entity\\User $user, &$returnValue) { switch ($rule) { case 'likes_on_single': /** Handling code here! */ break; } } Now, we need to write the code that actually checks whether a user has a message with X or more likes. This can be easily achieved via simple SQL query, which selects one record from xf_post with more than X likes ( likes column) and user_id equals currently matching user ID. So, here is the query: SELECT `likes` FROM `xf_post` WHERE `user_id` = ? ORDER BY `likes` DESC LIMIT 1 And the method code: public static function criteriaUser($rule, array $data, \\XF\\Entity\\User $user, &$returnValue) { switch ($rule) { case 'likes_on_single': // Getting the database $db = \\XF::db(); // Database query for selecting the maximum number of likes for single user post $query = \"SELECT `likes` FROM `xf_post` WHERE `user_id` = ? ORDER BY `likes` DESC LIMIT 1\"; // Retrieving the maximum number of likes $likes = $db->fetchOne($query, [$user->user_id]); // Checking that we have a result from database (we do expect a number) if (is_int($likes)) { // Returning true if user has a message with X or more likes or false if he has not $returnValue = ($likes >= $data['likes']); } else { $returnValue = false; } break; } } Pay attention to the following: We are using $user variable for retrieving currently matching user. We can use this variable since our criterion belongs to User criteria. We can access data via $data array. It contains data from fields we have added in template modification. We have only added one <xf:numberbox... which name attribute equals user_criteria[likes_on_single][data][likes] . That is why we can use $data['likes'] in the code above. Everything is done right now. Let's test it! Testing (trophy) \u00b6 Create an \"All for one\" trophy. On \"User criteria\" tab, \"Likes on single message\" field with, for example, 5. Next, create a test message somewhere on you forum and then like it five times with five different users (or just set manually set a value of likes column). Then, go to \"Tools > Cron entries\" and run \"Update user trophies\" cron by hitting arrows-circle button. Nice! Warning If you are not awarded with \"All for one\" trophy, try to sign out, sign in and re-running \"Update user trophies\" cron. Testing (notice) \u00b6 Go to \"Communication > Notices\" and hit \"Add notice\" button. On \"User criteria\" tab, set \"Likes on single message\" field with, again, 5. Save the notice. Next, create a test message somewhere on you forum and then like it five times with five different users (or just set manually set a value of likes column). Now, you should see a notice: You can download addon sources built based on this example (2.0.10). Custom criteria type example \u00b6 Imagine we are creating an addon (addon ID: PostsRemover ) for removing all posts that match selected criteria. A list of available criteria: Post has at least X likes Post author has an X username Post was edited at least X times Post was edited no more than X times Post was published before X Post was published after X Obviously, for such criteria we need a new criteria type: Post criteria. Criteria type class \u00b6 We should start by creating a new class Post that inherits AbstractCriteria within Criteria directory of our addon: <?php namespace PostsRemover\\Criteria; use XF\\Criteria\\AbstractCriteria; class Post extends AbstractCriteria { } Now we need to write code for all criteria out addon supports. In this example, I will write the code for the first three criteria from the list above: <?php namespace PostsRemover\\Criteria; use XF\\Criteria\\AbstractCriteria; class Post extends AbstractCriteria { // Post has at least X likes protected function _matchLikeCount(array $data, \\XF\\Entity\\Post $post) { return ($post->likes && $post->likes >= $data['likes']); } // Post author has an X username protected function _matchUsername(array $data, \\XF\\Entity\\Post $post) { return $post->username === $data['name']; } // Post was edited at least X times protected function _matchEditedCount(array $data, \\XF\\Entity\\Post $post) { return $post->edit_count && $post->edit_count >= $data['count']; } /* ================ Handling other criteria ================ */ } isMatched(...) method used to call _match methods we just created accepts only User entity, we are to write a custom variation of isMatched() , isUnknownMatched() and isSpecialMatched() methods. Since we are creating Post criteria, we need to create our own isMatchedPost() method: public function isMatchedPost(\\XF\\Entity\\Post $post) { if (!$this->criteria) { return $this->matchOnEmpty; } foreach ($this->criteria AS $criterion) { $rule = $criterion['rule']; $data = $criterion['data']; $specialResult = $this->isSpecialMatchedPost($rule, $data, $post); if ($specialResult === false) { return false; } else if ($specialResult === true) { continue; } $method = '_match' . \\XF\\Util\\Php::camelCase($rule); if (method_exists($this, $method)) { $result = $this->$method($data, $post); if (!$result) { return false; } } else { if (!$this->isUnknownMatched($rule, $data, $post)) { return false; } } } return true; } protected function isSpecialMatchedPost($rule, array $data, \\XF\\Entity\\Post $post) { return null; } protected function isUnknownMatchedPost($rule, array $data, \\XF\\Entity\\Post $post) { return false; } We simply used isMatched(...) method code replacing $user variable of User entity type with $post variable of Post entity type. As we do not plan to handle special and unknown criteria we return null in isSpecialMatchedPost and false in isUnknownMathcedPost methods. Template \u00b6 Leaving the process of adding an admin route, writing a controller and doing other actions behind the scenes, let's jump right to our page's template code: <xf:title>Posts Remover</xf:title> <xf:form action=\"{{ link('posts-remover/remove') }}\" ajax=\"true\" class=\"block\"> <div class=\"block-container\"> <xf:checkboxrow label=\"Post criteria\"> <xf:option label=\"Post has at least X likes\" name=\"post_criteria[like_count][rule]\" value=\"like_count\"> <xf:numberbox name=\"post_criteria[like_count][data][likes]\" size=\"5\" min=\"0\" step=\"1\" /> </xf:option> <xf:option label=\"Post author has an X username\" name=\"post_criteria[username][rule]\" value=\"username\"> <xf:textbox name=\"post_criteria[username][data][name]\" ac=\"true\" /> </xf:option> <xf:option label=\"Post was edited at least X times\" name=\"post_criteria[edited_count][rule]\" value=\"edited_count\"> <xf:numberbox name=\"post_criteria[edited_count][data][count]\" size=\"5\" min=\"0\" step=\"1\" /> </xf:option> </xf:checkboxrow> <!-- Template code for other criteria --> <xf:submitrow sticky=\"true\" icon=\"delete\"/> </div> </xf:form> Matching the criteria \u00b6 In the controller of our page, we need to create a method called actionRemove for handling \"Remove\" button click: public function actionRemove() { } Firstly, let's retrieve post_criteria array from page form: public function actionRemove() { $postCriteriaInput = $this->filter('post_criteria', 'array'); } Secondly, we need to create a criteria object from retrieved page form data: public function actionRemove() { $postCriteriaInput = $this->filter('post_criteria', 'array'); /** @var \\PostsRemover\\Criteria\\Post $postCriteria */ $postCriteria = $this->app()->criteria('PostsRemover:Post', $postCriteriaInput); } By default, out post will match the empty criteria (when nothing has been selected) which will result in deletion of all forum posts. To avoid this we need to manually set the result of matching the empty criteria via setMatchOnEmpty() method: public function actionRemove() { $postCriteriaInput = $this->filter('post_criteria', 'array'); /** @var \\PostsRemover\\Criteria\\Post $postCriteria */ $postCriteria = $this->app()->criteria('PostsRemover:Post', $postCriteriaInput); $postCriteria->setMatchOnEmpty(false); // If no criteria selected, nothing will be removed } Finally, we need to match all forum posts against selected criteria. If the post matches the criteria, we will delete it: public function actionRemove() { $postCriteriaInput = $this->filter('post_criteria', 'array'); /** @var \\PostsRemover\\Criteria\\Post $postCriteria */ $postCriteria = $this->app()->criteria('PostsRemover:Post', $postCriteriaInput); $postCriteria->setMatchOnEmpty(false); // If no criteria selected, nothing will be removed // Getting all forum posts $posts = $this->finder('XF:Post')->fetch(); $deletedCounter = 0; /** @var \\XF\\Entity\\Post $post */ foreach ($posts as $post) { if ($postCriteria->isMatchedPost($post)) // Checking the post against selected criteria { $post->delete(); // Deleting it if the post matches the selected criteria $deletedCounter++; } } return $this->message('Done! ' . $deletedCounter . ' posts were removed!'); } Note Keep in mind that we use isMatchedPost($post) method for XenForo versions below 2.1! Warning It is generally a bad practice to retrieve all entities from database at once ( $this->finder('XF:Post')->fetch(); in the code above). There could be millions of forum posts and selecting them all at once is going to be a very long process, which might end up with an error. Consider using a Job system for working with dozens (100+) of database items. Testing \u00b6 Time to test our custom criteria type! I have created three posts on my test forum. The first one was liked 500 times, the second one was edited 5 times. The third one is just an ordinary untouched post without likes. Now, on our \"Posts Remover\" ACP page, let's select \"Post has at least X likes\" (with value of 250) and \"Post was edited at least X times\" (wih value of 5): When I hit \"Delete\" button, I saw a flash message telling me that nothing was deleted. Why? Obviously, because there are no posts with at least 250 likes and at least 5 edits in the same time . That is why we need to select the first criterion only, then hit \"Delete\". This will delete a post with 500 likes. Next, we need to select the last criterion only and preform deletion. The post with 5 edits will be removed. As a result, only one test post survived out test: You can download addon sources built based on this example (2.0.10). You will find \"Posts Remover\" ACP page under \"Tools\" section.","title":"Criteria"},{"location":"criteria/#criteria","text":"When XenForo needs to test something (user/page/post...) against some user selected conditions (criteria), it uses the Criteria system. Some places, where the Criteria system is used: Trophies User-group promotions Forum notices Addons can also use this system.","title":"Criteria"},{"location":"criteria/#criteria-types","text":"Consider the following criteria: User has/has no avatar User has more than 300 messages User is creating a thread right now Current user's selected navigation tab is \"Members\" The first two criteria refer to the user himself. The remaining ones refer to his current location on the forum. It appears we have different categories or types of criteria. There are two criteria types in XenForo out of the box: User criteria \u2014 handling criteria about the user himself Page criteria \u2014 handling criteria about user's current location + time criteria Some addons may also add their own criteria types. From the code perspective, criteria types are simply children of an abstract AbstractCriteria class. They contain code for handling the selected criteria of certain type. AbstractCriteria , in turn, provides a general methods to work with criteria regardless of their meaning.","title":"Criteria types"},{"location":"criteria/#criterion","text":"Criterion is a user selectable predefined condition. Why selectable? Because admins/users can select them (remember trophy creation process). Why predefined? Because XenForo already knows how to handle them (using criteria classes methods). Every criterion consists of two parts: rule and (optionally) data .","title":"Criterion"},{"location":"criteria/#rule","text":"The criterion rule is simply a sting in snake case (words_are_separated_with_underscore_character). It has two essential purposes: It is used to distinguish criteria When performing matching, the rule is converted into a camel case name of a method that handles this criterion (see \"How criteria works\" ).","title":"Rule"},{"location":"criteria/#data","text":"It is just an optional array of additional criterion data. For example, \"User has posted at least X messages\" criterion has a data array with one element: a number of messages.","title":"Data"},{"location":"criteria/#how-criteria-system-works","text":"In this sections, we describe how criteria system works from A to Z.","title":"How criteria system works"},{"location":"criteria/#template","text":"It all starts from template code. Here is how criteria look inside templates: <xf:checkbox label=\"Criteria container\"> <!-- Criterion --> <xf:option name=\"foo_criteria[criterion_1_rule][rule]\" value=\"criterion_1_rule\" ... /> <!-- Criterion with data --> <xf:option name=\"bar_criteria[criterion_2_rule][rule]\" value=\"criterion_2_rule\" ... > <xf:... name=\"bar_criteria[criterion_2_rule][data][param_1]\" ... /> <xf:... name=\"bar_criteria[criterion_2_rule][data][param_2]\" ... /> </xf:option> </xf:checkbox> As you can see, criterion is simply a checkbox with optional input fields inside (criterion data). Let's analyze the code: foo_criteria and bar_criteria are the input containers and usually foo and bar parts refer to criteria type. For example, user_criteria[...] lets us know that this criteria belong to User criteria. value=\"criterion_1_rule\" and value=\"criterion_2_rule\" are, obviously, the rules of criteria. Note Keep in mind that criterion_1/2_rule in name attributes may not have to be criteria rules! These are just names for input containers. You can easily write <xf:option name=\"foo[bar][rule]\" value=\"criterion_rule\" /> and it will work correctly. The criterion rule will be criterion_rule , not bar .","title":"Template"},{"location":"criteria/#optionally-storing-selected-criteria","text":"Inside the controller, the criteria form data from the previous section can be filtered, encoded and saved in database columns of mediumblob type for better days: $fooCriteriaInput = $this->filter('foo_criteria', 'array'); $barCriteriaInput = $this->filter('bar_criteria', 'array'); $form->basicEntitySave($bazEntity, [ 'foo_criteria' => $fooCriteriaInput, 'bar_criteria' => $barCriteriaInput ]); The example $bazEntity structure: public static function getStructure(Structure $structure) { $structure->table = 'xf_baz'; $structure->shortName = 'XF:Baz'; $structure->primaryKey = 'baz_id'; $structure->columns = [ 'baz_id' => ['type' => self::UINT, 'autoIncrement' => true], 'foo_criteria' => ['type' => self::JSON_ARRAY, 'default' => [], 'required' => 'please_select_criteria_that_must_be_met'], 'bar_criteria' => ['type' => self::JSON_ARRAY, 'default' => []] ]; return $structure; }","title":"(Optionally) Storing selected criteria"},{"location":"criteria/#criteria-object","text":"For using criteria system we need to create a criteria object from selected criteria form data. This can be done via app's criteria() method: /** @var \\Qux\\Criteria\\Foo $fooCriteria */ $fooCriteria = \\XF::app()->criteria('Qux:Foo', $bazEntity->foo_criteria); /** @var \\Qux\\Criteria\\Bar $barCriteria */ $barCriteria = \\XF::app()->criteria('Qux:Bar', $bazEntity->bar_criteria); From now, we can use all AbstractCriteria functionality plus everything we have additionally written in child Foo / Bar classes.","title":"Criteria object"},{"location":"criteria/#matching","text":"When we want to check, whether something (User) matches the selected criteria or not, we use isMatched method: $visitor= \\XF::visitor(); if ($fooCriteria->isMatched($visitor)) { // Visitor matches all selected criteria } else { // Visitor does not match one or more criteria } isMacthed() converts criterion rule into camel case name of a method with _match prefix: criterion_1_rule > _matchCriterion1Rule and tries to find such a method inside criteria type class ( Foo class in our example): // Qux/Criteria/Foo.php protected function _matchCriterion1Rule(array $data, \\XF\\Entity\\User $user) { /* ... Handling criteria ... */ return true; // User matches current criteria /* OR */ return false; // User does not match current criteria } If some method can't be found in class, isMatched() calls isUnknownMatched() which behaviour can be set in AbstractCriteria ancestors (returns false by default). If none criteria were selected, isMatched() returns $matchOnEmpty variable which equals true by default. You can change this behaviour by calling $crteriaObj->setMatchOnEmpty(false) before using isMatched() method: $visitor= \\XF::visitor(); $fooCriteria->setMatchOnEmpty(false); if ($fooCriteria->isMatched($visitor)) { // Visitor matches all selected criteria } else { // Visitor does not match one or more criteria }","title":"Matching"},{"location":"criteria/#how-criteria-works-example","text":"Imagine you want to award with a trophy all users who have an avatar and have received at least 5 likes. When creating a trophy, you select \"User has an avatar\" (rule has_avatar ) and \"User has received at least X likes\" (rule like_count ) criteria. The last one also has a data array with one element: a number of likes. Your selected criteria stores in user_criteria column in xf_trophy table. When XenForo decides to check, whether to award a user with a trophy or not, it converts rules into camel case method names: like_count > _matchLikeCount() has_avatar > _matchHasAvatar() Since both of selected criteria are User criteria, XenForo addresses the User criteria class and tries to find such methods in it: // XF/Criteria/User.php //... protected function _matchLikeCount(array $data, \\XF\\Entity\\User $user) { return ($user->like_count && $user->like_count >= $data['likes']); } //... protected function _matchHasAvatar(array $data, \\XF\\Entity\\User $user) { return $user->user_id && ($user->avatar_date || $user->gravatar); } //... If all addressed methods return true , our user matches the selected criteria and therefore will be awarded with a trophy. If some methods can't be found in User criteria class, XenForo calls isUnknownMatched() method, which in turn fires criteria_user event, allowing addon makers to add their custom criteria handlers (see \"Custom User/Page criterion example\" ).","title":"How criteria works (example)"},{"location":"criteria/#extra-criteria-data","text":"Sometimes, when writing criteria template code, you need to access extra data, that is not passed with view params. This is what getExtraTemplateData() method exists. By default, it contains existing user groups, languages, styles, time zones. You can override this method in you custom criteria type class .","title":"Extra criteria data"},{"location":"criteria/#adding-data-in-custom-criteria-type","text":"Override getExtraTemplateData() method in your custom criteria class: public function getExtraTemplateData() { $templateData = parent::getExtraTemplateData(); $additionalData = []; /** @var \\XF\\Repository\\Smilie $smilieRepo */ $smilieRepo = \\XF::repository('XF:Smilie'); $additionalData['smilies'] = $smilieRepo->findSmiliesForList()->fetch(); return array_merge($templateData, $additionalData); }","title":"Adding data in custom criteria type"},{"location":"criteria/#adding-data-to-existing-criteria-types","text":"You can use criteria_template_data event listener to add you own extra criteria data: public static function criteriaTemplateData(array &$templateData) { /** @var \\XF\\Repository\\Smilie $smilieRepo */ $smilieRepo = \\XF::repository('XF:Smilie'); $templateData['smilies'] = $smilieRepo->findSmiliesForList()->fetch(); }","title":"Adding data to existing criteria types"},{"location":"criteria/#helper_criteria-template","text":"Whenever you as addon maker want to get a target user/admin a way to select User/Page/other addon's criteria (or even all at once), you can simply use helper_criteria . In short, helper_criteria is an admin template that allows to use criteria types checkbox-based interface in multiply places without copy-pasting the same code. helper_criteria contains macros of two types: *criteria_name*_tabs and *criteria_name*_panes for every criteria type. Example: user_tabs and user_panes macros for User criteria type.","title":"\"helper_criteria\" template"},{"location":"criteria/#tabs","text":"Tabs are used to distinguish different criteria types within the template they are used: When using tabs, the first one often contains fields/options that are not related to criteria. Then goes criteria tabs. In the image above, the first tab contains options for notice. First two tabs in the red box are related to User criteria type. The last one is related to Page criteria type. Tabs in helper_criteria are grouped under criteria types macros: <xf:macro name=\"foo_tabs\" arg-container=\"\" arg-active=\"\"> <xf:set var=\"$tabs\"> <a class=\"tabs-tab{{ $active == 'foo' ? ' is-active' : '' }}\" role=\"tab\" tabindex=\"0\" aria-controls=\"{{ unique_id('criteriaFoo') }}\">Foo criteria</a> <a class=\"tabs-tab{{ $active == 'foo_extra' ? ' is-active' : '' }}\" role=\"tab\" tabindex=\"0\" aria-controls=\"{{ unique_id('criteriaFooExtra') }}\">Foo criteria extra</a> </xf:set> <xf:if is=\"$container\"> <div class=\"tabs\" role=\"tablist\"> {$tabs|raw} </div> <xf:else /> {$tabs|raw} </xf:if> </xf:macro> In the code above, foo is a criteria type. It has two tabs, one for general foo criteria and another for extra foo criteria.","title":"Tabs"},{"location":"criteria/#panes","text":"Panes simply contain criteria. Just like tabs, panes in helper_criteria are grouped under criteria types macros: <xf:macro name=\"foo_panes\" arg-container=\"\" arg-active=\"\" arg-criteria=\"!\" arg-data=\"!\"> <xf:set var=\"$panes\"> <li class=\"{{ $active == 'foo' ? ' is-active' : '' }}\" role=\"tabpanel\" id=\"{{ unique_id('criteriaFoo') }}\"> <xf:checkboxrow label=\"Criteria group 1\"> <xf:option name=\"foo_criteria[criterion_1_rule][rule]\" value=\"criterion_1_rule\" ... /> <xf:option name=\"foo_criteria[criterion_2_rule][rule]\" value=\"criterion_2_rule\" ... /> </xf:checkboxrow> <xf:checkboxrow label=\"Criteria group 2\"> <xf:option name=\"foo_criteria[criterion_3_rule][rule]\" value=\"criterion_3_rule\" ... /> <xf:option name=\"foo_criteria[criterion_4_rule][rule]\" value=\"criterion_4_rule\" ... /> </xf:checkboxrow> </li> </xf:set> <xf:if is=\"$container\"> <ul class=\"tabPanes\"> {$panes|raw} </ul> <xf:else /> {$panes|raw} </xf:if> </xf:macro>","title":"Panes"},{"location":"criteria/#using-helper_criteria","text":"To use \"helper_criteria\" functionality, you need to include its macros.","title":"Using \"helper_criteria\""},{"location":"criteria/#preparing-data","text":"This section can be skipped if you don't have your selected criteria saved somewhere in database or the criteria type you want to use does't require any extra data. First of all, you need to retrieve saved selected criteria and create a criteria object from them. In this section, we will be using Page criteria as an example: $savedCriteria = /* Retrieve it somehow... */ // Criteria object $criteria = $this->app()->criteria('XF:Page', $savedCriteria)->getCriteriaForTemplate(); // Criteria extra data $criteriaData = $criteria->getExtraTemplateData(); $viewParams = [ /* ... */ 'criteria' => $criteria, 'criteriaData' => $criteriaData ]; return $this->view(/* ... */, $viewParams);","title":"Preparing data"},{"location":"criteria/#including-without-tabs","text":"To include criteria without tabs you need to use an <xf:macro... tag with arg-container attribute set to 0 : <xf:macro template=\"helper_criteria\" name=\"page_panes\" arg-container=\"0\" arg-criteria=\"{$criteria}\" arg-data=\"{$criteriaData}\" /> If you don't have saved criteria, you can just pass empty array {{ [] }} to an arg-criteria attribute. Don't forget to replace page in page_panes to the name of criteria type you want to use. Keep in mind that all criteria is wrapped with <li> tag so you will need to apply some CSS styling ( list-style-type: none; for example).","title":"Including without tabs"},{"location":"criteria/#with-tabs","text":"In order to use criteria tabs, you will need to organise the page. Stick to the following example structure: <xf:form ... class=\"block\"> <div class=\"block-container\"> <!-- Tabs --> <h2 class=\"block-tabHeader tabs hScroller\" data-xf-init=\"h-scroller tabs\" role=\"tablist\"> <span class=\"hScroller-scroll\"> <!-- Main tab where fields/options are located --> <a class=\"tabs-tab is-active\" role=\"tab\" tabindex=\"0\" aria-controls=\"MAIN_TAB_ID\">Main tab title</a> <!-- Criteria tabs --> <xf:macro template=\"helper_criteria\" name=\"page_tabs\" arg-userTabTitle=\"Custom tab name (optionally)\" /> </span> </h2> <!-- Panes --> <ul class=\"block-body tabPanes\"> <!-- Main pane --> <li class=\"is-active\" role=\"tabpanel\" id=\"MAIN_TAB_ID\"> <!-- Fields and options --> </li> <!-- Criteria panes --> <xf:macro template=\"helper_criteria\" name=\"page_panes\" arg-criteria=\"{$criteria}\" arg-data=\"{$criteriaData}\" /> </ul> <xf:submitrow sticky=\"true\" icon=\"save\" /> </div> </xf:form> Again, if you don't have any saved or even don't suppose to have it, pass {{ [] }} to an arg-criteria attribute.","title":"With tabs"},{"location":"criteria/#adding-custom-criteria-type-to-helper_criteria","text":"If you want to add a custom criteria type to helper_criteira template, you will need to create a template modification of helper_criteria template. Go to \"Appearance > Template modifications\" in ACP, switch to \"Admin\" tab and hit \"Add template modification\" button. We want to add our tab and pane at the very bottom of the template so switch \"Search type\" to \"Regular expression\". Type /$/ in \"Find\" field. Finally, add the tab and the pane macros code in \"Replace\" field. Example: <xf:macro name=\"foo_tabs\" arg-container=\"\" arg-active=\"\"> <xf:set var=\"$tabs\"> <a class=\"tabs-tab{{ $active == 'foo' ? ' is-active' : '' }}\" role=\"tab\" tabindex=\"0\" aria-controls=\"{{ unique_id('criteriaFoo') }}\">Foo criteria</a> <a class=\"tabs-tab{{ $active == 'foo_extra' ? ' is-active' : '' }}\" role=\"tab\" tabindex=\"0\" aria-controls=\"{{ unique_id('criteriaFooExtra') }}\">Foo criteria extra</a> </xf:set> <xf:if is=\"$container\"> <div class=\"tabs\" role=\"tablist\"> {$tabs|raw} </div> <xf:else /> {$tabs|raw} </xf:if> </xf:macro> <xf:macro name=\"foo_panes\" arg-container=\"\" arg-active=\"\" arg-criteria=\"!\" arg-data=\"!\"> <xf:set var=\"$panes\"> <li class=\"{{ $active == 'foo' ? ' is-active' : '' }}\" role=\"tabpanel\" id=\"{{ unique_id('criteriaFoo') }}\"> <xf:checkboxrow label=\"Criteria group 1\"> <xf:option name=\"foo_criteria[criterion_1_rule][rule]\" value=\"criterion_1_rule\" ... /> <xf:option name=\"foo_criteria[criterion_2_rule][rule]\" value=\"criterion_2_rule\" ... /> </xf:checkboxrow> <xf:checkboxrow label=\"Criteria group 2\"> <xf:option name=\"foo_criteria[criterion_3_rule][rule]\" value=\"criterion_3_rule\" ... /> <xf:option name=\"foo_criteria[criterion_4_rule][rule]\" value=\"criterion_4_rule\" ... /> </xf:checkboxrow> </li> </xf:set> <xf:if is=\"$container\"> <ul class=\"tabPanes\"> {$panes|raw} </ul> <xf:else /> {$panes|raw} </xf:if> </xf:macro> Now, you can use your criteria everywhere (see \"Using helper_criteria\" ).","title":"Adding custom criteria type to \"helper_criteria\""},{"location":"criteria/#custom-userpage-criterion-example","text":"Let's say we want to create a criterion for checking whether our user has X or more likes on single message or not. Since our criterion refers to user, we will be creating a criterion which belongs to User criteria.","title":"Custom User/Page criterion example"},{"location":"criteria/#adding-template-modification","text":"First of all, we need to add our criterion to User criteria list. Go to \"Template modifications\" page in ACP, select \"Admin\" tab and hit \"Add template modification\" button in the upper right corner. Warning If there is no \"Admin\" tab make sure you have enabled the development mode ! We will be modifying the helper_criteria template so write it to the \"Template\" field. In this example I will be using likes_on_single_message \"Modification key\" for this template modification. Our criterion is about likes on messages. This means it should be under \"Content and achievements\" section. This means we simply need to find <!--[XF:user:content_bottom]--> and replace it with the following code: <xf:option name=\"user_criteria[likes_on_single][rule]\" value=\"likes_on_single\" selected=\"{$criteria.likes_on_single}\" label=\"Likes on single message:\"> <xf:numberbox name=\"user_criteria[likes_on_single][data][likes]\" value=\"{$criteria.likes_on_single.likes}\" size=\"5\" min=\"0\" step=\"1\" /> </xf:option> $0 From this moment we can already see and even set a value for our criterion when creating trophies, notices and user-group promotions.","title":"Adding template modification"},{"location":"criteria/#adding-code-event-listener","text":"We have created our criterion. But it is unknown for XenForo, which will always return false when matching such criteria. We need to tell XenForo, what to do when it meets unknown criteria. Go to \"Development > Code event listener\" page and hit \"Add code event listener\" button. Select criteria_user in \"Listen to event\" field ( user because our criterion belongs to User criteria). In \"Execute callback\" field we should specify class and method to be called when matching criteria. Create a file Listener.php in addon root folder if you haven't already and add a new method criteriaUser there: <?php namespace YOUR_ADDON_ID; class Listener { public static function criteriaUser($rule, array $data, \\XF\\Entity\\User $user, &$returnValue) { } } You can fill \"Class\" and \"Method\" fields with YOUR_ADDON_ID\\Listener and criteriaUser , respectively.","title":"Adding code event listener"},{"location":"criteria/#handling-criterion","text":"Since our criteriaUser method is fired for every unknown criteria, we need to make sure $rule equals likes_on_single (the rule we specified in HTML markup): public static function criteriaUser($rule, array $data, \\XF\\Entity\\User $user, &$returnValue) { switch ($rule) { case 'likes_on_single': /** Handling code here! */ break; } } Now, we need to write the code that actually checks whether a user has a message with X or more likes. This can be easily achieved via simple SQL query, which selects one record from xf_post with more than X likes ( likes column) and user_id equals currently matching user ID. So, here is the query: SELECT `likes` FROM `xf_post` WHERE `user_id` = ? ORDER BY `likes` DESC LIMIT 1 And the method code: public static function criteriaUser($rule, array $data, \\XF\\Entity\\User $user, &$returnValue) { switch ($rule) { case 'likes_on_single': // Getting the database $db = \\XF::db(); // Database query for selecting the maximum number of likes for single user post $query = \"SELECT `likes` FROM `xf_post` WHERE `user_id` = ? ORDER BY `likes` DESC LIMIT 1\"; // Retrieving the maximum number of likes $likes = $db->fetchOne($query, [$user->user_id]); // Checking that we have a result from database (we do expect a number) if (is_int($likes)) { // Returning true if user has a message with X or more likes or false if he has not $returnValue = ($likes >= $data['likes']); } else { $returnValue = false; } break; } } Pay attention to the following: We are using $user variable for retrieving currently matching user. We can use this variable since our criterion belongs to User criteria. We can access data via $data array. It contains data from fields we have added in template modification. We have only added one <xf:numberbox... which name attribute equals user_criteria[likes_on_single][data][likes] . That is why we can use $data['likes'] in the code above. Everything is done right now. Let's test it!","title":"Handling criterion"},{"location":"criteria/#testing-trophy","text":"Create an \"All for one\" trophy. On \"User criteria\" tab, \"Likes on single message\" field with, for example, 5. Next, create a test message somewhere on you forum and then like it five times with five different users (or just set manually set a value of likes column). Then, go to \"Tools > Cron entries\" and run \"Update user trophies\" cron by hitting arrows-circle button. Nice! Warning If you are not awarded with \"All for one\" trophy, try to sign out, sign in and re-running \"Update user trophies\" cron.","title":"Testing (trophy)"},{"location":"criteria/#testing-notice","text":"Go to \"Communication > Notices\" and hit \"Add notice\" button. On \"User criteria\" tab, set \"Likes on single message\" field with, again, 5. Save the notice. Next, create a test message somewhere on you forum and then like it five times with five different users (or just set manually set a value of likes column). Now, you should see a notice: You can download addon sources built based on this example (2.0.10).","title":"Testing (notice)"},{"location":"criteria/#custom-criteria-type-example","text":"Imagine we are creating an addon (addon ID: PostsRemover ) for removing all posts that match selected criteria. A list of available criteria: Post has at least X likes Post author has an X username Post was edited at least X times Post was edited no more than X times Post was published before X Post was published after X Obviously, for such criteria we need a new criteria type: Post criteria.","title":"Custom criteria type example"},{"location":"criteria/#criteria-type-class","text":"We should start by creating a new class Post that inherits AbstractCriteria within Criteria directory of our addon: <?php namespace PostsRemover\\Criteria; use XF\\Criteria\\AbstractCriteria; class Post extends AbstractCriteria { } Now we need to write code for all criteria out addon supports. In this example, I will write the code for the first three criteria from the list above: <?php namespace PostsRemover\\Criteria; use XF\\Criteria\\AbstractCriteria; class Post extends AbstractCriteria { // Post has at least X likes protected function _matchLikeCount(array $data, \\XF\\Entity\\Post $post) { return ($post->likes && $post->likes >= $data['likes']); } // Post author has an X username protected function _matchUsername(array $data, \\XF\\Entity\\Post $post) { return $post->username === $data['name']; } // Post was edited at least X times protected function _matchEditedCount(array $data, \\XF\\Entity\\Post $post) { return $post->edit_count && $post->edit_count >= $data['count']; } /* ================ Handling other criteria ================ */ } isMatched(...) method used to call _match methods we just created accepts only User entity, we are to write a custom variation of isMatched() , isUnknownMatched() and isSpecialMatched() methods. Since we are creating Post criteria, we need to create our own isMatchedPost() method: public function isMatchedPost(\\XF\\Entity\\Post $post) { if (!$this->criteria) { return $this->matchOnEmpty; } foreach ($this->criteria AS $criterion) { $rule = $criterion['rule']; $data = $criterion['data']; $specialResult = $this->isSpecialMatchedPost($rule, $data, $post); if ($specialResult === false) { return false; } else if ($specialResult === true) { continue; } $method = '_match' . \\XF\\Util\\Php::camelCase($rule); if (method_exists($this, $method)) { $result = $this->$method($data, $post); if (!$result) { return false; } } else { if (!$this->isUnknownMatched($rule, $data, $post)) { return false; } } } return true; } protected function isSpecialMatchedPost($rule, array $data, \\XF\\Entity\\Post $post) { return null; } protected function isUnknownMatchedPost($rule, array $data, \\XF\\Entity\\Post $post) { return false; } We simply used isMatched(...) method code replacing $user variable of User entity type with $post variable of Post entity type. As we do not plan to handle special and unknown criteria we return null in isSpecialMatchedPost and false in isUnknownMathcedPost methods.","title":"Criteria type class"},{"location":"criteria/#template_1","text":"Leaving the process of adding an admin route, writing a controller and doing other actions behind the scenes, let's jump right to our page's template code: <xf:title>Posts Remover</xf:title> <xf:form action=\"{{ link('posts-remover/remove') }}\" ajax=\"true\" class=\"block\"> <div class=\"block-container\"> <xf:checkboxrow label=\"Post criteria\"> <xf:option label=\"Post has at least X likes\" name=\"post_criteria[like_count][rule]\" value=\"like_count\"> <xf:numberbox name=\"post_criteria[like_count][data][likes]\" size=\"5\" min=\"0\" step=\"1\" /> </xf:option> <xf:option label=\"Post author has an X username\" name=\"post_criteria[username][rule]\" value=\"username\"> <xf:textbox name=\"post_criteria[username][data][name]\" ac=\"true\" /> </xf:option> <xf:option label=\"Post was edited at least X times\" name=\"post_criteria[edited_count][rule]\" value=\"edited_count\"> <xf:numberbox name=\"post_criteria[edited_count][data][count]\" size=\"5\" min=\"0\" step=\"1\" /> </xf:option> </xf:checkboxrow> <!-- Template code for other criteria --> <xf:submitrow sticky=\"true\" icon=\"delete\"/> </div> </xf:form>","title":"Template"},{"location":"criteria/#matching-the-criteria","text":"In the controller of our page, we need to create a method called actionRemove for handling \"Remove\" button click: public function actionRemove() { } Firstly, let's retrieve post_criteria array from page form: public function actionRemove() { $postCriteriaInput = $this->filter('post_criteria', 'array'); } Secondly, we need to create a criteria object from retrieved page form data: public function actionRemove() { $postCriteriaInput = $this->filter('post_criteria', 'array'); /** @var \\PostsRemover\\Criteria\\Post $postCriteria */ $postCriteria = $this->app()->criteria('PostsRemover:Post', $postCriteriaInput); } By default, out post will match the empty criteria (when nothing has been selected) which will result in deletion of all forum posts. To avoid this we need to manually set the result of matching the empty criteria via setMatchOnEmpty() method: public function actionRemove() { $postCriteriaInput = $this->filter('post_criteria', 'array'); /** @var \\PostsRemover\\Criteria\\Post $postCriteria */ $postCriteria = $this->app()->criteria('PostsRemover:Post', $postCriteriaInput); $postCriteria->setMatchOnEmpty(false); // If no criteria selected, nothing will be removed } Finally, we need to match all forum posts against selected criteria. If the post matches the criteria, we will delete it: public function actionRemove() { $postCriteriaInput = $this->filter('post_criteria', 'array'); /** @var \\PostsRemover\\Criteria\\Post $postCriteria */ $postCriteria = $this->app()->criteria('PostsRemover:Post', $postCriteriaInput); $postCriteria->setMatchOnEmpty(false); // If no criteria selected, nothing will be removed // Getting all forum posts $posts = $this->finder('XF:Post')->fetch(); $deletedCounter = 0; /** @var \\XF\\Entity\\Post $post */ foreach ($posts as $post) { if ($postCriteria->isMatchedPost($post)) // Checking the post against selected criteria { $post->delete(); // Deleting it if the post matches the selected criteria $deletedCounter++; } } return $this->message('Done! ' . $deletedCounter . ' posts were removed!'); } Note Keep in mind that we use isMatchedPost($post) method for XenForo versions below 2.1! Warning It is generally a bad practice to retrieve all entities from database at once ( $this->finder('XF:Post')->fetch(); in the code above). There could be millions of forum posts and selecting them all at once is going to be a very long process, which might end up with an error. Consider using a Job system for working with dozens (100+) of database items.","title":"Matching the criteria"},{"location":"criteria/#testing","text":"Time to test our custom criteria type! I have created three posts on my test forum. The first one was liked 500 times, the second one was edited 5 times. The third one is just an ordinary untouched post without likes. Now, on our \"Posts Remover\" ACP page, let's select \"Post has at least X likes\" (with value of 250) and \"Post was edited at least X times\" (wih value of 5): When I hit \"Delete\" button, I saw a flash message telling me that nothing was deleted. Why? Obviously, because there are no posts with at least 250 likes and at least 5 edits in the same time . That is why we need to select the first criterion only, then hit \"Delete\". This will delete a post with 500 likes. Next, we need to select the last criterion only and preform deletion. The post with 5 edits will be removed. As a result, only one test post survived out test: You can download addon sources built based on this example (2.0.10). You will find \"Posts Remover\" ACP page under \"Tools\" section.","title":"Testing"},{"location":"designing-styles/","text":"Designing styles \u00b6 In XF2 we have introduced an all new way to build and edit styles called \"Designer mode\". Designer mode is a collection of CLI tools that allow you to modify certain templates within a style directly on the file system. It also outputs various metadata and information about style properties which is useful for version control and collaboration. Enabling designer mode \u00b6 The first step to enabling designer mode is to enable it in config.php : $config['designer']['enabled'] = true; Optionally, you can also specify a different path for designer mode files to exist on the file system. The following represents the default location. To change the location, add the below to your config.php and modify the path accordingly: $config['designer']['basePath'] = 'src/styles'; Enabling designer mode for a style \u00b6 Designer mode must be explicitly enabled for each style. We enable designer mode on a style by using the CLI and specifying the style ID of the style, and choosing a \"designer mode ID\": Terminal $ php cmd.php xf-designer:enable [style_id] [designer_mode_id] The designer mode ID is the identifier you will use for future commands related to designer mode. Once enabled, the current modified components of the style will be exported to the [basePath]/[designer_mode_id] directory. When enabling designer mode for this style if that directory already exists you will be given a choice to make as to whether we should overwrite the current contents of that directory from the style, or whether we should overwrite the current style from the current contents of that directory. Disabling designer mode for a style \u00b6 To disable designer mode for a style, you just run the following CLI command: Terminal $ php cmd.php xf-designer:disable [designer_mode_id] By default, this will keep the copy of the designer mode output on the file system. To remove the data, you can run the same command with the --clear option: Terminal $ php cmd.php xf-designer:disable [designer_mode_id] --clear What is output and where? \u00b6 It is important to remember that a style within XF only consists of what is modified in that style . This means that designer mode output will only consist of what has been modified in the style. Templates and style properties which are modified in a parent style is not output. Templates \u00b6 Templates will be output to the [basePath]/[designer_mode_id]/templates directory. Within that directory you may have another directory for each type (e.g. admin, email and public). The templates will be output in HTML format and are directly editable on the file system. Changes made on the file system are imported and compiled when that template is loaded on a page. Similarly, you can revert a template by deleting it from the file system (if it was previously modified). Style properties and groups \u00b6 Style properties and groups will be output to the [basePath]/[designer_mode_id]/style_properties and [basePath]/[designer_mode_id]/style_property_groups directories. They are exported in JSON format and serve as a useful way to monitor changes to these files via a version control system. It is not recommended to modify these files directly as changes to them will not be automatically imported like they are with templates. Modifying a specific template \u00b6 Bearing in mind that a style represents components which are modified within that style only, when designer mode is enabled, the file system will also contain only components which are modified within that style only. It would not be possible to output the effective version of each template and style property. To mark a template as modified within a style, you can do it in the usual way by editing it in the Admin CP. Templates and style properties modified in the Admin CP will automatically be written out to the file system if designer mode is enabled. However, it would likely be more convenient to modify or \"touch\" a template using a CLI command: Terminal $ php cmd.php xf-designer:touch-template [designer_mode_id] [template_type:template_title] As long as the specified template exists in a parent or the master style, it will be copied to the current style and output to the file system. You can then modify the template directly in the file system. If you would like to create an entirely custom template in your style (that doesn't exist in any other style within the tree), you can use the same command but you would just pass the --custom option: Terminal $ php cmd.php xf-designer:touch-template [designer_mode_id] [template_type:template_title] --custom Other useful commands \u00b6 There are a number of other useful commands relating to designer mode: Export from database \u00b6 This command is usually automatically run when designer mode is enabled on a style, but if for some reason you would like to overwrite the file system copy with what is currently in the database, then you can run the following command: Terminal $ php cmd.php xf-designer:export [designer_mode_id] It's also possible to export only specific types, e.g. xf-designer:export-templates . Import from file system \u00b6 This command will overwrite the database copy of the style with what is on the file system: Terminal $ php cmd.php xf-designer:import [designer_mode_id] It's also possible to import only specific types, e.g. xf-designer:import-templates . Sync templates \u00b6 This command is similar to importing templates (see above) but instead of overwriting everything it will only import templates and recompile them if the metadata has changed. It will also apply version number updates accordingly. Terminal $ php cmd.php xf-designer:sync-templates [designer_mode_id] Revert template \u00b6 This command can be used to revert a template, effectively deleting the custom version from the current style. Terminal $ php cmd.php xf-designer:revert-template [designer_mode_id] [template_type:template_title] It's also possible to trigger a revert by removing the template from the file system.","title":"Designing styles"},{"location":"designing-styles/#designing-styles","text":"In XF2 we have introduced an all new way to build and edit styles called \"Designer mode\". Designer mode is a collection of CLI tools that allow you to modify certain templates within a style directly on the file system. It also outputs various metadata and information about style properties which is useful for version control and collaboration.","title":"Designing styles"},{"location":"designing-styles/#enabling-designer-mode","text":"The first step to enabling designer mode is to enable it in config.php : $config['designer']['enabled'] = true; Optionally, you can also specify a different path for designer mode files to exist on the file system. The following represents the default location. To change the location, add the below to your config.php and modify the path accordingly: $config['designer']['basePath'] = 'src/styles';","title":"Enabling designer mode"},{"location":"designing-styles/#enabling-designer-mode-for-a-style","text":"Designer mode must be explicitly enabled for each style. We enable designer mode on a style by using the CLI and specifying the style ID of the style, and choosing a \"designer mode ID\": Terminal $ php cmd.php xf-designer:enable [style_id] [designer_mode_id] The designer mode ID is the identifier you will use for future commands related to designer mode. Once enabled, the current modified components of the style will be exported to the [basePath]/[designer_mode_id] directory. When enabling designer mode for this style if that directory already exists you will be given a choice to make as to whether we should overwrite the current contents of that directory from the style, or whether we should overwrite the current style from the current contents of that directory.","title":"Enabling designer mode for a style"},{"location":"designing-styles/#disabling-designer-mode-for-a-style","text":"To disable designer mode for a style, you just run the following CLI command: Terminal $ php cmd.php xf-designer:disable [designer_mode_id] By default, this will keep the copy of the designer mode output on the file system. To remove the data, you can run the same command with the --clear option: Terminal $ php cmd.php xf-designer:disable [designer_mode_id] --clear","title":"Disabling designer mode for a style"},{"location":"designing-styles/#what-is-output-and-where","text":"It is important to remember that a style within XF only consists of what is modified in that style . This means that designer mode output will only consist of what has been modified in the style. Templates and style properties which are modified in a parent style is not output.","title":"What is output and where?"},{"location":"designing-styles/#templates","text":"Templates will be output to the [basePath]/[designer_mode_id]/templates directory. Within that directory you may have another directory for each type (e.g. admin, email and public). The templates will be output in HTML format and are directly editable on the file system. Changes made on the file system are imported and compiled when that template is loaded on a page. Similarly, you can revert a template by deleting it from the file system (if it was previously modified).","title":"Templates"},{"location":"designing-styles/#style-properties-and-groups","text":"Style properties and groups will be output to the [basePath]/[designer_mode_id]/style_properties and [basePath]/[designer_mode_id]/style_property_groups directories. They are exported in JSON format and serve as a useful way to monitor changes to these files via a version control system. It is not recommended to modify these files directly as changes to them will not be automatically imported like they are with templates.","title":"Style properties and groups"},{"location":"designing-styles/#modifying-a-specific-template","text":"Bearing in mind that a style represents components which are modified within that style only, when designer mode is enabled, the file system will also contain only components which are modified within that style only. It would not be possible to output the effective version of each template and style property. To mark a template as modified within a style, you can do it in the usual way by editing it in the Admin CP. Templates and style properties modified in the Admin CP will automatically be written out to the file system if designer mode is enabled. However, it would likely be more convenient to modify or \"touch\" a template using a CLI command: Terminal $ php cmd.php xf-designer:touch-template [designer_mode_id] [template_type:template_title] As long as the specified template exists in a parent or the master style, it will be copied to the current style and output to the file system. You can then modify the template directly in the file system. If you would like to create an entirely custom template in your style (that doesn't exist in any other style within the tree), you can use the same command but you would just pass the --custom option: Terminal $ php cmd.php xf-designer:touch-template [designer_mode_id] [template_type:template_title] --custom","title":"Modifying a specific template"},{"location":"designing-styles/#other-useful-commands","text":"There are a number of other useful commands relating to designer mode:","title":"Other useful commands"},{"location":"designing-styles/#export-from-database","text":"This command is usually automatically run when designer mode is enabled on a style, but if for some reason you would like to overwrite the file system copy with what is currently in the database, then you can run the following command: Terminal $ php cmd.php xf-designer:export [designer_mode_id] It's also possible to export only specific types, e.g. xf-designer:export-templates .","title":"Export from database"},{"location":"designing-styles/#import-from-file-system","text":"This command will overwrite the database copy of the style with what is on the file system: Terminal $ php cmd.php xf-designer:import [designer_mode_id] It's also possible to import only specific types, e.g. xf-designer:import-templates .","title":"Import from file system"},{"location":"designing-styles/#sync-templates","text":"This command is similar to importing templates (see above) but instead of overwriting everything it will only import templates and recompile them if the metadata has changed. It will also apply version number updates accordingly. Terminal $ php cmd.php xf-designer:sync-templates [designer_mode_id]","title":"Sync templates"},{"location":"designing-styles/#revert-template","text":"This command can be used to revert a template, effectively deleting the custom version from the current style. Terminal $ php cmd.php xf-designer:revert-template [designer_mode_id] [template_type:template_title] It's also possible to trigger a revert by removing the template from the file system.","title":"Revert template"},{"location":"development-tools/","text":"Development tools \u00b6 XF2 provides developers with a number of built in tools you can use to expedite development of add-ons and we'll go through some of these below. Debug mode \u00b6 Debug mode can be enabled in your config.php which will allow you to access certain development tools in the Admin CP (such as creating routes, permissions, admin navigation etd.) and it will also enable an output at the bottom of every page which details how long the page took to process, how many queries were executed to render the page and how much memory was used. A tooltip containing information about the current controller, action and template name is available on hover. You can also click on the time output and this will give you a detailed look at exactly what queries ran and the stack trace that led to that query being executed. You can enable debug mode by adding the following to config.php : $config['debug'] = true; Enabling development mode \u00b6 Development mode is a special mode, activated in your config.php file which will trigger XF to automatically write out your development files to your _output directory. This mode needs to be enabled for filesystem template editing to be enabled. As development mode will be writing files to your file system it is important to ensure you have the appropriate file permissions in place. This may vary depending on environment, but a typical configuration would be to ensure that for any add-on you are working on, you have its _output directory set chmod to 0777 . For example, if you are working on an add-on with an ID of Demo , its development output will be written out to src/addons/Demo/_output and therefore that directory will need to be fully writable. Enabling development mode, also enables debug mode automatically. To enable development mode, add the following lines to your config.php file: $config['development']['enabled'] = true; $config['development']['defaultAddOn'] = 'SomeCompany/MyAddOn'; The defaultAddOn value is optional, but adding that will automatically populate the specified add-on in the XF Admin CP when creating new content which will be associated to an add-on. In addition to the above, you may find it necessary to add some additional configuration, especially if you are using more than one XF installation. $config['enableMail'] = false; This will disable all mail from being sent from your board. This is especially important if you are using a copy of live data with real users and real email addresses (though we would advise against this!). As an alternative to disabling mail directly, you may want to consider using a service such as MailTrap.io . This provides you with a free mailbox that will receive all emails sent from your board, which is very useful for testing any emails your new add-on may be sending. $config['cookie']['prefix'] = 'anything_'; If you're using two or more XF installs on the same domain, you may experience issues with cookies being overwritten, which is caused by the installations sharing the same cookie prefix. It's therefore recommended to ensure you change the cookie prefix for each XF install you have set up. Without doing that, you will experience issues, for example, getting logged out of one XF install when logging into another. Development commands \u00b6 XF 2.0 ships with a number of general development and add-on CLI commands which are aimed to help you develop more efficiently or even possibly automate/script some common processes. In this section we'll go through some of the common tools and explain what they do. Add-on specific commands \u00b6 Creating a new add-on \u00b6 Terminal $ php cmd.php xf-addon:create The xf-addon:create command is how to initially set up and create a new add-on. Once it runs, all you need to answer are some basic questions: Enter an ID for this add-on Enter a title Enter a version ID (e.g. 1000010) Enter a version string (e.g. 1.0.0 Alpha) You will then be given the option to create the add-on and write out its addon.json file, and asked some questions about whether you want to add a Setup.php file. Export _data .XML files \u00b6 Terminal $ php cmd.php xf-addon:export [addon_id] This command is what you will use to export all of your add-on's data to XML files inside the _data directory. It exports the data from what is currently in the database (rather than from the development output files). Bump your add-on version \u00b6 Terminal $ php cmd.php xf-addon:bump-version [addon_id] --version-id 1020370 --version-string 1.2.3 Note If your version string contains spaces, you'll need to surround it with quotes. This command takes the add-on ID for your add-on, the new version ID and the new version string. This enables you to bump the version of your add-on in a single step, without having to perform upgrades and rebuilds yourself. The options above are optional, and if they are not provided you will be prompted for them. If you only specify the version ID, we will try and infer the correct version string from that automatically if it matches our Recommended version ID format . Once the command completes, it updates the addon.json file automatically and the database with the correct version details. Sync your addon.json to the database \u00b6 Terminal $ php cmd.php xf-addon:sync-json [addon_id] Sometimes you might prefer to edit the JSON file directly with certain details. This could be the version, or a new icon, or a change of title or description. Changing the JSON in this way can cause the add-on system to believe there are pending changes or that the add-on is upgradeable. A rebuild or upgrade can be a destructive operation if you haven't yet exported your current data. Therefore, running this command is recommended as a way of importing that data in without affecting your existing data. Validate your addon.json file \u00b6 Terminal $ php cmd.php xf-addon:validate-json [addon_id] If you'd like to check your JSON file contains the correct content and in the correct format, you can now validate it. The validator will check that the content can be decoded, that it contains all of the correct required fields (such as title and version ID) and also checks for the presence of the optional keys (such as description and icon). If any keys are missing, you will be offered to have the issues fixed for you. We also check to see if there are any unexpected fields within the JSON file. These may be deliberate or represent typos. You can run the command manually or the command will be run automatically while building your release. Run a specific Setup step \u00b6 Sometimes it's useful to check that your Setup class steps function correctly, without having to go through the process of uninstalling and reinstalling. There are three commands which help with this. These commands will only work with Setup classes that are built using the default StepRunner traits. Run an install step \u00b6 Terminal $ php cmd.php xf-addon:install-step [addon_id] [step] Run an upgrade step \u00b6 Terminal $ php cmd.php xf-addon:upgrade-step [addon_id] [version] [step] Run an uninstall step \u00b6 Terminal $ php cmd.php xf-addon:uninstall-step [addon_id] [step] Building an add-on release \u00b6 Once all of the hard work has been done, it's a shame to have to go through a number of other processes before you can actually release it. Even the process of collecting all of the files into the correct place and creating the ZIP file manually can be time consuming and prone to errors. We can take care of that automatically, including generating the hashes.json file, with one simple command. Terminal $ php cmd.php xf-addon:build-release [addon_id] When you run this command, it will first run the xf-addon:export command before then collecting all of your files together into a temporary _build directory and writing them to a ZIP file. The finished ZIP will also include the hashes.json file. Once the ZIP has been created it will be saved to your _releases directory named and named <ADDON ID>-<VERSION STRING>.zip . Customizing the build process \u00b6 Aside from just creating the release ZIP there may be additional files you wish to include in your ZIP, other more advanced build processes you want to run such as minifying or concatenating JS or running certain shell commands. All of this can be taken care of in your build.json file. This is a typical build.json file: { \"additional_files\": [ \"js/demo/portal\" ], \"minify\": [ \"js/demo/portal/a.js\", \"js/demo/portal/b.js\" ], \"rollup\": { \"js/demo/portal/ab-rollup.js\": [ \"js/demo/portal/a.min.js\", \"js/demo/portal/b.min.js\" ] }, \"exec\": [ \"echo '{title} version {version_string} ({version_id}) has been built successfully!' > 'src/addons/Demo/Portal/_build/built.txt'\" ] } If you have assets, such as JavaScript, which need to be served outside of your add-on directory, you can tell the build process to copy files or directories using the additional_files array within build.json . During development it isn't always feasible to keep files outside of your add-on directory, so if you prefer, you can keep the files in your add-on _files directory instead. When copying the additional files, we will check there first. If you ship some JS files with your add-on, you may want to minify those files for performance reasons. You can specify which files you want to minify right inside your build.json . You can list these as an array or you can just specify it as '*' which will just minify everything in your js directory as long as that path has JS files within it after copying the additional files to the build. Any files minified will automatically have a suffix of .min.js instead of .js and the original files will still be in the package. You may prefer to roll up your multiple JS files into a single file. If you do, you can use the rollup array to define that. The key is the resulting combined filename, and the items within that array are the paths to the JS files that will be combined into a single file. Finally, you may have certain processes that need to be run just before the package is built and finalised. This could be any combination of things. Ultimately, if it is a command that can be run from the shell (including PHP scripts) then you can specify it here. The example above is of course fairly useless, but it does at least demonstrate that certain placeholders can be used. These placeholders are replaced with scalar values you can get from the XF\\AddOn\\AddOn object which is generally any value available in the addon.json file, or the AddOn entity. Development commands \u00b6 There are actually quite a few development related commands, but only the two most important ones are being covered here. To use any of these commands, you must have development mode enabled in your config.php file. Warning Both of the following commands can potentially cause data loss if there is a situation whereby the database and _output directory become out of sync. It is always recommended to use a VCS (Version Control System) such as GitHub to mitigate the impact of such mistakes. Import development output \u00b6 Terminal $ php cmd.php xf-dev:import --addon [addon_id] Running this command will import all of the development output files from your add-on _output directory into the database. Export development output \u00b6 Terminal $ php cmd.php xf-dev:export --addon [addon_id] This will export all data currently associated to your add-on in the database to files within your _output directory. Debugging code \u00b6 It should be possible to set up your favourite debugger tool (XDebug, Zend Debugger etc.) to work with XF2. Though, sometimes, debugging code can be as rudimentary as just quickly seeing what value (or value type) a variable holds at a given time. Dump a variable \u00b6 PHP of course has a tool built-in to handle this. You'll likely know it as var_dump() . XF ships with two replacements for this: \\XF::dump($var); \\XF::dumpSimple($var); The simple version mostly just dumps out the value of a variable in plain text. For example, if you just use it to dump the value of an array, you will see an output at the top of the page like this: array(2) { [\"user_id\"] => int(1) [\"username\"] => string(5) \"Admin\" } This is actually the same output as a standard var_dump, but slightly modified for readability and wrapped inside <pre> tags to ensure whitespace is maintained when rendering. The alternative is actually a component named VarDumper from the Symfony project. It outputs HTML, CSS and JS to create a much more functional and potentially easier to read output. It allows you to collapse certain sections, and for certain values which can output a considerable amount of data, such as objects, it can collapse those sections automatically.","title":"Development tools"},{"location":"development-tools/#development-tools","text":"XF2 provides developers with a number of built in tools you can use to expedite development of add-ons and we'll go through some of these below.","title":"Development tools"},{"location":"development-tools/#debug-mode","text":"Debug mode can be enabled in your config.php which will allow you to access certain development tools in the Admin CP (such as creating routes, permissions, admin navigation etd.) and it will also enable an output at the bottom of every page which details how long the page took to process, how many queries were executed to render the page and how much memory was used. A tooltip containing information about the current controller, action and template name is available on hover. You can also click on the time output and this will give you a detailed look at exactly what queries ran and the stack trace that led to that query being executed. You can enable debug mode by adding the following to config.php : $config['debug'] = true;","title":"Debug mode"},{"location":"development-tools/#enabling-development-mode","text":"Development mode is a special mode, activated in your config.php file which will trigger XF to automatically write out your development files to your _output directory. This mode needs to be enabled for filesystem template editing to be enabled. As development mode will be writing files to your file system it is important to ensure you have the appropriate file permissions in place. This may vary depending on environment, but a typical configuration would be to ensure that for any add-on you are working on, you have its _output directory set chmod to 0777 . For example, if you are working on an add-on with an ID of Demo , its development output will be written out to src/addons/Demo/_output and therefore that directory will need to be fully writable. Enabling development mode, also enables debug mode automatically. To enable development mode, add the following lines to your config.php file: $config['development']['enabled'] = true; $config['development']['defaultAddOn'] = 'SomeCompany/MyAddOn'; The defaultAddOn value is optional, but adding that will automatically populate the specified add-on in the XF Admin CP when creating new content which will be associated to an add-on. In addition to the above, you may find it necessary to add some additional configuration, especially if you are using more than one XF installation. $config['enableMail'] = false; This will disable all mail from being sent from your board. This is especially important if you are using a copy of live data with real users and real email addresses (though we would advise against this!). As an alternative to disabling mail directly, you may want to consider using a service such as MailTrap.io . This provides you with a free mailbox that will receive all emails sent from your board, which is very useful for testing any emails your new add-on may be sending. $config['cookie']['prefix'] = 'anything_'; If you're using two or more XF installs on the same domain, you may experience issues with cookies being overwritten, which is caused by the installations sharing the same cookie prefix. It's therefore recommended to ensure you change the cookie prefix for each XF install you have set up. Without doing that, you will experience issues, for example, getting logged out of one XF install when logging into another.","title":"Enabling development mode"},{"location":"development-tools/#development-commands","text":"XF 2.0 ships with a number of general development and add-on CLI commands which are aimed to help you develop more efficiently or even possibly automate/script some common processes. In this section we'll go through some of the common tools and explain what they do.","title":"Development commands"},{"location":"development-tools/#add-on-specific-commands","text":"","title":"Add-on specific commands"},{"location":"development-tools/#creating-a-new-add-on","text":"Terminal $ php cmd.php xf-addon:create The xf-addon:create command is how to initially set up and create a new add-on. Once it runs, all you need to answer are some basic questions: Enter an ID for this add-on Enter a title Enter a version ID (e.g. 1000010) Enter a version string (e.g. 1.0.0 Alpha) You will then be given the option to create the add-on and write out its addon.json file, and asked some questions about whether you want to add a Setup.php file.","title":"Creating a new add-on"},{"location":"development-tools/#export-_data-xml-files","text":"Terminal $ php cmd.php xf-addon:export [addon_id] This command is what you will use to export all of your add-on's data to XML files inside the _data directory. It exports the data from what is currently in the database (rather than from the development output files).","title":"Export _data .XML files"},{"location":"development-tools/#bump-your-add-on-version","text":"Terminal $ php cmd.php xf-addon:bump-version [addon_id] --version-id 1020370 --version-string 1.2.3 Note If your version string contains spaces, you'll need to surround it with quotes. This command takes the add-on ID for your add-on, the new version ID and the new version string. This enables you to bump the version of your add-on in a single step, without having to perform upgrades and rebuilds yourself. The options above are optional, and if they are not provided you will be prompted for them. If you only specify the version ID, we will try and infer the correct version string from that automatically if it matches our Recommended version ID format . Once the command completes, it updates the addon.json file automatically and the database with the correct version details.","title":"Bump your add-on version"},{"location":"development-tools/#sync-your-addonjson-to-the-database","text":"Terminal $ php cmd.php xf-addon:sync-json [addon_id] Sometimes you might prefer to edit the JSON file directly with certain details. This could be the version, or a new icon, or a change of title or description. Changing the JSON in this way can cause the add-on system to believe there are pending changes or that the add-on is upgradeable. A rebuild or upgrade can be a destructive operation if you haven't yet exported your current data. Therefore, running this command is recommended as a way of importing that data in without affecting your existing data.","title":"Sync your addon.json to the database"},{"location":"development-tools/#validate-your-addonjson-file","text":"Terminal $ php cmd.php xf-addon:validate-json [addon_id] If you'd like to check your JSON file contains the correct content and in the correct format, you can now validate it. The validator will check that the content can be decoded, that it contains all of the correct required fields (such as title and version ID) and also checks for the presence of the optional keys (such as description and icon). If any keys are missing, you will be offered to have the issues fixed for you. We also check to see if there are any unexpected fields within the JSON file. These may be deliberate or represent typos. You can run the command manually or the command will be run automatically while building your release.","title":"Validate your addon.json file"},{"location":"development-tools/#run-a-specific-setup-step","text":"Sometimes it's useful to check that your Setup class steps function correctly, without having to go through the process of uninstalling and reinstalling. There are three commands which help with this. These commands will only work with Setup classes that are built using the default StepRunner traits.","title":"Run a specific Setup step"},{"location":"development-tools/#run-an-install-step","text":"Terminal $ php cmd.php xf-addon:install-step [addon_id] [step]","title":"Run an install step"},{"location":"development-tools/#run-an-upgrade-step","text":"Terminal $ php cmd.php xf-addon:upgrade-step [addon_id] [version] [step]","title":"Run an upgrade step"},{"location":"development-tools/#run-an-uninstall-step","text":"Terminal $ php cmd.php xf-addon:uninstall-step [addon_id] [step]","title":"Run an uninstall step"},{"location":"development-tools/#building-an-add-on-release","text":"Once all of the hard work has been done, it's a shame to have to go through a number of other processes before you can actually release it. Even the process of collecting all of the files into the correct place and creating the ZIP file manually can be time consuming and prone to errors. We can take care of that automatically, including generating the hashes.json file, with one simple command. Terminal $ php cmd.php xf-addon:build-release [addon_id] When you run this command, it will first run the xf-addon:export command before then collecting all of your files together into a temporary _build directory and writing them to a ZIP file. The finished ZIP will also include the hashes.json file. Once the ZIP has been created it will be saved to your _releases directory named and named <ADDON ID>-<VERSION STRING>.zip .","title":"Building an add-on release"},{"location":"development-tools/#customizing-the-build-process","text":"Aside from just creating the release ZIP there may be additional files you wish to include in your ZIP, other more advanced build processes you want to run such as minifying or concatenating JS or running certain shell commands. All of this can be taken care of in your build.json file. This is a typical build.json file: { \"additional_files\": [ \"js/demo/portal\" ], \"minify\": [ \"js/demo/portal/a.js\", \"js/demo/portal/b.js\" ], \"rollup\": { \"js/demo/portal/ab-rollup.js\": [ \"js/demo/portal/a.min.js\", \"js/demo/portal/b.min.js\" ] }, \"exec\": [ \"echo '{title} version {version_string} ({version_id}) has been built successfully!' > 'src/addons/Demo/Portal/_build/built.txt'\" ] } If you have assets, such as JavaScript, which need to be served outside of your add-on directory, you can tell the build process to copy files or directories using the additional_files array within build.json . During development it isn't always feasible to keep files outside of your add-on directory, so if you prefer, you can keep the files in your add-on _files directory instead. When copying the additional files, we will check there first. If you ship some JS files with your add-on, you may want to minify those files for performance reasons. You can specify which files you want to minify right inside your build.json . You can list these as an array or you can just specify it as '*' which will just minify everything in your js directory as long as that path has JS files within it after copying the additional files to the build. Any files minified will automatically have a suffix of .min.js instead of .js and the original files will still be in the package. You may prefer to roll up your multiple JS files into a single file. If you do, you can use the rollup array to define that. The key is the resulting combined filename, and the items within that array are the paths to the JS files that will be combined into a single file. Finally, you may have certain processes that need to be run just before the package is built and finalised. This could be any combination of things. Ultimately, if it is a command that can be run from the shell (including PHP scripts) then you can specify it here. The example above is of course fairly useless, but it does at least demonstrate that certain placeholders can be used. These placeholders are replaced with scalar values you can get from the XF\\AddOn\\AddOn object which is generally any value available in the addon.json file, or the AddOn entity.","title":"Customizing the build process"},{"location":"development-tools/#development-commands_1","text":"There are actually quite a few development related commands, but only the two most important ones are being covered here. To use any of these commands, you must have development mode enabled in your config.php file. Warning Both of the following commands can potentially cause data loss if there is a situation whereby the database and _output directory become out of sync. It is always recommended to use a VCS (Version Control System) such as GitHub to mitigate the impact of such mistakes.","title":"Development commands"},{"location":"development-tools/#import-development-output","text":"Terminal $ php cmd.php xf-dev:import --addon [addon_id] Running this command will import all of the development output files from your add-on _output directory into the database.","title":"Import development output"},{"location":"development-tools/#export-development-output","text":"Terminal $ php cmd.php xf-dev:export --addon [addon_id] This will export all data currently associated to your add-on in the database to files within your _output directory.","title":"Export development output"},{"location":"development-tools/#debugging-code","text":"It should be possible to set up your favourite debugger tool (XDebug, Zend Debugger etc.) to work with XF2. Though, sometimes, debugging code can be as rudimentary as just quickly seeing what value (or value type) a variable holds at a given time.","title":"Debugging code"},{"location":"development-tools/#dump-a-variable","text":"PHP of course has a tool built-in to handle this. You'll likely know it as var_dump() . XF ships with two replacements for this: \\XF::dump($var); \\XF::dumpSimple($var); The simple version mostly just dumps out the value of a variable in plain text. For example, if you just use it to dump the value of an array, you will see an output at the top of the page like this: array(2) { [\"user_id\"] => int(1) [\"username\"] => string(5) \"Admin\" } This is actually the same output as a standard var_dump, but slightly modified for readability and wrapped inside <pre> tags to ensure whitespace is maintained when rendering. The alternative is actually a component named VarDumper from the Symfony project. It outputs HTML, CSS and JS to create a much more functional and potentially easier to read output. It allows you to collapse certain sections, and for certain values which can output a considerable amount of data, such as objects, it can collapse those sections automatically.","title":"Dump a variable"},{"location":"entities-finders-repositories/","text":"Entities, finders, and repositories \u00b6 There are a number of ways to interact with data within XF2. In XF1 this was mostly geared towards writing out raw SQL statements inside Model files. The approach in XF2 has moved away from this, and we have added a number of new ways in its place. We'll first look at the preferred method for performing database queries - the finder. The Finder \u00b6 We have introduced a new \"Finder\" system which allows queries to be built up programmatically in a object oriented way so that raw database queries do not need to be written. The Finder system works hand in hand with the Entity system, which we talk about in more detail below. The first argument passed into the finder method is the short class name for the Entity you want to work with. Let's just convert some of the queries mentioned in the section above to use the Finder system instead. For example, to access a single user record: $finder = \\XF::finder('XF:User'); $user = $finder->where('user_id', 1)->fetchOne(); One of the main differences between the direct query approach and using the Finder is that the base unit of data returned by the Finder is not an array. In the case of a Finder object which calls the fetchOne method (which only returns a single row from the database), a single Entity object will be returned. Let's look at a slightly different approach which will return multiple rows: $finder = \\XF::finder('XF:User'); $users = $finder->limit(10)->fetch(); This example will query 10 records from the xf_user table, and it will return them as an ArrayCollection object. This is a special object which acts similarly to an array, in that it is traversable (you can loop through it) and it has some special methods that can tell you the total number of entries it has, grouping by certain values, or other array like operations such as filtering, merging, getting the first or last entry etc. Finder queries generally should be expected to retrieve all columns from a table, so there's no specific equivalent to fetch only certain values certain columns. Instead, to get a single value, you would just fetch one entity and read the value directly from that: $finder = \\XF::finder('XF:User'); $username = $finder->where('user_id', 1)->fetchOne()->username; Similarly, to get an array of values from a single column, you can use the pluckFrom method: $finder = \\XF::finder('XF:User'); $usernames = $finder->limit(10)->pluckFrom('username')->fetch(); So far we've seen the Finder apply somewhat simple where and limit constraints. So let's look at the Finder in more detail, including a bit more detail about the where method itself. where method \u00b6 The where method can support up to three arguments. The first being the condition itself, e.g. the column you are querying. The second would ordinarily be the operator. The third is the value being searched for. If you supply only two arguments, as you have seen above, then it automatically implies the operator is = . Below is a list of the other operators which are valid: = <> != > >= < <= LIKE BETWEEN So, we could get a list of the valid users who registered in the last 7 days: $finder = \\XF::finder('XF:User'); $users = $finder->where('user_state', 'valid')->where('register_date', '>=', time() - 86400 * 7)->fetch(); As you can see you can call the where method as many times as you like, but in addition to that, you can choose to pass in an array as the only argument of the method, and build up your conditions in a single call. The array method supports two types, both of which we can use on the query we built above: $finder = \\XF::finder('XF:User'); $users = $finder->where([ 'user_state' => 'valid', ['register_date', '>=', time() - 86400 * 7] ]) ->fetch(); It wouldn't usually be recommended or clear to mix the usage like this, but it does demonstrate the flexibility of the method somewhat. Now that the conditions are in an array, we can either specify the column name (as the array key) and value for an implied = operator or we can actually define another array containing the column, operator and value. whereOr method \u00b6 With the above examples, both conditions need to be met, i.e. each condition is joined by the AND operator. However, sometimes it is necessary to only meet part of your condition, and this is possible by using the whereOr method. For example, if you wanted to search for users who are either not valid or have posted zero messages, you can build that as follows: $finder = \\XF::finder('XF:User'); $users = $finder->whereOr( ['user_state', '<>', 'valid'], ['message_count', 0] )->fetch(); Similar to the example in the previous section, as well as passing up to two conditions as separate arguments, you can also just pass an array of conditions to the first argument: $finder = \\XF::finder('XF:User'); $users = $finder->whereOr([ ['user_state', '<>', 'valid'], ['message_count', 0], ['is_banned', 1] ])->fetch(); with method \u00b6 The with method is essentially equivalent to using the INNER|LEFT JOIN syntax, though it relies upon the Entity having had its \"Relations\" defined. We won't go into that until the next page, but this should just give you an understanding of how it works. Let's now use the Thread finder to retrieve a specific thread: $finder = \\XF::finder('XF:Thread'); $thread = $finder->with('Forum', true)->where('thread_id', 123)->fetchOne(); This query will fetch the Thread entity where the thread_id = 123 but it will also do a join with the xf_forum table, behind the scenes. In terms of controlling how to do an INNER JOIN rather than a LEFT JOIN , that is what the second argument is for. In this case we've set the \"must exist\" argument to true, so it will flip the join syntax to using INNER rather than the default LEFT . We'll go into more detail about how to access the data fetched from this join in the next section. It's also possible to pass an array of relations into the with method to do multiple joins. $finder = \\XF::finder('XF:Thread'); $thread = $finder->with(['Forum', 'User'], true)->where('thread_id', 123)->fetchOne(); This would join to the xf_user table to get the thread author too. However, with the second argument there still being true , we might not need to do an INNER join for the user join, so, we could just chain the methods instead: $finder = \\XF::finder('XF:Thread'); $thread = $finder->with('Forum', true)->with('User')->where('thread_id', 123)->fetchOne(); order, limit and limitByPage methods \u00b6 order method \u00b6 This method allows you to modify your query so the results are fetched in a specific order. It takes two arguments, the first is the column name, and the second is, optionally, the direction of the sort. So, if you wanted to list the 10 users who have the most messages, you could build the query like this: $finder = \\XF::finder('XF:User'); $users = $finder->order('message_count', 'DESC')->limit(10); Note Now is probably a good time to mention that finder methods can mostly be called in any order. For example: $threads = $finder->limit(10)->where('thread_id', '>', 123)->order('post_date')->with('User')->fetch(); Although if you wrote a MySQL query in that order you'd certainly encounter some syntax issues, the Finder system will still build it all in the correct order and the above code, although odd looking and probably not recommended, is perfectly valid. As with a standard MySQL query, it is possible to order a result set on multiple columns. To do that, you can just call the order method again. It's also possible to pass multiple order clauses into the order method using an array. $finder = \\XF::finder('XF:User'); $users = $finder->order('message_count', 'DESC')->order('register_date')->limit(10); limit method \u00b6 We've already seen how to limit a query to a specific number of records being returned: $finder = \\XF::finder('XF:User'); $users = $finder->limit(10)->fetch(); However, there's actually an alternative to calling the limit method directly: $finder = \\XF::finder('XF:User'); $users = $finder->fetch(10); It's possible to pass your limit directly into the fetch() method. It's also worth noting that the limit (and fetch ) method supports two arguments. The first obviously being the limit, the second being the offset. $finder = \\XF::finder('XF:User'); $users = $finder->limit(10, 100)->fetch(); The offset value here essentially means the first 100 results will be discarded, and the first 10 after that will be returned. This kind of approach is useful for providing paginated results, though we actually also have an easier way to do that... limitByPage method \u00b6 This method is a sort of helper method which ultimately sets the appropriate limit and offset based on the \"page\" you're currently viewing and how many \"per page\" you require. $finder = \\XF::finder('XF:User'); $users = $finder->limitByPage(3, 20); In this case, the limit is going to be set to 20 (which is our per page value) and the offset is going to be set to 40 because we're starting on page 3. Occasionally, it is necessary for us to grab additional more data than the limit. Over-fetching can be useful to help detect whether you have additional data to display after the current page, or if you have a need to filter the initial result set down based on permissions. We can do that with the third argument: $finder = \\XF::finder('XF:User'); $users = $finder->limitByPage(3, 20, 1); This will get a total of up to 21 users (20 + 1) starting at page 3. getQuery method \u00b6 When you first start working with the finder, as intuitive as it is, you may occasionally wonder whether you're using it correctly, and whether it is going to build the query you expect it to. We have a method named getQuery which can tell us the current query that will be built with the current finder object. For example: $finder = \\XF::finder('XF:User') ->where('user_id', 1); \\XF::dumpSimple($finder->getQuery()); This will output something similar to: string(67) \"SELECT `xf_user`.* FROM `xf_user` WHERE (`xf_user`.`user_id` = 1)\" You probably won't need it very often, but it can be useful if the finder isn't quite returning the results you expected. Read more about the dumpSimple method in the Dump a variable section. Custom finder methods \u00b6 So far we have seen the finder object get setup with an argument similar to XF:User and XF:Thread . For the most part, this identifies the Entity class the finder is working with and will resolve to, for example, XF\\Entity\\User . However, it can additionally represent a finder class. Finder classes are optional, but they serve as a way to add custom finder methods to specific finder types. To see this in action, let's look at the finder class that relates to XF:User which can be found in the XF\\Finder\\User class. Here's an example finder method from that class: public function isRecentlyActive($days = 180) { $this->where('last_activity', '>', time() - ($days * 86400)); return $this; } What this allows us to do is to now call that method on any User finder object. So if we take an example earlier: $finder = \\XF::finder('XF:User'); $users = $finder->isRecentlyActive(20)->order('message_count', 'DESC')->limit(10); This query, which earlier just returned 10 users in descending message count order, will now return the 10 users in that order who have been recently active in the last 20 days. Even though for a lot of entity types a finder class doesn't exist, it is still possible to extend these non existent classes in the same way as mentioned in the Extending classes section. The Entity system \u00b6 If you're familiar with XF1, you may be familiar with some of the concepts behind Entities because they have ultimately derived from the DataWriter system there. In case you're not so familiar with them, the following section should give you some idea. Entity structure \u00b6 The Structure object consists of a number of properties which define the structure of the Entity and the database table it relates to. The structure object itself is setup inside the entity it relates to. Let's look at some of the common properties from the User entity: Table \u00b6 $structure->table = 'xf_user'; This tells the Entity which database table to use when updating and inserting records, and also tells the Finder which table to read from when building queries to execute. Additionally, it plays a part in knowing which other tables your query needs to join to. Short name \u00b6 $structure->shortName = 'XF:User'; This is the just the short class name of both the Entity itself and the Finder class (if applicable). Content type \u00b6 $structure->contentType = 'user'; This defines what content type this Entity represents. This will not be needed in most entity structures. It is used to connect to specific things used by the \"content type\" system (which will be covered in another section). Primary key \u00b6 $structure->primaryKey = 'user_id'; Defines the column which represents the primary key in the database table. If a table supports more than a single column as a primary key, then this can be defined as an array. Columns \u00b6 $structure->columns = [ 'user_id' => ['type' => self::UINT, 'autoIncrement' => true, 'nullable' => true, 'changeLog' => false], 'username' => ['type' => self::STR, 'maxLength' => 50, 'required' => 'please_enter_valid_name' ] // and many more columns ... ]; This is a key part of the configuration of the entity as this goes into a lot of detail to explain the specifics of each database column that the Entity is responsible for. This tells us the type of data that is expected, whether a value is required, what format it should match, whether it should be a unique value, what its default value is, and much more. Based on the type , the entity manager knows whether to encode or decode a value in a certain way. This may be a somewhat simple process of casting a value to a string or an integer, or slightly more complicated such as using json_encode() on an array when writing to the database or using json_decode() on a JSON string when reading from the database so that the value is correctly returned to the entity object as an array without us needing to manually do that. It can also support comma separated values being encoded/decoded appropriately. Occasionally it is necessary to do some additional verification or modification of a value before it is written. As an example, in the User entity, look at the verifyStyleId() method. When a value is set on the style_id field, we automatically check to see if a method named verifyStyleId() exists, and if it does, we run the value through that first. Behaviors \u00b6 $structure->behaviors = [ 'XF:ChangeLoggable' => [] ]; This is an array of behavior classes which should be used by this entity. Behavior classes are a way of allowing certain code to be reused generically across multiple entity types (only when the entity changes, not on reads). A good example of this is the XF:Likeable behavior which is able to automatically execute certain actions on entities which support content which can be \"liked\". This includes automatically recalculating counts when visibility changes occur within the content and automatically deleting likes when the content is deleted. Getters \u00b6 $structure->getters = [ 'is_super_admin' => true, 'last_activity' => true ]; Getter methods are automatically called when the named fields are called. For example, if we request is_super_admin from a User entity, this will automatically check for, and use the getIsSuperAdmin() method. The interesting thing to note about this is that the xf_user table doesn't actually have a field named is_super_admin . This actually exists on the Admin entity, but we have added it as a getter method as a shorthand way of accessing that value. Getter methods can also be used to override the values of existing fields directly, which is the case for the last_activity value here. last_activity is actually a cached value which is updated usually when a user logs out. However, we store the user's latest activity date in the xf_session_activity table, so we can use this getLastActivity method to return that value instead of the cached last activity value. Should you ever have a need to bypass the getter method entirely, and just get the true entity value, just suffix the column name with an underscore, e.g. $user->last_activity_ . Because an entity is just like any other PHP object, you can add more methods to them. A common use case for this is for adding things like permission check methods that can be called on the entity itself. Relations \u00b6 $structure->relations = [ 'Admin' => [ 'entity' => 'XF:Admin', 'type' => self::TO_ONE, 'conditions' => 'user_id', 'primary' => true ] ]; This is how Relations are defined. What are relations? They define the relationship between entities which can be used to perform join queries to other tables or fetch records associated to an entity on the fly. If we remember the with method on the finder, if we wanted to fetch a specific user and preemptively fetch the user's Admin record (if it exists) then we would do something like the following: $finder = \\XF::finder('XF:User'); $user = $finder->where('user_id', 1)->with('Admin')->fetchOne(); This will use the information defined in the user entity for the Admin relation and the details of the XF:Admin entity structure to know that this user query should perform a LEFT JOIN on the xf_admin table and the user_id column. To access the admin last login date from the user entity: $lastLogin = $user->Admin->last_login; // returns timestamp of the last admin login However, it's not always necessary to do a join in a finder to get related information for an entity. For example, if we take the above example without the with method call: $finder = \\XF::finder('XF:User'); $user = $finder->where('user_id', 1)->fetchOne(); $lastLogin = $user->Admin->last_login; // returns timestamp of the last admin login We still get the last_login value here. It does this by performing the additional query to get the Admin entity on the fly. The example above uses the TO_ONE type, and this relation, therefore, relates one entity to one other entity. We also have a TO_MANY type. It is not possible to fetch an entire TO_MANY relation (e.g. with a join / with method on the finder), but at the cost of a query it is possible to read that at any time on the fly, such as in the final last_login example above. One such relation that is defined on the User entity is the ConnectedAccounts relation: $structure->relations = [ 'ConnectedAccounts' => [ 'entity' => 'XF:UserConnectedAccount', 'type' => self::TO_MANY, 'conditions' => 'user_id', 'key' => 'provider' ] ]; This relation is able to return the records from the xf_user_connected_account table that match the current user ID as a FinderCollection . This is similar to the ArrayCollection object we mentioned in The Finder section above. The relation definition specifies that the collection should be keyed by the provider field. Although it isn't possible to fetch multiple records while performing a finder query, it is possible to use a TO_MANY relation to fetch a single record from that relation. As an example, if we wanted to see if the user was associated to a specific connected account provider, we can at least fetch that while querying: $finder = \\XF::finder('XF:User'); $user = $finder->where('user_id', 1)->with('ConnectedAccounts|facebook')->fetchOne(); Options \u00b6 $structure->options = [ 'custom_title_disallowed' => preg_split('/\\r?\\n/', $options->disallowedCustomTitles), 'admin_edit' => false, 'skip_email_confirm' => false ]; Entity options are a way of modifying the behavior of the entity under certain conditions. For example, if we set admin_edit to true (which is the case when editing a user in the Admin CP), then certain checks will be skipped such as to allow a user's email address to be empty. The Entity life cycle \u00b6 The Entity plays a significant job in terms of managing the life cycle of a record within the database. As well as reading values from it, and writing values to it, the Entity can be used to delete records and trigger certain events when all of these actions occur so that certain tasks can be performed, or certain associated records can be updated as well. Let's look at some of these events that happen when an entity is saving: _preSave() - This happens before the save process begins, and is primarily used to perform any additional pre-save validations or to set additional data before the save happens. _postSave() - After the data has been saved, but before any transactions are committed, this method is called and you can use it to perform any additional work that should trigger after an entity has been saved. There are additionally _preDelete() and _postDelete() which work in a similar way, but when a delete is happening. The Entity is also able to give information on its current state. For example, there is an isInsert() and isUpdate() method so you can detect whether this is a new record being inserted or an existing record being updated. There is an isChanged() method which can tell you whether a specific field has changed since the last save. Let's look at some real examples of these methods in action, in the User entity. protected function _preSave() { if ($this->isChanged('user_group_id') || $this->isChanged('secondary_group_ids')) { $groupRepo = $this->getUserGroupRepo(); $this->display_style_group_id = $groupRepo->getDisplayGroupIdForUser($this); } // ... } protected function _postSave() { // ... if ($this->isUpdate() && $this->isChanged('username') && $this->getExistingValue('username') != null) { $this->app()->jobManager()->enqueue('XF:UserRenameCleanUp', [ 'originalUserId' => $this->user_id, 'originalUserName' => $this->getExistingValue('username'), 'newUserName' => $this->username ]); } // ... In the _preSave() example we fetch and cache the new display group ID for a user based on their changed user groups. In the _postSave() example, we trigger a job to run after a user's name has been changed. Repositories \u00b6 Repositories are a new concept for XF2, but you might not be blamed for comparing them to the \"Model\" objects from XF1. We don't have a model object in XF2 because we have much better places and ways to fetch and write data to the database. So, rather than having a massive class which contains all of the queries your add-on needs, and all of the various different ways to manipulate those queries, we have the finder which adds a lot more flexibility. It's also worth bearing in mind that in XF1 the Model objects were a bit of a \"dumping ground\" for so many things. Many of which are now redundant. For example, in XF1 all of the permission rebuilding code was in the permission model. In XF2, we have specific services and objects which handle this. So, what are Repositories? They correspond with an entity and a finder and hold methods which generally return a finder object setup for a specific purpose. Why not just return the result of the finder query? Well, if we return the finder object itself then it serves as a useful extension point for add-ons to extend that and modify the finder object before the entity or collection is returned. Repositories may also contain some specific methods for things like cache rebuilding.","title":"Entities, finders, and repositories"},{"location":"entities-finders-repositories/#entities-finders-and-repositories","text":"There are a number of ways to interact with data within XF2. In XF1 this was mostly geared towards writing out raw SQL statements inside Model files. The approach in XF2 has moved away from this, and we have added a number of new ways in its place. We'll first look at the preferred method for performing database queries - the finder.","title":"Entities, finders, and repositories"},{"location":"entities-finders-repositories/#the-finder","text":"We have introduced a new \"Finder\" system which allows queries to be built up programmatically in a object oriented way so that raw database queries do not need to be written. The Finder system works hand in hand with the Entity system, which we talk about in more detail below. The first argument passed into the finder method is the short class name for the Entity you want to work with. Let's just convert some of the queries mentioned in the section above to use the Finder system instead. For example, to access a single user record: $finder = \\XF::finder('XF:User'); $user = $finder->where('user_id', 1)->fetchOne(); One of the main differences between the direct query approach and using the Finder is that the base unit of data returned by the Finder is not an array. In the case of a Finder object which calls the fetchOne method (which only returns a single row from the database), a single Entity object will be returned. Let's look at a slightly different approach which will return multiple rows: $finder = \\XF::finder('XF:User'); $users = $finder->limit(10)->fetch(); This example will query 10 records from the xf_user table, and it will return them as an ArrayCollection object. This is a special object which acts similarly to an array, in that it is traversable (you can loop through it) and it has some special methods that can tell you the total number of entries it has, grouping by certain values, or other array like operations such as filtering, merging, getting the first or last entry etc. Finder queries generally should be expected to retrieve all columns from a table, so there's no specific equivalent to fetch only certain values certain columns. Instead, to get a single value, you would just fetch one entity and read the value directly from that: $finder = \\XF::finder('XF:User'); $username = $finder->where('user_id', 1)->fetchOne()->username; Similarly, to get an array of values from a single column, you can use the pluckFrom method: $finder = \\XF::finder('XF:User'); $usernames = $finder->limit(10)->pluckFrom('username')->fetch(); So far we've seen the Finder apply somewhat simple where and limit constraints. So let's look at the Finder in more detail, including a bit more detail about the where method itself.","title":"The Finder"},{"location":"entities-finders-repositories/#where-method","text":"The where method can support up to three arguments. The first being the condition itself, e.g. the column you are querying. The second would ordinarily be the operator. The third is the value being searched for. If you supply only two arguments, as you have seen above, then it automatically implies the operator is = . Below is a list of the other operators which are valid: = <> != > >= < <= LIKE BETWEEN So, we could get a list of the valid users who registered in the last 7 days: $finder = \\XF::finder('XF:User'); $users = $finder->where('user_state', 'valid')->where('register_date', '>=', time() - 86400 * 7)->fetch(); As you can see you can call the where method as many times as you like, but in addition to that, you can choose to pass in an array as the only argument of the method, and build up your conditions in a single call. The array method supports two types, both of which we can use on the query we built above: $finder = \\XF::finder('XF:User'); $users = $finder->where([ 'user_state' => 'valid', ['register_date', '>=', time() - 86400 * 7] ]) ->fetch(); It wouldn't usually be recommended or clear to mix the usage like this, but it does demonstrate the flexibility of the method somewhat. Now that the conditions are in an array, we can either specify the column name (as the array key) and value for an implied = operator or we can actually define another array containing the column, operator and value.","title":"where method"},{"location":"entities-finders-repositories/#whereor-method","text":"With the above examples, both conditions need to be met, i.e. each condition is joined by the AND operator. However, sometimes it is necessary to only meet part of your condition, and this is possible by using the whereOr method. For example, if you wanted to search for users who are either not valid or have posted zero messages, you can build that as follows: $finder = \\XF::finder('XF:User'); $users = $finder->whereOr( ['user_state', '<>', 'valid'], ['message_count', 0] )->fetch(); Similar to the example in the previous section, as well as passing up to two conditions as separate arguments, you can also just pass an array of conditions to the first argument: $finder = \\XF::finder('XF:User'); $users = $finder->whereOr([ ['user_state', '<>', 'valid'], ['message_count', 0], ['is_banned', 1] ])->fetch();","title":"whereOr method"},{"location":"entities-finders-repositories/#with-method","text":"The with method is essentially equivalent to using the INNER|LEFT JOIN syntax, though it relies upon the Entity having had its \"Relations\" defined. We won't go into that until the next page, but this should just give you an understanding of how it works. Let's now use the Thread finder to retrieve a specific thread: $finder = \\XF::finder('XF:Thread'); $thread = $finder->with('Forum', true)->where('thread_id', 123)->fetchOne(); This query will fetch the Thread entity where the thread_id = 123 but it will also do a join with the xf_forum table, behind the scenes. In terms of controlling how to do an INNER JOIN rather than a LEFT JOIN , that is what the second argument is for. In this case we've set the \"must exist\" argument to true, so it will flip the join syntax to using INNER rather than the default LEFT . We'll go into more detail about how to access the data fetched from this join in the next section. It's also possible to pass an array of relations into the with method to do multiple joins. $finder = \\XF::finder('XF:Thread'); $thread = $finder->with(['Forum', 'User'], true)->where('thread_id', 123)->fetchOne(); This would join to the xf_user table to get the thread author too. However, with the second argument there still being true , we might not need to do an INNER join for the user join, so, we could just chain the methods instead: $finder = \\XF::finder('XF:Thread'); $thread = $finder->with('Forum', true)->with('User')->where('thread_id', 123)->fetchOne();","title":"with method"},{"location":"entities-finders-repositories/#order-limit-and-limitbypage-methods","text":"","title":"order, limit and limitByPage methods"},{"location":"entities-finders-repositories/#order-method","text":"This method allows you to modify your query so the results are fetched in a specific order. It takes two arguments, the first is the column name, and the second is, optionally, the direction of the sort. So, if you wanted to list the 10 users who have the most messages, you could build the query like this: $finder = \\XF::finder('XF:User'); $users = $finder->order('message_count', 'DESC')->limit(10); Note Now is probably a good time to mention that finder methods can mostly be called in any order. For example: $threads = $finder->limit(10)->where('thread_id', '>', 123)->order('post_date')->with('User')->fetch(); Although if you wrote a MySQL query in that order you'd certainly encounter some syntax issues, the Finder system will still build it all in the correct order and the above code, although odd looking and probably not recommended, is perfectly valid. As with a standard MySQL query, it is possible to order a result set on multiple columns. To do that, you can just call the order method again. It's also possible to pass multiple order clauses into the order method using an array. $finder = \\XF::finder('XF:User'); $users = $finder->order('message_count', 'DESC')->order('register_date')->limit(10);","title":"order method"},{"location":"entities-finders-repositories/#limit-method","text":"We've already seen how to limit a query to a specific number of records being returned: $finder = \\XF::finder('XF:User'); $users = $finder->limit(10)->fetch(); However, there's actually an alternative to calling the limit method directly: $finder = \\XF::finder('XF:User'); $users = $finder->fetch(10); It's possible to pass your limit directly into the fetch() method. It's also worth noting that the limit (and fetch ) method supports two arguments. The first obviously being the limit, the second being the offset. $finder = \\XF::finder('XF:User'); $users = $finder->limit(10, 100)->fetch(); The offset value here essentially means the first 100 results will be discarded, and the first 10 after that will be returned. This kind of approach is useful for providing paginated results, though we actually also have an easier way to do that...","title":"limit method"},{"location":"entities-finders-repositories/#limitbypage-method","text":"This method is a sort of helper method which ultimately sets the appropriate limit and offset based on the \"page\" you're currently viewing and how many \"per page\" you require. $finder = \\XF::finder('XF:User'); $users = $finder->limitByPage(3, 20); In this case, the limit is going to be set to 20 (which is our per page value) and the offset is going to be set to 40 because we're starting on page 3. Occasionally, it is necessary for us to grab additional more data than the limit. Over-fetching can be useful to help detect whether you have additional data to display after the current page, or if you have a need to filter the initial result set down based on permissions. We can do that with the third argument: $finder = \\XF::finder('XF:User'); $users = $finder->limitByPage(3, 20, 1); This will get a total of up to 21 users (20 + 1) starting at page 3.","title":"limitByPage method"},{"location":"entities-finders-repositories/#getquery-method","text":"When you first start working with the finder, as intuitive as it is, you may occasionally wonder whether you're using it correctly, and whether it is going to build the query you expect it to. We have a method named getQuery which can tell us the current query that will be built with the current finder object. For example: $finder = \\XF::finder('XF:User') ->where('user_id', 1); \\XF::dumpSimple($finder->getQuery()); This will output something similar to: string(67) \"SELECT `xf_user`.* FROM `xf_user` WHERE (`xf_user`.`user_id` = 1)\" You probably won't need it very often, but it can be useful if the finder isn't quite returning the results you expected. Read more about the dumpSimple method in the Dump a variable section.","title":"getQuery method"},{"location":"entities-finders-repositories/#custom-finder-methods","text":"So far we have seen the finder object get setup with an argument similar to XF:User and XF:Thread . For the most part, this identifies the Entity class the finder is working with and will resolve to, for example, XF\\Entity\\User . However, it can additionally represent a finder class. Finder classes are optional, but they serve as a way to add custom finder methods to specific finder types. To see this in action, let's look at the finder class that relates to XF:User which can be found in the XF\\Finder\\User class. Here's an example finder method from that class: public function isRecentlyActive($days = 180) { $this->where('last_activity', '>', time() - ($days * 86400)); return $this; } What this allows us to do is to now call that method on any User finder object. So if we take an example earlier: $finder = \\XF::finder('XF:User'); $users = $finder->isRecentlyActive(20)->order('message_count', 'DESC')->limit(10); This query, which earlier just returned 10 users in descending message count order, will now return the 10 users in that order who have been recently active in the last 20 days. Even though for a lot of entity types a finder class doesn't exist, it is still possible to extend these non existent classes in the same way as mentioned in the Extending classes section.","title":"Custom finder methods"},{"location":"entities-finders-repositories/#the-entity-system","text":"If you're familiar with XF1, you may be familiar with some of the concepts behind Entities because they have ultimately derived from the DataWriter system there. In case you're not so familiar with them, the following section should give you some idea.","title":"The Entity system"},{"location":"entities-finders-repositories/#entity-structure","text":"The Structure object consists of a number of properties which define the structure of the Entity and the database table it relates to. The structure object itself is setup inside the entity it relates to. Let's look at some of the common properties from the User entity:","title":"Entity structure"},{"location":"entities-finders-repositories/#table","text":"$structure->table = 'xf_user'; This tells the Entity which database table to use when updating and inserting records, and also tells the Finder which table to read from when building queries to execute. Additionally, it plays a part in knowing which other tables your query needs to join to.","title":"Table"},{"location":"entities-finders-repositories/#short-name","text":"$structure->shortName = 'XF:User'; This is the just the short class name of both the Entity itself and the Finder class (if applicable).","title":"Short name"},{"location":"entities-finders-repositories/#content-type","text":"$structure->contentType = 'user'; This defines what content type this Entity represents. This will not be needed in most entity structures. It is used to connect to specific things used by the \"content type\" system (which will be covered in another section).","title":"Content type"},{"location":"entities-finders-repositories/#primary-key","text":"$structure->primaryKey = 'user_id'; Defines the column which represents the primary key in the database table. If a table supports more than a single column as a primary key, then this can be defined as an array.","title":"Primary key"},{"location":"entities-finders-repositories/#columns","text":"$structure->columns = [ 'user_id' => ['type' => self::UINT, 'autoIncrement' => true, 'nullable' => true, 'changeLog' => false], 'username' => ['type' => self::STR, 'maxLength' => 50, 'required' => 'please_enter_valid_name' ] // and many more columns ... ]; This is a key part of the configuration of the entity as this goes into a lot of detail to explain the specifics of each database column that the Entity is responsible for. This tells us the type of data that is expected, whether a value is required, what format it should match, whether it should be a unique value, what its default value is, and much more. Based on the type , the entity manager knows whether to encode or decode a value in a certain way. This may be a somewhat simple process of casting a value to a string or an integer, or slightly more complicated such as using json_encode() on an array when writing to the database or using json_decode() on a JSON string when reading from the database so that the value is correctly returned to the entity object as an array without us needing to manually do that. It can also support comma separated values being encoded/decoded appropriately. Occasionally it is necessary to do some additional verification or modification of a value before it is written. As an example, in the User entity, look at the verifyStyleId() method. When a value is set on the style_id field, we automatically check to see if a method named verifyStyleId() exists, and if it does, we run the value through that first.","title":"Columns"},{"location":"entities-finders-repositories/#behaviors","text":"$structure->behaviors = [ 'XF:ChangeLoggable' => [] ]; This is an array of behavior classes which should be used by this entity. Behavior classes are a way of allowing certain code to be reused generically across multiple entity types (only when the entity changes, not on reads). A good example of this is the XF:Likeable behavior which is able to automatically execute certain actions on entities which support content which can be \"liked\". This includes automatically recalculating counts when visibility changes occur within the content and automatically deleting likes when the content is deleted.","title":"Behaviors"},{"location":"entities-finders-repositories/#getters","text":"$structure->getters = [ 'is_super_admin' => true, 'last_activity' => true ]; Getter methods are automatically called when the named fields are called. For example, if we request is_super_admin from a User entity, this will automatically check for, and use the getIsSuperAdmin() method. The interesting thing to note about this is that the xf_user table doesn't actually have a field named is_super_admin . This actually exists on the Admin entity, but we have added it as a getter method as a shorthand way of accessing that value. Getter methods can also be used to override the values of existing fields directly, which is the case for the last_activity value here. last_activity is actually a cached value which is updated usually when a user logs out. However, we store the user's latest activity date in the xf_session_activity table, so we can use this getLastActivity method to return that value instead of the cached last activity value. Should you ever have a need to bypass the getter method entirely, and just get the true entity value, just suffix the column name with an underscore, e.g. $user->last_activity_ . Because an entity is just like any other PHP object, you can add more methods to them. A common use case for this is for adding things like permission check methods that can be called on the entity itself.","title":"Getters"},{"location":"entities-finders-repositories/#relations","text":"$structure->relations = [ 'Admin' => [ 'entity' => 'XF:Admin', 'type' => self::TO_ONE, 'conditions' => 'user_id', 'primary' => true ] ]; This is how Relations are defined. What are relations? They define the relationship between entities which can be used to perform join queries to other tables or fetch records associated to an entity on the fly. If we remember the with method on the finder, if we wanted to fetch a specific user and preemptively fetch the user's Admin record (if it exists) then we would do something like the following: $finder = \\XF::finder('XF:User'); $user = $finder->where('user_id', 1)->with('Admin')->fetchOne(); This will use the information defined in the user entity for the Admin relation and the details of the XF:Admin entity structure to know that this user query should perform a LEFT JOIN on the xf_admin table and the user_id column. To access the admin last login date from the user entity: $lastLogin = $user->Admin->last_login; // returns timestamp of the last admin login However, it's not always necessary to do a join in a finder to get related information for an entity. For example, if we take the above example without the with method call: $finder = \\XF::finder('XF:User'); $user = $finder->where('user_id', 1)->fetchOne(); $lastLogin = $user->Admin->last_login; // returns timestamp of the last admin login We still get the last_login value here. It does this by performing the additional query to get the Admin entity on the fly. The example above uses the TO_ONE type, and this relation, therefore, relates one entity to one other entity. We also have a TO_MANY type. It is not possible to fetch an entire TO_MANY relation (e.g. with a join / with method on the finder), but at the cost of a query it is possible to read that at any time on the fly, such as in the final last_login example above. One such relation that is defined on the User entity is the ConnectedAccounts relation: $structure->relations = [ 'ConnectedAccounts' => [ 'entity' => 'XF:UserConnectedAccount', 'type' => self::TO_MANY, 'conditions' => 'user_id', 'key' => 'provider' ] ]; This relation is able to return the records from the xf_user_connected_account table that match the current user ID as a FinderCollection . This is similar to the ArrayCollection object we mentioned in The Finder section above. The relation definition specifies that the collection should be keyed by the provider field. Although it isn't possible to fetch multiple records while performing a finder query, it is possible to use a TO_MANY relation to fetch a single record from that relation. As an example, if we wanted to see if the user was associated to a specific connected account provider, we can at least fetch that while querying: $finder = \\XF::finder('XF:User'); $user = $finder->where('user_id', 1)->with('ConnectedAccounts|facebook')->fetchOne();","title":"Relations"},{"location":"entities-finders-repositories/#options","text":"$structure->options = [ 'custom_title_disallowed' => preg_split('/\\r?\\n/', $options->disallowedCustomTitles), 'admin_edit' => false, 'skip_email_confirm' => false ]; Entity options are a way of modifying the behavior of the entity under certain conditions. For example, if we set admin_edit to true (which is the case when editing a user in the Admin CP), then certain checks will be skipped such as to allow a user's email address to be empty.","title":"Options"},{"location":"entities-finders-repositories/#the-entity-life-cycle","text":"The Entity plays a significant job in terms of managing the life cycle of a record within the database. As well as reading values from it, and writing values to it, the Entity can be used to delete records and trigger certain events when all of these actions occur so that certain tasks can be performed, or certain associated records can be updated as well. Let's look at some of these events that happen when an entity is saving: _preSave() - This happens before the save process begins, and is primarily used to perform any additional pre-save validations or to set additional data before the save happens. _postSave() - After the data has been saved, but before any transactions are committed, this method is called and you can use it to perform any additional work that should trigger after an entity has been saved. There are additionally _preDelete() and _postDelete() which work in a similar way, but when a delete is happening. The Entity is also able to give information on its current state. For example, there is an isInsert() and isUpdate() method so you can detect whether this is a new record being inserted or an existing record being updated. There is an isChanged() method which can tell you whether a specific field has changed since the last save. Let's look at some real examples of these methods in action, in the User entity. protected function _preSave() { if ($this->isChanged('user_group_id') || $this->isChanged('secondary_group_ids')) { $groupRepo = $this->getUserGroupRepo(); $this->display_style_group_id = $groupRepo->getDisplayGroupIdForUser($this); } // ... } protected function _postSave() { // ... if ($this->isUpdate() && $this->isChanged('username') && $this->getExistingValue('username') != null) { $this->app()->jobManager()->enqueue('XF:UserRenameCleanUp', [ 'originalUserId' => $this->user_id, 'originalUserName' => $this->getExistingValue('username'), 'newUserName' => $this->username ]); } // ... In the _preSave() example we fetch and cache the new display group ID for a user based on their changed user groups. In the _postSave() example, we trigger a job to run after a user's name has been changed.","title":"The Entity life cycle"},{"location":"entities-finders-repositories/#repositories","text":"Repositories are a new concept for XF2, but you might not be blamed for comparing them to the \"Model\" objects from XF1. We don't have a model object in XF2 because we have much better places and ways to fetch and write data to the database. So, rather than having a massive class which contains all of the queries your add-on needs, and all of the various different ways to manipulate those queries, we have the finder which adds a lot more flexibility. It's also worth bearing in mind that in XF1 the Model objects were a bit of a \"dumping ground\" for so many things. Many of which are now redundant. For example, in XF1 all of the permission rebuilding code was in the permission model. In XF2, we have specific services and objects which handle this. So, what are Repositories? They correspond with an entity and a finder and hold methods which generally return a finder object setup for a specific purpose. Why not just return the result of the finder query? Well, if we return the finder object itself then it serves as a useful extension point for add-ons to extend that and modify the finder object before the entity or collection is returned. Repositories may also contain some specific methods for things like cache rebuilding.","title":"Repositories"},{"location":"general-concepts/","text":"General concepts \u00b6 The following sections go into detail about some of the general systems and concepts you will come across while developing a XenForo add-on. If you are familiar with XenForo 1.x development, then a lot of these concepts will seem familiar to you, though it's worth reviewing them as there are some excellent new tools and features to help you develop add-ons. Vendor components \u00b6 XF2 is not powered by a specifc framework as XF1 was, however, we have employed the use of certain popular, well-tested, open source packages to help with specific tasks. For example, we use a project named SwiftMailer for email sending and a project named Guzzle as a HTTP client. All third party projects are loaded from the src/vendor directory. It is not currently possible for add-on developers to add their own dependencies to this location. Integrated Development Environment (IDE) \u00b6 Before starting work on XF2 development, you may want to spend some time evaluating the application with which you will actually be creating and editing PHP files. This is commonly referred to as an IDE. There are a number of options available ranging from basic Notepad to something like Sublime Text which can be expanded to have better PHP support with add-ons, up to a proper IDE, such as PhpStorm . Internally, we use PhpStorm as our preferred IDE. This is a premium and commercial product, but there may be free alternatives available. Either way, no one can tell you the best application for your requirements, and you should spend some time with a number of products (even free ones) and use that experience to find out your preference. Autoloader \u00b6 XF2 uses an autoloader which is automatically generated by Composer. This allows all XF code, third party vendor code, and any add-on developer code to be automatically included throughout the entire project without having to include/require your classes manually. The autoload root for all XF add-ons is the src/addons directory. This means that all of your class names will be relative to this base location. It's also worth noting that XF2 employs a strict \"class per file\" pattern to naming. Each file should only contain a single class, and the name of that class should identify the exact location of the class PHP file on the file system. For example, if you want to create a new class in a file named src/addons/Demo/Setup.php (where Demo is your add-on ID) then this class will be named Demo\\Setup . Conversely, if you had a class named Demo\\Entity\\Thing then you will know the file for this class is located in the path src/addons/Demo/Entity/Thing.php . Namespaces \u00b6 Throughout XF we use namespaces so that we can reference classes in the same namespace more succinctly. It is recommended that all add-ons also use namespaces. In the above example we talked about a class named Demo\\Setup . Using namespaces, the class would actually be named simply Setup but the namespace will be set to Demo . As a more concrete example, we also talked above about a class named Demo\\Entity\\Thing . Let's see what the PHP code would look like for this class: <?php namespace Demo\\Entity; class Thing { } If there was a class named AnotherThing in the src/addons/Demo/Entity directory, we could reference this class in the Thing class simply as AnotherThing because that class is in the same Demo\\Entity namespace. Short class names \u00b6 Occasionally, classes referenced in XF are shortened. For example, if you wish to call the User entity (more on entities below) then you may see the class name referenced as simply XF:User . The use of short class names and the full class name they resolve to, is entirely context sensitive. Therefore, in the context of a call to an entity, the short class name will resolve to the following full class name XF\\Entity\\User . The XF part indicates the file path (based on add-on ID), the Entity part is implied by calling the entity and the User part indicates the specific entity. Similarly when you start creating your own classes, you will also use short class names to reference your own classes. For example, if you need to create a new Thing entity for your Demo add-on, then you would write the following: \\XF::em()->create('Demo:Thing'); This would resolve to the Demo\\Entity\\Thing class. Similarly, if you wanted to access a Thing repository, you would write it as follows: \\XF::repository('Demo:Thing'); Notice how the short class names are identical. The repository call would actually resolve to Demo\\Repository\\Thing . Extending classes \u00b6 A great deal number of classes in XF2 are extendable which allows developers to extend and override the core code without having to directly edit it. If you're familiar with XF1 development, you will be somewhat familiar with the following process: Create a Listener PHP file Create a class which will ultimately extend the original class Write a function which matches the expected callback signature for one of the load_class events and adds the name of your extended class Add a \"Code event listener\" in the Admin CP which specifies the Listener class and method name for the function mentioned above, and optionally hint as to which class is being extended In XF2 we have removed these events in favour of a specific system called \"Class extensions\". The process is as follows: Create a class which will ultimately extend the original class Add a \"Class extension\" in the Admin CP which specifies the name of the class you are extending and the name of the class which is extending it This clearly cuts down on some of the boilerplate required to extend classes, and also provides a dedicated UI for viewing and managing these extensions. Let's look at the process by extending the public Member controller, and adding a new action which displays a simple message. The first thing to do is to create an add-on. We previously outlined how to do that using the xf-addon:create command here . For this example, we'll assume you created an add-on with an ID and title of \"Demo\". You will now have an addon.json file for this add-on in the following location src/addons/Demo/addon.json . Note Although, strictly speaking, you can place your extended classes wherever you like within your add-on directory, it is recommended to put extended classes in a directory which easily identifies a) the add-on the class belongs to b) the type of class being extended and c) the name of the class being extended. In the following examples, we are extending the public XF Member controller so we will place our extended class in the following path: src/addons/Demo/XF/Pub/Controller/Member.php . The extended class needs to exist before we add the class extension to the Admin CP. So, follow the following instructions: Create a new directory named XF inside src/addons/Demo Create a new directory named Pub inside src/addons/Demo/XF Create a new directory named Controller inside src/addons/Demo/XF/Pub Create a new file named Member.php inside src/addons/Demo/XF/Pub/Controller The initial contents of your PHP file, should be as follows: <?php namespace Demo\\XF\\Pub\\Controller; class Member extends XFCP_Member { } If you're familiar with extending PHP classes generally, but not familiar with XF, the above example may initially seem confusing. The reason for that is you may have been expecting to extend the XF\\Pub\\Controller\\Member class directly, rather than XFCP_Member . In XF we use the \"XenForo Class Proxy\" system (XFCP for short) to build an \"inheritance chain\" which ultimately allows a single class to be extended by multiple add-ons. The convention is to reference a dummy extended class which is the current class name Member and prefix it with XFCP_ . Now the class has been created, we can create the class extension on the Admin CP > Development > Class extensions > Add class extension page. All you need to do is enter the base class name ( XF\\Pub\\Controller\\Member ) in the first field, and the extended class name (which you just created) in the second field ( Demo\\XF\\Pub\\Controller\\Member ) and click the \"Save\" button. Your class extension should now be active, but currently, not doing anything. To make something happen, we need to either override an existing method within this class by creating a method of the same name as an existing one, or adding a new method entirely. Let's do the latter: <?php namespace Demo\\XF\\Pub\\Controller; class Member extends XFCP_Member { public function actionHelloWorld() { return $this->message('Hello world!'); } } We talk more about controllers, actions, and replies in the Controller basics pages, so don't particularly worry about understanding this right now. Now we've added some code to our extended controller, let's see it in action. Simply enter the following URL (relative to your board URL): index.php?members/hello-world . You should now see a \"Hello world!\" message displayed! As mentioned earlier, it is also possible to override existing methods within a class. For example, if we changed actionHelloWorld() with actionIndex() then you would no longer have a \"Notable members\" list, it would instead display the \"Hello world!\" message! This isn't quite the right way to extend an existing controller action (or any class method, in fact) but we go into more detail about that in the Modifying a controller action reply (properly) section. Type hinting \u00b6 A lot of objects within XF are instantiated through factory methods. For example, if we want to instantiate a specific repository, we would write the following: $repo = \\XF::repository('Demo:Thing'); This is a highly convenient and consistent way of instantiating an object. We know, just by looking at it, what object will be instantiated. The resulting code in that method knows how to return the correct object for what we've requested. Unfortunately, however, your IDE probably has no clue (at least by default). As far as the IDE is concerned, this method will return an object instance of XF\\Mvc\\Entity\\Repository . That's useful to a certain extent, but there's potentially lots of methods available in the specific Demo\\Repository\\Thing object which your IDE doesn't know about. This ultimately means that when you're trying to use your $repo object in the code, your IDE will not be able to make suggestions or auto complete method names and the arguments it requires. This is where type hinting becomes useful, and the syntax should be supported, by standard, by most IDEs and some \"PHP aware\" text editors. We would just change our repository call as follows: /** @var \\Demo\\Repository\\Thing $repo */ $repo = \\XF::repository('Demo:Thing'); The type hint above the repository call now tells the IDE that $repo relates to an object represented by the Demo\\Repository\\Thing class rather than the object it automatically inferred originally. Type hinting is especially useful when extending classes, too. A potential problem with our class extension methods are that essentially your classes don't extend the original class you want to extend, but instead this is proxied through a class that doesn't actually exist, e.g. XFCP_Member such as in the example above . To rectify this issue, we automatically generate a file named extension_hint.php and store that in your _output directory. This adds a reference that the IDE can read but PHP can't so that the IDE now understands that when we use $this inside any of the methods in this extended class that it can suggest and autocomplete methods and properties available in the Member controller or one of its parents.","title":"General concepts"},{"location":"general-concepts/#general-concepts","text":"The following sections go into detail about some of the general systems and concepts you will come across while developing a XenForo add-on. If you are familiar with XenForo 1.x development, then a lot of these concepts will seem familiar to you, though it's worth reviewing them as there are some excellent new tools and features to help you develop add-ons.","title":"General concepts"},{"location":"general-concepts/#vendor-components","text":"XF2 is not powered by a specifc framework as XF1 was, however, we have employed the use of certain popular, well-tested, open source packages to help with specific tasks. For example, we use a project named SwiftMailer for email sending and a project named Guzzle as a HTTP client. All third party projects are loaded from the src/vendor directory. It is not currently possible for add-on developers to add their own dependencies to this location.","title":"Vendor components"},{"location":"general-concepts/#integrated-development-environment-ide","text":"Before starting work on XF2 development, you may want to spend some time evaluating the application with which you will actually be creating and editing PHP files. This is commonly referred to as an IDE. There are a number of options available ranging from basic Notepad to something like Sublime Text which can be expanded to have better PHP support with add-ons, up to a proper IDE, such as PhpStorm . Internally, we use PhpStorm as our preferred IDE. This is a premium and commercial product, but there may be free alternatives available. Either way, no one can tell you the best application for your requirements, and you should spend some time with a number of products (even free ones) and use that experience to find out your preference.","title":"Integrated Development Environment (IDE)"},{"location":"general-concepts/#autoloader","text":"XF2 uses an autoloader which is automatically generated by Composer. This allows all XF code, third party vendor code, and any add-on developer code to be automatically included throughout the entire project without having to include/require your classes manually. The autoload root for all XF add-ons is the src/addons directory. This means that all of your class names will be relative to this base location. It's also worth noting that XF2 employs a strict \"class per file\" pattern to naming. Each file should only contain a single class, and the name of that class should identify the exact location of the class PHP file on the file system. For example, if you want to create a new class in a file named src/addons/Demo/Setup.php (where Demo is your add-on ID) then this class will be named Demo\\Setup . Conversely, if you had a class named Demo\\Entity\\Thing then you will know the file for this class is located in the path src/addons/Demo/Entity/Thing.php .","title":"Autoloader"},{"location":"general-concepts/#namespaces","text":"Throughout XF we use namespaces so that we can reference classes in the same namespace more succinctly. It is recommended that all add-ons also use namespaces. In the above example we talked about a class named Demo\\Setup . Using namespaces, the class would actually be named simply Setup but the namespace will be set to Demo . As a more concrete example, we also talked above about a class named Demo\\Entity\\Thing . Let's see what the PHP code would look like for this class: <?php namespace Demo\\Entity; class Thing { } If there was a class named AnotherThing in the src/addons/Demo/Entity directory, we could reference this class in the Thing class simply as AnotherThing because that class is in the same Demo\\Entity namespace.","title":"Namespaces"},{"location":"general-concepts/#short-class-names","text":"Occasionally, classes referenced in XF are shortened. For example, if you wish to call the User entity (more on entities below) then you may see the class name referenced as simply XF:User . The use of short class names and the full class name they resolve to, is entirely context sensitive. Therefore, in the context of a call to an entity, the short class name will resolve to the following full class name XF\\Entity\\User . The XF part indicates the file path (based on add-on ID), the Entity part is implied by calling the entity and the User part indicates the specific entity. Similarly when you start creating your own classes, you will also use short class names to reference your own classes. For example, if you need to create a new Thing entity for your Demo add-on, then you would write the following: \\XF::em()->create('Demo:Thing'); This would resolve to the Demo\\Entity\\Thing class. Similarly, if you wanted to access a Thing repository, you would write it as follows: \\XF::repository('Demo:Thing'); Notice how the short class names are identical. The repository call would actually resolve to Demo\\Repository\\Thing .","title":"Short class names"},{"location":"general-concepts/#extending-classes","text":"A great deal number of classes in XF2 are extendable which allows developers to extend and override the core code without having to directly edit it. If you're familiar with XF1 development, you will be somewhat familiar with the following process: Create a Listener PHP file Create a class which will ultimately extend the original class Write a function which matches the expected callback signature for one of the load_class events and adds the name of your extended class Add a \"Code event listener\" in the Admin CP which specifies the Listener class and method name for the function mentioned above, and optionally hint as to which class is being extended In XF2 we have removed these events in favour of a specific system called \"Class extensions\". The process is as follows: Create a class which will ultimately extend the original class Add a \"Class extension\" in the Admin CP which specifies the name of the class you are extending and the name of the class which is extending it This clearly cuts down on some of the boilerplate required to extend classes, and also provides a dedicated UI for viewing and managing these extensions. Let's look at the process by extending the public Member controller, and adding a new action which displays a simple message. The first thing to do is to create an add-on. We previously outlined how to do that using the xf-addon:create command here . For this example, we'll assume you created an add-on with an ID and title of \"Demo\". You will now have an addon.json file for this add-on in the following location src/addons/Demo/addon.json . Note Although, strictly speaking, you can place your extended classes wherever you like within your add-on directory, it is recommended to put extended classes in a directory which easily identifies a) the add-on the class belongs to b) the type of class being extended and c) the name of the class being extended. In the following examples, we are extending the public XF Member controller so we will place our extended class in the following path: src/addons/Demo/XF/Pub/Controller/Member.php . The extended class needs to exist before we add the class extension to the Admin CP. So, follow the following instructions: Create a new directory named XF inside src/addons/Demo Create a new directory named Pub inside src/addons/Demo/XF Create a new directory named Controller inside src/addons/Demo/XF/Pub Create a new file named Member.php inside src/addons/Demo/XF/Pub/Controller The initial contents of your PHP file, should be as follows: <?php namespace Demo\\XF\\Pub\\Controller; class Member extends XFCP_Member { } If you're familiar with extending PHP classes generally, but not familiar with XF, the above example may initially seem confusing. The reason for that is you may have been expecting to extend the XF\\Pub\\Controller\\Member class directly, rather than XFCP_Member . In XF we use the \"XenForo Class Proxy\" system (XFCP for short) to build an \"inheritance chain\" which ultimately allows a single class to be extended by multiple add-ons. The convention is to reference a dummy extended class which is the current class name Member and prefix it with XFCP_ . Now the class has been created, we can create the class extension on the Admin CP > Development > Class extensions > Add class extension page. All you need to do is enter the base class name ( XF\\Pub\\Controller\\Member ) in the first field, and the extended class name (which you just created) in the second field ( Demo\\XF\\Pub\\Controller\\Member ) and click the \"Save\" button. Your class extension should now be active, but currently, not doing anything. To make something happen, we need to either override an existing method within this class by creating a method of the same name as an existing one, or adding a new method entirely. Let's do the latter: <?php namespace Demo\\XF\\Pub\\Controller; class Member extends XFCP_Member { public function actionHelloWorld() { return $this->message('Hello world!'); } } We talk more about controllers, actions, and replies in the Controller basics pages, so don't particularly worry about understanding this right now. Now we've added some code to our extended controller, let's see it in action. Simply enter the following URL (relative to your board URL): index.php?members/hello-world . You should now see a \"Hello world!\" message displayed! As mentioned earlier, it is also possible to override existing methods within a class. For example, if we changed actionHelloWorld() with actionIndex() then you would no longer have a \"Notable members\" list, it would instead display the \"Hello world!\" message! This isn't quite the right way to extend an existing controller action (or any class method, in fact) but we go into more detail about that in the Modifying a controller action reply (properly) section.","title":"Extending classes"},{"location":"general-concepts/#type-hinting","text":"A lot of objects within XF are instantiated through factory methods. For example, if we want to instantiate a specific repository, we would write the following: $repo = \\XF::repository('Demo:Thing'); This is a highly convenient and consistent way of instantiating an object. We know, just by looking at it, what object will be instantiated. The resulting code in that method knows how to return the correct object for what we've requested. Unfortunately, however, your IDE probably has no clue (at least by default). As far as the IDE is concerned, this method will return an object instance of XF\\Mvc\\Entity\\Repository . That's useful to a certain extent, but there's potentially lots of methods available in the specific Demo\\Repository\\Thing object which your IDE doesn't know about. This ultimately means that when you're trying to use your $repo object in the code, your IDE will not be able to make suggestions or auto complete method names and the arguments it requires. This is where type hinting becomes useful, and the syntax should be supported, by standard, by most IDEs and some \"PHP aware\" text editors. We would just change our repository call as follows: /** @var \\Demo\\Repository\\Thing $repo */ $repo = \\XF::repository('Demo:Thing'); The type hint above the repository call now tells the IDE that $repo relates to an object represented by the Demo\\Repository\\Thing class rather than the object it automatically inferred originally. Type hinting is especially useful when extending classes, too. A potential problem with our class extension methods are that essentially your classes don't extend the original class you want to extend, but instead this is proxied through a class that doesn't actually exist, e.g. XFCP_Member such as in the example above . To rectify this issue, we automatically generate a file named extension_hint.php and store that in your _output directory. This adds a reference that the IDE can read but PHP can't so that the IDE now understands that when we use $this inside any of the methods in this extended class that it can suggest and autocomplete methods and properties available in the Member controller or one of its parents.","title":"Type hinting"},{"location":"lets-build-an-add-on/","text":"Let's build an add-on \u00b6 For some people, getting stuck straight into a project is the best way to learn, and the aim is that in the following sections you will learn how to build an add-on, from scratch. Be prepared; this isn't a simple 'Hello world' type demo. This is actually a fairly full featured demo add-on which covers a number of concepts within XF2. The add-on we're going to build will allow users with the appropriate permission to \"feature\" a thread, and allow that thread to be displayed on a new page. We'll even set up a process which automatically features threads in specific forums. We will use a new route for this named portal and eventually set that as the index page route and set the \"Home\" tab to be selected when viewing that page. Create the add-on \u00b6 Throughout the add-on we will use the add-on ID of Demo/Portal . The first thing we need to do is create the add-on, for this we need to open a command prompt / shell / terminal window, change the directory to your XF installation root (where cmd.php is located) and run the following command, and enter the responses displayed below: Terminal $ php cmd.php xf-addon:create Enter an ID for this add-on: Demo/Portal Enter a title: Demo - Portal Enter a version ID: This integer will be used for internal variable comparisons. Each release of your addon should increase this number: 1000010 Version string set to: 1.0.0 Alpha Does this add-on supersede a XenForo 1 add-on? (y/n) n The addon.json file was successfully written out to /var/www/src/addons/Demo/Portal/addon.json Does your add-on need a Setup file? (y/n) y Does your Setup need to support running multiple steps? (y/n) y The Setup.php file was successfully written out to /var/www/src/addons/Demo/Portal/Setup.php The add-on has now been created, you will now find that you have a new directory in the src/addons directory, and you will find the add-on in the \"Installed add-ons\" list of the Admin CP. One of the files that has been created is the addon.json file, which currently looks like this: { \"legacy_addon_id\": \"\", \"title\": \"Demo - Portal\", \"description\": \"\", \"version_id\": 1000010, \"version_string\": \"1.0.0 Alpha\", \"dev\": \"\", \"dev_url\": \"\", \"faq_url\": \"\", \"support_url\": \"\", \"extra_urls\": [], \"require\": [], \"icon\": \"\" } Let's fill in some of these details: { \"legacy_addon_id\": \"\", \"title\": \"Demo - Portal\", \"description\": \"Add-on which will display featured threads on the forum home page.\", \"version_id\": 1000010, \"version_string\": \"1.0.0 Alpha\", \"dev\": \"You!\", \"dev_url\": \"\", \"faq_url\": \"\", \"support_url\": \"\", \"extra_urls\": [], \"require\": [], \"icon\": \"fa-home\" } We have now added a description , the developer's name ( dev ) and specified that we want to display an icon ( icon ). The icon can either be a path (relative to your add-on root) or the name of a Font Awesome icon as we've done here. As we're not superceding a XenForo 1 addon, we can disregard legacy_addon_id . For a full explaination of all of the properties in the addon.json file, refer to the Add-on structure section . Creating the Setup class \u00b6 Well, strictly speaking, the class has already been created and written out to Setup.php but right now it doesn't really do anything. We've basically got a skeleton class for it which looks like this: <?php namespace Demo\\Portal; use XF\\AddOn\\AbstractSetup; use XF\\AddOn\\StepRunnerInstallTrait; use XF\\AddOn\\StepRunnerUninstallTrait; use XF\\AddOn\\StepRunnerUpgradeTrait; class Setup extends AbstractSetup { use StepRunnerInstallTrait; use StepRunnerUpgradeTrait; use StepRunnerUninstallTrait; } We talked a little bit already about the Setup class. We're going to be breaking the install, upgrade and uninstall processes into separate steps. Let's start by importing some useful Schema classes. If you want to learn more about them, you can refer to the Managing the Schema section . Just after the last use declaration, add the following lines: use XF\\Db\\Schema\\Alter; use XF\\Db\\Schema\\Create; The StepRunner traits here are going to handle the process of cycling through all of the available steps, so all we have to do is start creating those steps. We'll begin by adding some code to create a new column in the xf_forum table: <?php namespace Demo\\Portal; use XF\\AddOn\\AbstractSetup; use XF\\AddOn\\StepRunnerInstallTrait; use XF\\AddOn\\StepRunnerUninstallTrait; use XF\\AddOn\\StepRunnerUpgradeTrait; use XF\\Db\\Schema\\Alter; use XF\\Db\\Schema\\Create; class Setup extends \\XF\\AddOn\\AbstractSetup { use StepRunnerInstallTrait; use StepRunnerUpgradeTrait; use StepRunnerUninstallTrait; public function installStep1() { $this->schemaManager()->alterTable('xf_forum', function(Alter $table) { $table->addColumn('demo_portal_auto_feature', 'tinyint')->setDefault(0); }); } } This column is being added to the xf_forum table so that we can set certain forums up to have threads automatically featured when they are created. The naming here is significant; columns added to core XF tables should always be prefixed. This serves two important purposes. The first being that there is less risk of conflicts happening with duplicate column names, in case XF or another add-on has reason to add that column in the future. The second being that it helps more easily identify which columns belong to which add-ons in case some issues arise in the future. While we're here, we might as well add another step to the installer. For brevity, we'll just display the new code, rather than the entire class. It should be placed directly below the installStep1() method: public function installStep2() { $this->schemaManager()->alterTable('xf_thread', function(Alter $table) { $table->addColumn('demo_portal_featured', 'tinyint')->setDefault(0); }); } This step, similar to the step above, will add a new column this time to the xf_thread table. We'll use this column as a cached value to quickly identify whether a thread is featured or not, without having to perform additional queries or a lookup against the xf_demo_portal_featured_thread table. Speaking of which, we should add that table now. This time directly below installStep2() : public function installStep3() { $this->schemaManager()->createTable('xf_demo_portal_featured_thread', function(Create $table) { $table->addColumn('thread_id', 'int'); $table->addColumn('featured_date', 'int'); $table->addPrimaryKey('thread_id'); }); } This step is going to create the new table. This table will be used to keep a log of all of the threads that have been featured, and when they were featured. The same principles apply here in terms of naming. A significant difference is that all tables should additionally be prefixed with xf_ . The reason for this is so that if a clean XF install is performed, we can remove all tables with the xf_ prefix, including those created by add-ons. One of the simplest things to forget when adding the code which adds various schema changes is to forget to apply the schema changes yourself. You can run install/upgrade steps using a CLI command. In this case, execute the following commands: Terminal $ php cmd.php xf-addon:install-step Demo/Portal 1 $ php cmd.php xf-addon:install-step Demo/Portal 2 $ php cmd.php xf-addon:install-step Demo/Portal 3 Extending the forum entity \u00b6 So far we've added a column to the xf_forum table, it's now time to extend the Forum entity structure. We need to do this so that the entity knows about our new column, and so that data can be read from and written to it via the entity. Note The following steps will require Development mode to be enabled. Remember to set Demo/Portal as the defaultAddOn value in config.php . The first step in this process is to create a \"Code event listener\". This can be done in the Admin CP under Development, click the \"Code event listeners\" link and click the \"Add code event listener\" button. We need to listen to the entity_structure event. We will use this to modify the default forum entity structure to add our newly created demo_portal_auto_feature column. In the \"Event hint\" field, we will enter the name of the class we're extending, e.g. XF\\Entity\\Forum . This will ensure our listener only executes on the forum entity. For the \"Execute callback\" class enter Demo\\Portal\\Listener and for the method enter forumEntityStructure . It's worth adding a description to explain what this listener is for, as this will help more easily identify the listener in the code event listener list. \"Extends the XF\\Entity\\Forum structure\" should be sufficient. Finally, make sure the \"Demo - Portal\" add-on is selected. Before we click \"Save\" we need to actually create the Listener class. So create a new file named Listener.php in src/addons/Demo/Portal . The contents of this file should be as follows, initially. We know the arguments this function requires from the documentation below the code event selector. <?php namespace Demo\\Portal; use XF\\Mvc\\Entity\\Entity; class Listener { public static function forumEntityStructure(\\XF\\Mvc\\Entity\\Manager $em, \\XF\\Mvc\\Entity\\Structure &$structure) { } } Notice the use declaration between the namespace and class name. We will be referencing the class declared here more than once, so declaring it here does allow us to reference it by its much shorter alias, in this case, Entity . This code won't actually do anything yet, but now is a good time to save the code event listener, so go ahead and click the \"Save\" button. Before we add some functional code to our new function, now might be a good time to see how the development output system works. Check out the new directories and files added to your add-on directory. Specifically there is a new JSON file in the _output/code_event_listeners directory, which should look like this: { \"event_id\": \"entity_structure\", \"execute_order\": 10, \"callback_class\": \"Demo\\\\Portal\\\\Listener\", \"callback_method\": \"forumEntityStructure\", \"active\": true, \"hint\": \"XF\\\\Entity\\\\Forum\", \"description\": \"Extends the XF\\\\Entity\\\\Forum structure\" } Whenever changes are made to the listener this file will update automatically. Right, let's add some more code. Back inside the Listener class, add the following to the forumEntityStructure function: $structure->columns['demo_portal_auto_feature'] = ['type' => Entity::BOOL, 'default' => false]; The forum entity is now aware of our new column, but there are a few more steps we should take care of first before we can begin to implement a way to actually start setting values on that column. Extending the thread entity \u00b6 Again, as we have added a new column to the xf_thread table, we should make the Thread entity aware of that. This is very similar to what we did above. Head back to \"Add code event listener\" and listen to entity_structure again. The \"Event hint\" this time will be XF\\Entity\\Thread . We can use the same callback class as before ( Demo\\Portal\\Listener ) but this time the method will be named threadEntityStructure . Add a description similar to before. Before saving, we should add the code, directly below the forumEntityStructure function: public static function threadEntityStructure(\\XF\\Mvc\\Entity\\Manager $em, \\XF\\Mvc\\Entity\\Structure &$structure) { $structure->columns['demo_portal_featured'] = ['type' => Entity::BOOL, 'default' => false]; } This code is almost identical to what we added to the forum entity structure; really the only difference is the column name. But, we do need to add something else. We should create an entity relation so that, later on, should we need to access the featured thread entity (which we create in the next section) we can do so easily with a finder query. Below the $structure->columns line add: $structure->relations['FeaturedThread'] = [ 'entity' => 'Demo\\Portal:FeaturedThread', 'type' => Entity::TO_ONE, 'conditions' => 'thread_id', 'primary' => true ]; See Relations for more information about relations. Hit \"Save\" to save the listener. Creating a new entity \u00b6 Above in installStep3() we created a new table. We are going to need to create an entity to interact with and create new records in this table. Because this is a brand new entity we don't need to do anything other than create the class inside src/addons/Demo/Portal/Entity/FeaturedThread.php , the skeleton for which will look like this: <?php namespace Demo\\Portal\\Entity; use XF\\Mvc\\Entity\\Structure; class FeaturedThread extends \\XF\\Mvc\\Entity\\Entity { } We need to use this to define the entity structure which represents our new xf_demo_portal_featured_thread table which we created earlier. The structure for this entity should look like this: public static function getStructure(Structure $structure) { $structure->table = 'xf_demo_portal_featured_thread'; $structure->shortName = 'Demo\\Portal:FeaturedThread'; $structure->primaryKey = 'thread_id'; $structure->columns = [ 'thread_id' => ['type' => self::UINT, 'required' => true], 'featured_date' => ['type' => self::UINT, 'default' => time()] ]; $structure->getters = []; $structure->relations = [ 'Thread' => [ 'entity' => 'XF:Thread', 'type' => self::TO_ONE, 'conditions' => 'thread_id', 'primary' => true ], ]; return $structure; } The list of columns is probably self explanatory based on the MySQL we wrote earlier to create the table. The relations includes a Thread relation, which will allow us to get the related thread entity record (and even the thread entity relations) from this entity. Modifying the forum edit form \u00b6 We now need a way to modify the forum_edit template to add a new checkbox there which can ultimately write back to the new column we have now created. We'll do this by creating a template modification. This is done from the Admin CP under Appearance and then click Template modifications. Click the \"Admin\" tab followed by the \"Add template modification\" button. In the \"Template\" field, type \"forum_edit\". This is the template we need to modify. In the \"Modification key\" field, type \"demo_portal_forum_edit\". This is a unique key which identifies your template modification. The preferred convention for this is, at minimum, to mention the add-on followed by the template name being modified. The \"Description\" field should contain some text to help you identify the purpose of this modification when looking down the template modifications list. Something like \"Adds auto feature checkbox to the forum_edit template\" should suffice. When you entered the template name in the \"Template\" field, you may notice that a preview of the template contents was displayed. We need to use this to identify the preferred place for our checkbox. While viewing the forum edit page, you may notice there's a series of checkboxes and this looks like a reasonable location. The simplest way to place a checkbox in this section is to do a simple replacement on the top checkbox, so in the \"Find\" field add: <xf:option name=\"allow_posting\" And in the replace field: <xf:option name=\"demo_portal_auto_feature\" selected=\"$forum.demo_portal_auto_feature\" label=\"Automatically feature threads in this forum\" hint=\"If selected, any new threads posted in this forum will be automatically featured.\" /> $0 We don't need to worry about creating phrases, yet, we can pick those up later. Notice that the name attribute matches the name of the column we created earlier, and more significantly, the checked state of the checkbox row also reads the newly added column from the forum entity. When we save the template modification later, if the contents of the find field matches any part of the template then it will be replaced with the contents of the replace field. We are not actually removing what we have matched because the $0 in the replace field is re-inserting the matched text. We can use the \"Test\" button to check the replacement is working as expected. When the test button is clicked, an overlay with the modified template will appear. If all goes well, a green area should be highlighted with the new code we want to add. Note This is a fairly simple replacement. For more advanced matching, you can also use the \"Regular expression\" type. A detailed explanation of working with regular expressions is beyond the scope for this guide, but there are lots of resources online which may help. Finally, click save to save your template modification. If all has gone well, when you return to the template modifications list, you will see the log summary is displaying 1 / 0 / 0 therefore indicating that the modification successfully applied one time. An even better indicator that it has worked as planned is to go to the \"Nodes\" page listed under \"Forums\" in the Admin CP, and edit an existing forum. Our newly added template modification should now appear. Extending the forum save process \u00b6 We have our column, we have a UI to pass an input to that column, now we have to handle saving data to that column. We will do this by extending the Forum controller and extending a special method which is called when a node and its data are saved. First, let's create a \"Class extension\" which can be found under the \"Development\" entry in the Admin CP. Click \"Add class extension\". Here we need to specify a \"Base class name\" which is the name of the class we are extending, which in this case will be XF\\Admin\\Controller\\Forum . And we need to specify a \"Extension class name\" which is the class which will extend the base class. Enter this as Demo\\Portal\\XF\\Admin\\Controller\\Forum . We should create that class before clicking Save. Create a new file in src/addons/Demo/Portal/XF/Admin/Controller named Forum.php . This might seem like quite a long path, but we recommend a path like this for extended classes. It enables you to more easily identify the files that represent extended classes by virtue of the fact that they are in a directory of the same name as the extended \"add-on\" ID (in this case XF ). It also makes it clear exactly which class has been extended as the directory structure follows the same path as the default class. The contents of the file should, for now, look like this: <?php namespace Demo\\Portal\\XF\\Admin\\Controller; class Forum extends XFCP_Forum { } See Extending classes and Type hinting for more information. Click save to save the Class extension. Now we can add some code. The particular method we need to extend is a protected function called saveTypeData . When extending any existing method in any class, it is important to inspect the original method for a couple of reasons. The first being we want to make sure the arguments we use in the extended method, match that of the method we're extending. The second being that we need to know what this method actually does. For example, should the method be returning something of a particular type, or a certain object? This is certainly the case in most controller actions as we mentioned in the Modifying a controller action reply (properly) section. However, although this method is within a controller, it isn't actually a controller action itself. In fact, this particular method is a \"void\" method; it isn't expected to return anything. However, we should always ensure we call the parent method in our extended method so let's just add the new method itself, without the new code we need to add: protected function saveTypeData(FormAction $form, \\XF\\Entity\\Node $node, \\XF\\Entity\\AbstractNode $data) { parent::saveTypeData($form, $node, $data); } Warning This particular method's argument list assumes that we have a use declaration which aliases the full \\XF\\Mvc\\FormAction class to simply FormAction . You will therefore need to add that use declaration yourself. Add use XF\\Mvc\\FormAction; between the namespace and class lines. So, right now, we've extended that method, and our extension should be called, but right now it isn't doing anything other than calling its parent method. We now need to get the value of the input from the forum edit page and apply that to the $data entity (which in this case is the Forum entity). protected function saveTypeData(FormAction $form, \\XF\\Entity\\Node $node, \\XF\\Entity\\AbstractNode $data) { parent::saveTypeData($form, $node, $data); $form->setup(function() use ($data) { $data->demo_portal_auto_feature = $this->filter('demo_portal_auto_feature', 'bool'); }); } Using the FormAction object allows us to have various extension points into the process that runs during the course of a typical form submission. It isn't available for all controller actions. It is much more prevalent in the Admin CP, for example, which often follow a simple CRUD model (Create, Read, Update, Delete). A lot of other processes within XF happen inside a service object, which usually has specific extension points related to the service that is running. This particular usage of the FormAction object is somewhat different to what you would usually encounter. Saving a node is a somewhat different process, because as well as working with the node entity, you'll also be working with an associated type of node, e.g. a forum entity. We do have access to the form action object in this method, though, so we should use it. We've used it here to add a specific behaviour to the \"setup\" phase of the process. Namely, when the FormAction object's run() method is called, it will run through the various phases in a specific order. It doesn't matter which order those behaviors were added to the object in, they will still run in the order setup , validate , apply , complete . The code we added above lets us set our demo_portal_auto_feature column in the forum entity to whatever value is stored for the demo_portal_auto_feature input which we added to the forum edit page. It should now be possible to test that all of this works. Simply edit a forum of your choice and check the checkbox. You should be able to observe two things. First, when you go back into edit that forum, the checkbox should now be checked. Second, if you look in the xf_forum table for the forum you just edited, the demo_portal_auto_feature field should now be set to 1. Keep this value enabled for this forum, as we will eventually be automatically featuring threads from that forum. Setting a thread to be featured automatically \u00b6 We've added a new column to the forum entity which will allow us to automatically feature a thread when it is newly created in this forum, so now it's time to add the code which will do this. In XF2, we make heavy use of Service objects. These typically take a \"setup and go\" type approach; you setup your configuration and then call a method to complete the action. We use a service object to setup and perform the thread creation, so this is a perfect place to add the code we need. It all starts with another class extension, so go to the \"Add class extension\" page. This time, the base class will be XF\\Service\\Thread\\Creator and the extension class will be Demo\\Portal\\XF\\Service\\Thread\\Creator and, as usual, this new class will look something like the code below. Create that code in the path src/addons/Demo/Portal/XF/Service/Thread/Creator.php then click \"Save\" to create the extension. <?php namespace Demo\\Portal\\XF\\Service\\Thread; class Creator extends XFCP_Creator { } While we're here we will also create another extension. The base will be XF\\Pub\\Controller\\Forum and the extension class will be Demo\\Portal\\XF\\Pub\\Controller\\Forum . Creating the following code in the path src/addons/Demo/Portal/XF/Pub/Controller/Forum.php and click \"Save\": <?php namespace Demo\\Portal\\XF\\Pub\\Controller; class Forum extends XFCP_Forum { } We're ultimately going to extend the _save() method in our extended thread creator object so we can feature our thread after it has been created. To fit in with the \"setup and go\" approach, we will create a method which can be used to indicate whether the thread should be created as featured, or not. For this, we need two things; a class property to store the value (it defaults to null) and a public method to allow that property to be set. protected $featureThread; public function setFeatureThread($featureThread) { $this->featureThread = $featureThread; } Going back to our newly extended forum controller, we will now extend the method that sets up the creator service, and opt in to featuring if the forum entity has the necessary value set. Remember, before extending a method, we need to know what it is expected to return (if anything), and ensure we call the parent method. If the parent method does return something, then it is this which we should return after our code has finished. The setupThreadCreate() method in this case returns the set up creator service, so we will start this off as follows: protected function setupThreadCreate(\\XF\\Entity\\Forum $forum) { /** @var \\Demo\\Portal\\XF\\Service\\Thread\\Creator $creator */ $creator = parent::setupThreadCreate($forum); return $creator; } As expected, this doesn't actually do anything; the extended code is called, but all it does is return whatever was returned by the parent call. We should now modify the $creator to set up featuring if it applies to the forum we're currently working with. In between the $creator line and the return line, add: if ($forum->demo_portal_auto_feature) { $creator->setFeatureThread(true); } We can now add the _save() method to the extended creator class: protected function _save() { $thread = parent::_save(); return $thread; } To make sure this thread gets featured, in between the $thread line and the return line we just need to add: if ($this->featureThread && $thread->discussion_state == 'visible') { /** @var \\Demo\\Portal\\Entity\\FeaturedThread $featuredThread */ $featuredThread = $thread->getRelationOrDefault('FeaturedThread'); $featuredThread->save(); $thread->fastUpdate('demo_portal_featured', true); } Because we earlier created the FeaturedThread relation on the thread entity, we can actually use that relation for creation too! There is a method named getRelationOrDefault() which we use here. This will see if that relation actually returns an existing record, and if it doesn't, it will create the entity and set it up with any default values even the thread ID! This means we actually need to do little more than to get the default relation and save it to insert it into the database. Additionally, we should set the demo_portal_featured field to true. Because the thread entity has already been saved (when the original class saved the entity) we can use the fastUpdate() method to quickly update that field. We now need to try this all out and make sure it works. Go to the forum which you enabled the demo_portal_auto_feature option on earlier, and create a new thread. The only way to tell if it is working right now is to check the xf_demo_portal_featured_thread table and in doing that we should see a new record in there! Create the portal page \u00b6 There's still a considerable amount of work to do before we're finished, but now we have the ability to feature threads, it certainly would be nice if we could display them somewhere, so let's start creating our portal page. To do this we need a new public route. Go to the Admin CP and under \"Development\" click \"Routes\" then click \"Add route: Public\". We're going to keep this quite simple, for now. The route prefix is going to be \"portal\", the section context is going to be \"home\" and the controller is going to be \"Demo\\Portal:Portal\". We should now create that controller at the path src/addons/Demo/Portal/Pub/Controller/Portal.php with the following basic contents: <?php namespace Demo\\Portal\\Pub\\Controller; class Portal extends \\XF\\Pub\\Controller\\AbstractController { } We want our portal to be displayed to people when they visit the index.php?portal page. This URL doesn't have an \"action\" part - just the route prefix we just created. With that in mind, the code we need to add to display the portal page, should be in the actionIndex() method. The basic code we will need in that is: public function actionIndex() { $viewParams = []; return $this->view('Demo\\Portal:View', 'demo_portal_view', $viewParams); } Now, this won't exactly work, yet, because we haven't created the template, yet, but this is enough, for now, to at least demonstrate our route and controller are talking to each other. So visiting index.php?portal should at the very least display a 'Template error'. As was mentioned in the View reply section, the first argument is a view class, but we don't need to actually create this class. This class could be extended by other add-ons, if necessary, even if it doesn't exist. The second argument is the template, which we need to create now in the path src/addons/Demo/Portal/_output/templates/public/demo_portal_view.html . That template, for now, should simply contain the following: <xf:title>Portal</xf:title> If we now visit the portal page, the template error will be gone, and although we will still have a fairly blank looking page, it will at least now have the title \"Portal\". Now, it's time to start adding the code which will display a list of featured threads. The first step to this is to create a repository for some of our common base finder queries. So, create a new file in the path src/addons/Demo/Portal/Repository/FeaturedThread.php and add the following code: <?php namespace Demo\\Portal\\Repository; use XF\\Mvc\\Entity\\Finder; use XF\\Mvc\\Entity\\Repository; class FeaturedThread extends Repository { /** * @return Finder */ public function findFeaturedThreadsForPortalView() { $visitor = \\XF::visitor(); $finder = $this->finder('Demo\\Portal:FeaturedThread'); $finder ->setDefaultOrder('featured_date', 'DESC') ->with('Thread', true) ->with('Thread.User') ->with('Thread.Forum', true) ->with('Thread.Forum.Node.Permissions|' . $visitor->permission_combination_id) ->with('Thread.FirstPost', true) ->with('Thread.FirstPost.User') ->where('Thread.discussion_type', '<>', 'redirect') ->where('Thread.discussion_state', 'visible'); return $finder; } } What we're doing here is using the finder to query for all featured threads, in reverse featured_date order, and joining to the xf_thread table and from that table joining to the xf_user table for the thread creator, xf_forum table, the xf_post table and from there joining to the xf_user table again for the post creator. We've asserted that the thread, forum and first post must exist by specifying true for that argument so these will be performed as INNER JOIN whereas the user queries will be performed with a LEFT JOIN . It's possible that the author of some threads and posts may not exist (for example if they were posted automatically by the RSS feeder system, or posted by guests). We also have a special join here that fetches the current visitor's permissions along with the query. This will reduce the number of queries needed to render the portal page, as we will be doing a number of things (later) to only display featured threads to users who have permission to view them. This doesn't return the results of this query. This returns the finder object itself. This enables a clear extension point in case another add-on needs to extend our code, and also allows us to make further changes before fetching that data (such as for setting a limit/offset for pagination, or setting a different order). Let's now use that in our actionIndex() method inside our portal controller. Change the existing $viewParams = []; line to the following: /** @var \\Demo\\Portal\\Repository\\FeaturedThread $repo */ $repo = $this->repository('Demo\\Portal:FeaturedThread'); $finder = $repo->findFeaturedThreadsForPortalView(); $viewParams = [ 'featuredThreads' => $finder->fetch() ]; At this stage, we're not going to worry about modifying the base finder we've retrieved from the repo. Instead, let's start to actually see some results, and update the demo_portal_view template as follows (after the <xf:title> tags): <xf:if is=\"$featuredThreads is not empty\"> <xf:foreach loop=\"$featuredThreads\" value=\"$featuredThread\"> <xf:macro name=\"thread_block\" arg-thread=\"{$featuredThread.Thread}\" arg-post=\"{$featuredThread.Thread.FirstPost}\" arg-featuredThread=\"{$featuredThread}\" /> </xf:foreach> <xf:else /> <div class=\"blockMessage\">No threads have been featured yet.</div> </xf:if> <xf:macro name=\"thread_block\" arg-thread=\"!\" arg-post=\"!\" arg-featuredThread=\"!\"> <xf:css src=\"message.less\" /> <div class=\"block\"> <div class=\"block-container\" data-xf-init=\"lightbox\"> <h4 class=\"block-header\"><a href=\"{{ link('threads', $thread) }}\">{$thread.title}</a></h4> <div class=\"block-body\"> <xf:macro name=\"message\" arg-post=\"{$post}\" arg-thread=\"{$thread}\" arg-featuredThread=\"{$featuredThread}\" /> </div> <div class=\"block-footer\"> <a href=\"{{ link('threads', $thread) }}\">Continue reading...</a> </div> </div> </div> </xf:macro> <xf:macro name=\"message\" arg-post=\"!\" arg-thread=\"!\" arg-featuredThread=\"!\"> <div class=\"message message--post message--simple\"> <div class=\"message-inner\"> <div class=\"message-cell message-cell--main\"> <div class=\"message-content js-messageContent\"> <div class=\"message-attribution\"> <div class=\"contentRow contentRow--alignMiddle\"> <div class=\"contentRow-figure\"> <xf:avatar user=\"{$post.User}\" size=\"xxs\" defaultname=\"{$post.username}\" href=\"\" /> </div> <div class=\"contentRow-main contentRow-main--close\"> <ul class=\"listInline listInline--bullet u-muted\"> <li><xf:username user=\"{$thread.User}\" /></li> <li><xf:date time=\"{$featuredThread.featured_date}\" /></li> <li><a href=\"{{ link('forums', $thread.Forum) }}\">{$thread.Forum.title}</a></li> <li>{{ phrase('replies:') }} {$thread.reply_count|number}</li> </ul> </div> </div> </div> <div class=\"message-userContent lbContainer js-lbContainer\" data-lb-id=\"post-{$post.post_id}\" data-lb-caption-desc=\"{{ $post.User ? $post.User.username : $post.username }} &middot; {{ date_time($post.post_date) }}\" > <blockquote class=\"message-body\"> {{ bb_code($post.message, 'post', $post.User, { 'attachments': $post.attach_count ? $post.Attachments : [], 'viewAttachments': $thread.canViewAttachments() }) }} </blockquote> </div> </div> </div> </div> </div> </xf:macro> Now, admittedly, there's a lot going on here. Although it may look daunting, it's mostly just markup to display our featured threads in a reasonable style. There's a few things worth paying attention to, though. We start off the template with a condition that reads <xf:if is=\"$featuredThreads is not empty\"> . This is to chceck that the object returned by the finder actually contains featured thread records. If it doesn't, then we display an appropriate message. If we do have some records, we need to loop through each to display it. For each record, we call a macro . Macros are reusable portions of template code which are self documenting (in that you see which arguments are supported) and maintain their own scope which cannot be polluted with the arguments in the template calling the macro; meaning that macros are only aware of the arguments that are explicitly passed in and the global $xf param. The thread block macro displays the basic block for the featured thread, and then that calls another macro to display each message. Implementing the navigation tab \u00b6 You may have spotted when setting up the route that we specified the section context as \"home\", and when you visited the portal page, the home tab was selected, or alternatively you may not have seen a home tab at all if a homePageUrl is not set in options. We want to use the default home tab rather than creating one ourselves and potentially having a duplicate tab. To do this, we should use a code event listener to change the URL to our portal URL. In the Admin CP under Development click \"Code event listeners\" and click \"Add code event listener\". Listen to the event home_page_url , callback class will be Demo\\Portal\\Listener again, and this time the method will be named homePageUrl . The code for this new method should be fairly simple: public static function homePageUrl(&$homePageUrl, \\XF\\Mvc\\Router $router) { $homePageUrl = $router->buildLink('canonical:portal'); } Finally, we should consider changing the index page route to our portal page. Go to Admin CP and under Setup click Options followed by \"Basic board information\". Change the \"Index page route\" option to portal/ . While you're in the Admin CP, let's see what happens now when you click on the Board title in the header. This should take you to your index page. All being well, that index page should now be your portal! In addition to that, the Home tab should be visible, and selected. As an optional step, you may choose to add some additional navigation entries under the home tab. But, for now, let's move on. Manually featuring (or unfeaturing) threads \u00b6 So, we can automatically feature new threads. What about manually featuring existing threads? Or manually featuring threads during creation where auto featuring is not supported? This will be a good way to get our current portal page looking a bit more busy. To achieve this, we will add a template modification to a specific macro, and this macro is actually used during thread reply, thread edit and when creating a thread. This will involve extending the editor service and making changes to the existing code which handled the auto featuring. First step then is a new template modification. So go to \"Add template modification\" (make sure the \"Public\" tab is selected on the \"Template modifications\" list). This time the template we are modifying is helper_thread_options , we'll use demo_portal_helper_thread_options as the key and you can write a reasonable description. We can actually do a \"Simple replacement\" here so leave that radio selected and in the \"Find\" field add: <xf:if is=\"$thread.canLockUnlock()\"> In the \"Replace\" field add: <xf:if is=\"($thread.isInsert() AND !$thread.Forum.demo_portal_auto_feature AND $thread.canFeatureUnfeature()) OR ($thread.isUpdate() && $thread.canFeatureUnfeature())\" > <xf:option label=\"{{ phrase('demo_portal_featured') }}\" name=\"featured\" value=\"1\" selected=\"{$thread.demo_portal_featured}\"> <xf:hint>{{ phrase('demo_portal_featured_hint') }}</xf:hint> <xf:afterhtml> <xf:hiddenval name=\"_xfSet[featured]\" value=\"1\" /> </xf:afterhtml> </xf:option> </xf:if> $0 That condition is a little on the lengthy side, but it allows us to show the featured checkbox under two specific conditions: a) If the thread has not yet been created and the auto feature option is disabled for the forum and there is permission to feature or b) it's an existing thread and there is permission to feature/unfeature. A quick \"Test\" should show this additional code will be inserted just above the existing \"Open\" checkbox within the existing <xf:checkboxrow> . If that all looks good, click \"Save\". We have had to use template code directly within the modification here, because including a template (like we did before) won't work within an existing input or row tag in this way. We'll also need to create the phrases now for the label and hint, because it won't be possible to detect those later. Under \"Appearance\" go to \"Phrases\" and click \"Add phrase\". Make sure your add-on is selected. The \"Title\" of the first phrase will be \"demo_portal_featured\" and the text will be simply \"Featured\". Click \"Save and Exit\". Click \"Add phrase\" again. The \"Title\" for the second phrase will be \"demo_portal_featured_hint\" and the text will be \"Featured threads will appear on the Portal page.\" Back to the template code we just added to the modification; you may have noticed something. We have called a method on the thread entity, canFeatureUnfeature() , and this method does not exist, yet. We are going to use this eventually to do a permission check that will control whether a user can manually feature a thread or not. To add this method, we need a new class extension for the XF\\Entity\\Thread entity. So, do that now similar to how we've done it before. The extended class will be Demo\\Portal\\XF\\Entity\\Thread so create that in the path src/addons/Demo/Portal/XF/Entity/Thread.php with the contents: <?php namespace Demo\\Portal\\XF\\Entity; class Thread extends XFCP_Thread { public function canFeatureUnfeature() { return true; } } Ok, so, we haven't exactly done much here of value, yet. All the canFeatureUnfeature() method does is return true right now. Later on, we will implement some proper permissions and add them here. To test this works so far, open one of the threads you previously featured, and select \"Edit thread\" from the tools menu. We should see the \"Set thread status\" checkbox row has the \"Featured\" checkbox we added, and it should be checked, indicating that this thread is indeed featured. We can now move on to changing the thread editor service to look for this value and feature or unfeature accordingly. We are going to need two new class extensions for this. Go back to the \"Add class extensions\" page. The first one will have a base class of XF\\Pub\\Controller\\Thread and extension class of Demo\\Portal\\XF\\Pub\\Controller\\Thread . The second one will have a base class of XF\\Service\\Thread\\Editor and an extension class of Demo\\Portal\\XF\\Service\\Thread\\Editor . The editor service is actually going to be very similar to the extended creator service we created earlier, so create that in the relevant location. Here is all of the code for the extended class: <?php namespace Demo\\Portal\\XF\\Service\\Thread; class Editor extends XFCP_Editor { protected $featureThread; public function setFeatureThread($featureThread) { $this->featureThread = $featureThread; } protected function _save() { $thread = parent::_save(); if ($this->featureThread !== null && $thread->discussion_state == 'visible') { /** @var \\Demo\\Portal\\Entity\\FeaturedThread $featuredThread */ $featuredThread = $thread->getRelationOrDefault('FeaturedThread', false); if ($this->featureThread) { if (!$featuredThread->exists()) { $featuredThread->save(); $thread->fastUpdate('demo_portal_featured', true); } } else { if ($featuredThread->exists()) { $featuredThread->delete(); $thread->fastUpdate('demo_portal_featured', false); } } } return $thread; } } This is a little bit more involved than the code in the creator service. For example, there may be situations where a thread is edited, and the user has no permission to edit the thread, and therefore we don't show the checkboxes. In these cases, we do not want to automatically assume the thread should be unfeatured. As the class $featureThread property defaults to null we can use this so that essentially the property has three states. In this case null will mean \"no change\", true will mean we feature the thread and false will mean we unfeature it. In the case of unfeaturing, we actually just delete the featured thread entity by calling the delete() method. In both cases we use the fastUpdate() method again to update the cached value in the thread entity to represent the curent featured state. Before we finish the process of editing, we need to add code to our extended thread controller, and specifically extend the setupThreadEdit() method. The entire extended thread controller code will look like this: <?php namespace Demo\\Portal\\XF\\Pub\\Controller; class Thread extends XFCP_Thread { public function setupThreadEdit(\\XF\\Entity\\Thread $thread) { /** @var \\Demo\\Portal\\XF\\Service\\Thread\\Editor $editor */ $editor = parent::setupThreadEdit($thread); $canFeatureUnfeature = $thread->canFeatureUnfeature(); if ($canFeatureUnfeature) { $editor->setFeatureThread($this->filter('featured', 'bool')); } return $editor; } } This should be enough to be able to edit a thread, and set the status to featured (or unfeatured). If you try this out now, you should be able to see threads appearing and disappearing from your portal page accordingly. We need to extend another method in the thread controller to handle a situation whereby the thread status controls are shown on some thread reply forms, too. We just need to add the following code below the setupThreadEdit() method we added above: public function finalizeThreadReply(\\XF\\Service\\Thread\\Replier $replier) { parent::finalizeThreadReply($replier); $setOptions = $this->filter('_xfSet', 'array-bool'); if ($setOptions) { $thread = $replier->getThread(); if ($thread->canFeatureUnfeature() && isset($setOptions['featured'])) { $replier->setFeatureThread($this->filter('featured', 'bool')); } } } Note that we haven't actually returned anything in this method because it isn't expected to return anything. For the final step in manually featuring/unfeaturing a thread, we need to go back to the forum controller and slightly change our existing code so that if featuring isn't automatic, we can handle it manually, instead. This should be fairly straight forward. Head into your extended forum controller, and replace this: if ($forum->demo_portal_auto_feature) { $creator->setFeatureThread(true); } With this: if ($forum->demo_portal_auto_feature) { $creator->setFeatureThread(true); } else { $setOptions = $this->filter('_xfSet', 'array-bool'); if ($setOptions) { $thread = $creator->getThread(); if ($thread->canFeatureUnfeature() && isset($setOptions['featured'])) { $creator->setFeatureThread($this->filter('featured', 'bool')); } } } This is mostly the same as we already had, for example, if the forum has auto featuring enabled then we just set the thread as featured, otherwise, we check to see if the checkbox is available and as we've done for the other cases, set that to whatever the checkbox state was. We should now test creating 3 threads to ensure this is working as expected. The first in a forum with auto featuring enabled, to make sure that is still working, then in a forum without auto featuring enabled with the \"Featured\" checkbox checked, and again with it unchecked. Assuming that all works, let's move on. Improving the portal page \u00b6 So, the portal page looks reasonable, but we can do a bit better. First we should adjust our code so we only display X featured threads, and we should also add some page navigation. At this point, if you haven't already, it may be worth featuring some more threads so we can actually test the pagination! To start, we need to go back to our portal controller, and add some code to the top of the actionIndex() method: $page = $this->filterPage(); $perPage = 5; The first line here is a special helper method to get the current page number. The second is how many items we are going to load per page. This would usually come from an option, but we will hard code this to 5 for now. The next thing to do is to change this line: $finder = $repo->findFeaturedThreadsForPortalView(); To this: $finder = $repo->findFeaturedThreadsForPortalView() ->limitByPage($page, $perPage); This changes our query so that it will limit by the page / per page values we defined above. This will automatically calculate the correct limit ( $perPage ) and offset ( ($page - 1) * $perPage ) for the current page. Next, we need to pass a few more params into our view params so change: $viewParams = [ 'featuredThreads' => $finder->fetch() ]; To: $viewParams = [ 'featuredThreads' => $finder->fetch(), 'total' => $finder->total(), 'page' => $page, 'perPage' => $perPage ]; To use display our page navigation, we need to know the total number of entries, which we can get from the finder using the total() method, the current page number and how many we are displaying per page. If you head back on over to the portal, you will now see only 5 featured threads displayed. However, we need to now add the page navigation. So open up the demo_portal_view template and directly after the closing </xf:foreach> tag add the following: <xf:pagenav page=\"{$page}\" perpage=\"{$perPage}\" total=\"{$total}\" link=\"portal\" wrapperclass=\"block\" /> Reloading the portal page at this point, as long as you have more than 5 featured threads, you will now see page navigation at the bottom of the list of featured threads. Something else that may be useful to help improve how this page looks is to add a sidebar or, more accurately, a widget position that displays in the sidebar. Widget positions are added in the Admin CP under \"Development\". Go to the \"Widget positions\" page then click \"Add widget position\". Type a \"Position ID\" of demo_portal_view_sidebar , a \"Title\" of Demo portal view: Sidebar and an appropriate description. After making sure the position is enabled, and the correct add-on ID is selected, click \"Save\". To add this position to the template, simply add the following below the <xf:title> tag: <xf:widgetpos id=\"demo_portal_view_sidebar\" position=\"sidebar\" /> Of course we still won't see a sidebar until we add some widgets to it. Widgets themselves are not assigned to add-ons, so the widgets you create for this position, if you wish to ship some configured widgets by default, will need to be added to the Setup class. For the sake of simplicity, we'll just duplicate the widgets that are currently assigned to the forum_list_sidebar position (by default). So, we'll add those to a new installStep4() method into the Setup class: public function installStep4() { $this->createWidget('demo_portal_view_members_online', 'members_online', [ 'positions' => ['demo_portal_view_sidebar' => 10] ]); $this->createWidget('demo_portal_view_new_posts', 'new_posts', [ 'positions' => ['demo_portal_view_sidebar' => 20] ]); $this->createWidget('demo_portal_view_new_profile_posts', 'new_profile_posts', [ 'positions' => ['demo_portal_view_sidebar' => 30] ]); $this->createWidget('demo_portal_view_forum_statistics', 'forum_statistics', [ 'positions' => ['demo_portal_view_sidebar' => 40] ]); $this->createWidget('demo_portal_view_share_page', 'share_page', [ 'positions' => ['demo_portal_view_sidebar' => 50] ]); } And, of course, don't forget to run this setup step for yourself: Terminal $ php cmd.php xf-addon:install-step Demo/Portal 4 Implementing permissions & optimizations \u00b6 Right now, we are displaying all featured threads in the portal, regardless of whether the visitor has permission to view them or not. This isn't ideal; there may be use cases where you want to feature threads from certain restricted forums, and only have those visible by the users who can normally view that forum. To do this, we need to change our code so that we \"over-fetch\" the number of records that we need to display, filter out any unviewable results, and then slice the resulting collection to the actual amount we want to display per page. This is somewhat easier than it sounds. To start, go to the Portal controller, and change this line: ->limitByPage($page, $perPage); To: ->limit($perPage * 3); And below that, add: $featuredThreads = $finder->fetch() ->filter(function(\\Demo\\Portal\\Entity\\FeaturedThread $featuredThread) { return ($featuredThread->Thread->canView()); }) ->sliceToPage($page, $perPage); Finally change: 'featuredThreads' => $finder->fetch(), To: 'featuredThreads' => $featuredThreads, You may have spotted earlier in the demo_portal_view template that each post we render also specifies its attachments: 'attachments': $post.attach_count ? $post.Attachments : [], Right now, this is going to generate an additional query for each post. So, we should instead try to do a single query for all of the posts we are displaying and add them to the posts in advance. It probably sounds more complicated than it is. Just add the below code beneath the ->slice(0, $perPage, true); line. $threads = $featuredThreads->pluckNamed('Thread'); $posts = $threads->pluckNamed('FirstPost', 'first_post_id'); /** @var \\XF\\Repository\\Attachment $attachRepo */ $attachRepo = $this->repository('XF:Attachment'); $attachRepo->addAttachmentsToContent($posts, 'post'); We use the pluckNamed() method first to get a collection of threads, then again to get a collection of the posts (keyed by the post ID) from the threads. Once we have the posts, we can just pass them into a special method in the attachment repo, which performs a single query and \"hydrates\" the Attachments relation for each post. The final permission related thing to finish up is to create a new permission to control who can feature / unfeature threads manually. To do this, in the Admin CP under \"Development\" click \"Permission definitions\" and click \"Add permission\". The \"Permission group\" will be \"forum\", \"Permission ID\" will be demoPortalFeature , \"Title\" should be Can feature / unfeature threads , set \"Interface group\" to Forum moderator permissions and after choosing an appropriate display order and ensuring your add-on is selected, click \"Save\". To actually use this permission, we need to go back to our extended thread entity to modify the canFeatureUnfeature() method. Replace return true; with: return \\XF::visitor()->hasNodePermission($this->node_id, 'demoPortalFeature'); At this point, because permissions do not have any default values, if you go to edit any thread, you should find the \"Featured\" checkbox is missing. But, if you go and give yourself that permission, the checkbox will come back. So, that should demonstrate the permission is working as expected! Creating some options \u00b6 We currently display only 5 featured threads per page, but it would be nice to have the option to display more. Creating options is easy. Although not essential, we'll first create a new option group and then add a new option to that group. In the Admin CP under Setup then Options click the \"Add option group\" button. We'll just call the \"Group ID\" demoPortal and give it a title of \"Demo - Portal options\". Give it an appropriate \u0300\"Description\" and \"Display order\" and click \"Save\". Now click \"Add option\". Set the \"Option ID\" to demoPortalFeaturedPerPage , \"Title\" to Featured threads per page , edit format to Spin box , \"Data type\" to Positive integer and \"Default value\" to 10 . Click \"Save\". To implement that, go back to the portal controller and change: $perPage = 5; To: $perPage = $this->options()->demoPortalFeaturedPerPage; It's probably not going to hurt to add another option. Perhaps another useful option would be to be able to change the default sort order from xf_demo_portal_featured_thread.feartured_date to xf_thread.post_date . Go back to the \"Demo - Portal options\" group, and click \"Add option\". Set \"Option ID\" to demoPortalDefaultSort , \"Title\" to Default sort order and \"Edit format\" to Radio buttons . For the \"Format parameters\" set those as follows: plain featured_date={{ phrase('demo_portal_featured_date') }} post_date={{ phrase('demo_portal_post_date') }} Finally set \"Default value\" to featured_date and click \"Save\". We'll need to create the phrases used for the radio button labels, similar to how we created the phrases earlier for the template modification. Set the option value to \"Post date\". Strictly speaking, we could just update our repository method to use the new option directly, however, it might be worth looking at how custom finder methods work. Create a new file in the path src/addons/Demo/Portal/Finder/FeaturedThread.php with the contents: <?php namespace Demo\\Portal\\Finder; use XF\\Mvc\\Entity\\Finder; class FeaturedThread extends Finder { public function applyFeaturedOrder($direction = 'ASC') { $options = \\XF::options(); if ($options->demoPortalDefaultSort == 'featured_date') { $this->setDefaultOrder('featured_date', $direction); } else { $this->setDefaultOrder('Thread.post_date', $direction); } return $this; } } As you can see, all we've done here is create a fairly basic class which extends the XF Finder object and a simple method which looks at the value of our option, and applies the appropriate default order. We can now update our repository method to use this instead. Inside our featured thread repository, find: ->setDefaultOrder('featured_date', 'DESC') And change to: ->applyFeaturedOrder('DESC') Finally, it probably makes sense to update our portal view to display the appropriate time stamp - either the featured date or the post date, depending on our option value. In the demo_portal_view template change: <li><xf:date time=\"{$featuredThread.featured_date}\" /></li> To: <li> <xf:if is=\"$xf.options.demoPortalDefaultSort == 'featured_date'\"> <xf:date time=\"{$featuredThread.featured_date}\" /> <xf:else /> <xf:date time=\"{$thread.post_date}\" /> </xf:if> </li> Unfeaturing on visibility changes \u00b6 To approach this, we are going to need to modify the Thread entity again but this time we'll be doing that with the entity_post_save event. As we mentioned in The Entity life cycle , the _postSave() method is where actions can be performed as a result of an entity being inserted or updated. Initially we will be unfeaturing a thread when that thread is no longer visible. So, head back into the \"Add code event listeners\" page, and this time listen to the entity_post_save event. The event hint this time will be XF\\Entity\\Thread . For the execute callback, we will use the same class as we did before ( Demo\\Portal\\Listener ) but we will add a new method here named threadEntityPostSave . Let's add that method now so it's there when we save the listener: public static function threadEntityPostSave(\\XF\\Mvc\\Entity\\Entity $entity) { } Click \"Save\" to save the listener. The contents of this function are fairly simple, let's look at that: if ($entity->isUpdate()) { $visibilityChange = $entity->isStateChanged('discussion_state', 'visible'); if ($visibilityChange == 'leave') { $featuredThread = $entity->FeaturedThread; if ($featuredThread) { $featuredThread->delete(); $entity->fastUpdate('demo_portal_featured', false); } } } We've unfeatured threads before, but this time we want to make that conditional on the state of the thread. We can detect state changes using the isStateChanged method. This will return either enter or leave for the column name and value passed in. For example, if the discussion_state changes from visible to deleted then the method will return leave in the example above. Once we have detected that we are \"leaving\" the visible state, we can then just make sure we have a featured thread relation, and delete it, and update the cached value. This would only cover the situation whereby the thread is soft deleted or sent to the approval queue. We also need to cover the situation where the thread is permanently deleted. For this, we need another listener, this time for the entity_post_delete event. So, add that using the same callback class, and this time a method name of threadEntityPostDelete . Add the following code to the listener class: public static function threadEntityPostDelete(\\XF\\Mvc\\Entity\\Entity $entity) { $featuredThread = $entity->FeaturedThread; if ($featuredThread) { $featuredThread->delete(); } } After clicking \"Save\" to save the listener, it will be worth giving this a test. To test this, you might actually be better off keeping an eye on the xf_demo_portal_featured_thread table, as so far the code will already not display non-visible threads, but it's always important not to leave orphaned data. All being well, we're very nearly finished... Some final loose ends \u00b6 Speaking of orphaned data, we should tidy up the database whenever the add-on is uninstalled. We can do this in the Setup class we created earlier. We're going to create 3 new methods which correspond to our first 3 install steps: public function uninstallStep1() { $this->schemaManager()->alterTable('xf_forum', function(Alter $table) { $table->dropColumns('demo_portal_auto_feature'); }); } public function uninstallStep2() { $this->schemaManager()->alterTable('xf_thread', function(Alter $table) { $table->dropColumns('demo_portal_featured'); }); } public function uninstallStep3() { $this->schemaManager()->dropTable('xf_demo_portal_featured_thread'); } We don't have to create an uninstall step to remove the widgets as they will be removed automatically when the widget positions are removed. The same is true for any other data we created and associated to the add-on -- it will be removed automatically on uninstall. Building the add-on \u00b6 The final step for any add-on, is releasing it! This involves extracting the XML files from the database (which are shipped in the package and used for installation), calculating the hash of each file and adding it to our hashes.json and packaging only the relevant files up into a ZIP file. Thankfully, this can be done with a single CLI command! Just execute the command below: Terminal $ php cmd.php xf-addon:build-release Demo/Portal Performing add-on export. Exporting data for Demo - Portal to ../src/addons/Demo/Portal/_data. 10/10 [============================] 100% Written successfully. Building release ZIP. Writing release ZIP to ../src/addons/Demo/Portal/_releases. Release written successfully. So, with that, that concludes our demo add-on! If you would like to download the source code for this add-on, built using the very commands demonstrated above, click here: Demo-Portal-1.0.0 Alpha.zip .","title":"Let's build an add-on"},{"location":"lets-build-an-add-on/#lets-build-an-add-on","text":"For some people, getting stuck straight into a project is the best way to learn, and the aim is that in the following sections you will learn how to build an add-on, from scratch. Be prepared; this isn't a simple 'Hello world' type demo. This is actually a fairly full featured demo add-on which covers a number of concepts within XF2. The add-on we're going to build will allow users with the appropriate permission to \"feature\" a thread, and allow that thread to be displayed on a new page. We'll even set up a process which automatically features threads in specific forums. We will use a new route for this named portal and eventually set that as the index page route and set the \"Home\" tab to be selected when viewing that page.","title":"Let's build an add-on"},{"location":"lets-build-an-add-on/#create-the-add-on","text":"Throughout the add-on we will use the add-on ID of Demo/Portal . The first thing we need to do is create the add-on, for this we need to open a command prompt / shell / terminal window, change the directory to your XF installation root (where cmd.php is located) and run the following command, and enter the responses displayed below: Terminal $ php cmd.php xf-addon:create Enter an ID for this add-on: Demo/Portal Enter a title: Demo - Portal Enter a version ID: This integer will be used for internal variable comparisons. Each release of your addon should increase this number: 1000010 Version string set to: 1.0.0 Alpha Does this add-on supersede a XenForo 1 add-on? (y/n) n The addon.json file was successfully written out to /var/www/src/addons/Demo/Portal/addon.json Does your add-on need a Setup file? (y/n) y Does your Setup need to support running multiple steps? (y/n) y The Setup.php file was successfully written out to /var/www/src/addons/Demo/Portal/Setup.php The add-on has now been created, you will now find that you have a new directory in the src/addons directory, and you will find the add-on in the \"Installed add-ons\" list of the Admin CP. One of the files that has been created is the addon.json file, which currently looks like this: { \"legacy_addon_id\": \"\", \"title\": \"Demo - Portal\", \"description\": \"\", \"version_id\": 1000010, \"version_string\": \"1.0.0 Alpha\", \"dev\": \"\", \"dev_url\": \"\", \"faq_url\": \"\", \"support_url\": \"\", \"extra_urls\": [], \"require\": [], \"icon\": \"\" } Let's fill in some of these details: { \"legacy_addon_id\": \"\", \"title\": \"Demo - Portal\", \"description\": \"Add-on which will display featured threads on the forum home page.\", \"version_id\": 1000010, \"version_string\": \"1.0.0 Alpha\", \"dev\": \"You!\", \"dev_url\": \"\", \"faq_url\": \"\", \"support_url\": \"\", \"extra_urls\": [], \"require\": [], \"icon\": \"fa-home\" } We have now added a description , the developer's name ( dev ) and specified that we want to display an icon ( icon ). The icon can either be a path (relative to your add-on root) or the name of a Font Awesome icon as we've done here. As we're not superceding a XenForo 1 addon, we can disregard legacy_addon_id . For a full explaination of all of the properties in the addon.json file, refer to the Add-on structure section .","title":"Create the add-on"},{"location":"lets-build-an-add-on/#creating-the-setup-class","text":"Well, strictly speaking, the class has already been created and written out to Setup.php but right now it doesn't really do anything. We've basically got a skeleton class for it which looks like this: <?php namespace Demo\\Portal; use XF\\AddOn\\AbstractSetup; use XF\\AddOn\\StepRunnerInstallTrait; use XF\\AddOn\\StepRunnerUninstallTrait; use XF\\AddOn\\StepRunnerUpgradeTrait; class Setup extends AbstractSetup { use StepRunnerInstallTrait; use StepRunnerUpgradeTrait; use StepRunnerUninstallTrait; } We talked a little bit already about the Setup class. We're going to be breaking the install, upgrade and uninstall processes into separate steps. Let's start by importing some useful Schema classes. If you want to learn more about them, you can refer to the Managing the Schema section . Just after the last use declaration, add the following lines: use XF\\Db\\Schema\\Alter; use XF\\Db\\Schema\\Create; The StepRunner traits here are going to handle the process of cycling through all of the available steps, so all we have to do is start creating those steps. We'll begin by adding some code to create a new column in the xf_forum table: <?php namespace Demo\\Portal; use XF\\AddOn\\AbstractSetup; use XF\\AddOn\\StepRunnerInstallTrait; use XF\\AddOn\\StepRunnerUninstallTrait; use XF\\AddOn\\StepRunnerUpgradeTrait; use XF\\Db\\Schema\\Alter; use XF\\Db\\Schema\\Create; class Setup extends \\XF\\AddOn\\AbstractSetup { use StepRunnerInstallTrait; use StepRunnerUpgradeTrait; use StepRunnerUninstallTrait; public function installStep1() { $this->schemaManager()->alterTable('xf_forum', function(Alter $table) { $table->addColumn('demo_portal_auto_feature', 'tinyint')->setDefault(0); }); } } This column is being added to the xf_forum table so that we can set certain forums up to have threads automatically featured when they are created. The naming here is significant; columns added to core XF tables should always be prefixed. This serves two important purposes. The first being that there is less risk of conflicts happening with duplicate column names, in case XF or another add-on has reason to add that column in the future. The second being that it helps more easily identify which columns belong to which add-ons in case some issues arise in the future. While we're here, we might as well add another step to the installer. For brevity, we'll just display the new code, rather than the entire class. It should be placed directly below the installStep1() method: public function installStep2() { $this->schemaManager()->alterTable('xf_thread', function(Alter $table) { $table->addColumn('demo_portal_featured', 'tinyint')->setDefault(0); }); } This step, similar to the step above, will add a new column this time to the xf_thread table. We'll use this column as a cached value to quickly identify whether a thread is featured or not, without having to perform additional queries or a lookup against the xf_demo_portal_featured_thread table. Speaking of which, we should add that table now. This time directly below installStep2() : public function installStep3() { $this->schemaManager()->createTable('xf_demo_portal_featured_thread', function(Create $table) { $table->addColumn('thread_id', 'int'); $table->addColumn('featured_date', 'int'); $table->addPrimaryKey('thread_id'); }); } This step is going to create the new table. This table will be used to keep a log of all of the threads that have been featured, and when they were featured. The same principles apply here in terms of naming. A significant difference is that all tables should additionally be prefixed with xf_ . The reason for this is so that if a clean XF install is performed, we can remove all tables with the xf_ prefix, including those created by add-ons. One of the simplest things to forget when adding the code which adds various schema changes is to forget to apply the schema changes yourself. You can run install/upgrade steps using a CLI command. In this case, execute the following commands: Terminal $ php cmd.php xf-addon:install-step Demo/Portal 1 $ php cmd.php xf-addon:install-step Demo/Portal 2 $ php cmd.php xf-addon:install-step Demo/Portal 3","title":"Creating the Setup class"},{"location":"lets-build-an-add-on/#extending-the-forum-entity","text":"So far we've added a column to the xf_forum table, it's now time to extend the Forum entity structure. We need to do this so that the entity knows about our new column, and so that data can be read from and written to it via the entity. Note The following steps will require Development mode to be enabled. Remember to set Demo/Portal as the defaultAddOn value in config.php . The first step in this process is to create a \"Code event listener\". This can be done in the Admin CP under Development, click the \"Code event listeners\" link and click the \"Add code event listener\" button. We need to listen to the entity_structure event. We will use this to modify the default forum entity structure to add our newly created demo_portal_auto_feature column. In the \"Event hint\" field, we will enter the name of the class we're extending, e.g. XF\\Entity\\Forum . This will ensure our listener only executes on the forum entity. For the \"Execute callback\" class enter Demo\\Portal\\Listener and for the method enter forumEntityStructure . It's worth adding a description to explain what this listener is for, as this will help more easily identify the listener in the code event listener list. \"Extends the XF\\Entity\\Forum structure\" should be sufficient. Finally, make sure the \"Demo - Portal\" add-on is selected. Before we click \"Save\" we need to actually create the Listener class. So create a new file named Listener.php in src/addons/Demo/Portal . The contents of this file should be as follows, initially. We know the arguments this function requires from the documentation below the code event selector. <?php namespace Demo\\Portal; use XF\\Mvc\\Entity\\Entity; class Listener { public static function forumEntityStructure(\\XF\\Mvc\\Entity\\Manager $em, \\XF\\Mvc\\Entity\\Structure &$structure) { } } Notice the use declaration between the namespace and class name. We will be referencing the class declared here more than once, so declaring it here does allow us to reference it by its much shorter alias, in this case, Entity . This code won't actually do anything yet, but now is a good time to save the code event listener, so go ahead and click the \"Save\" button. Before we add some functional code to our new function, now might be a good time to see how the development output system works. Check out the new directories and files added to your add-on directory. Specifically there is a new JSON file in the _output/code_event_listeners directory, which should look like this: { \"event_id\": \"entity_structure\", \"execute_order\": 10, \"callback_class\": \"Demo\\\\Portal\\\\Listener\", \"callback_method\": \"forumEntityStructure\", \"active\": true, \"hint\": \"XF\\\\Entity\\\\Forum\", \"description\": \"Extends the XF\\\\Entity\\\\Forum structure\" } Whenever changes are made to the listener this file will update automatically. Right, let's add some more code. Back inside the Listener class, add the following to the forumEntityStructure function: $structure->columns['demo_portal_auto_feature'] = ['type' => Entity::BOOL, 'default' => false]; The forum entity is now aware of our new column, but there are a few more steps we should take care of first before we can begin to implement a way to actually start setting values on that column.","title":"Extending the forum entity"},{"location":"lets-build-an-add-on/#extending-the-thread-entity","text":"Again, as we have added a new column to the xf_thread table, we should make the Thread entity aware of that. This is very similar to what we did above. Head back to \"Add code event listener\" and listen to entity_structure again. The \"Event hint\" this time will be XF\\Entity\\Thread . We can use the same callback class as before ( Demo\\Portal\\Listener ) but this time the method will be named threadEntityStructure . Add a description similar to before. Before saving, we should add the code, directly below the forumEntityStructure function: public static function threadEntityStructure(\\XF\\Mvc\\Entity\\Manager $em, \\XF\\Mvc\\Entity\\Structure &$structure) { $structure->columns['demo_portal_featured'] = ['type' => Entity::BOOL, 'default' => false]; } This code is almost identical to what we added to the forum entity structure; really the only difference is the column name. But, we do need to add something else. We should create an entity relation so that, later on, should we need to access the featured thread entity (which we create in the next section) we can do so easily with a finder query. Below the $structure->columns line add: $structure->relations['FeaturedThread'] = [ 'entity' => 'Demo\\Portal:FeaturedThread', 'type' => Entity::TO_ONE, 'conditions' => 'thread_id', 'primary' => true ]; See Relations for more information about relations. Hit \"Save\" to save the listener.","title":"Extending the thread entity"},{"location":"lets-build-an-add-on/#creating-a-new-entity","text":"Above in installStep3() we created a new table. We are going to need to create an entity to interact with and create new records in this table. Because this is a brand new entity we don't need to do anything other than create the class inside src/addons/Demo/Portal/Entity/FeaturedThread.php , the skeleton for which will look like this: <?php namespace Demo\\Portal\\Entity; use XF\\Mvc\\Entity\\Structure; class FeaturedThread extends \\XF\\Mvc\\Entity\\Entity { } We need to use this to define the entity structure which represents our new xf_demo_portal_featured_thread table which we created earlier. The structure for this entity should look like this: public static function getStructure(Structure $structure) { $structure->table = 'xf_demo_portal_featured_thread'; $structure->shortName = 'Demo\\Portal:FeaturedThread'; $structure->primaryKey = 'thread_id'; $structure->columns = [ 'thread_id' => ['type' => self::UINT, 'required' => true], 'featured_date' => ['type' => self::UINT, 'default' => time()] ]; $structure->getters = []; $structure->relations = [ 'Thread' => [ 'entity' => 'XF:Thread', 'type' => self::TO_ONE, 'conditions' => 'thread_id', 'primary' => true ], ]; return $structure; } The list of columns is probably self explanatory based on the MySQL we wrote earlier to create the table. The relations includes a Thread relation, which will allow us to get the related thread entity record (and even the thread entity relations) from this entity.","title":"Creating a new entity"},{"location":"lets-build-an-add-on/#modifying-the-forum-edit-form","text":"We now need a way to modify the forum_edit template to add a new checkbox there which can ultimately write back to the new column we have now created. We'll do this by creating a template modification. This is done from the Admin CP under Appearance and then click Template modifications. Click the \"Admin\" tab followed by the \"Add template modification\" button. In the \"Template\" field, type \"forum_edit\". This is the template we need to modify. In the \"Modification key\" field, type \"demo_portal_forum_edit\". This is a unique key which identifies your template modification. The preferred convention for this is, at minimum, to mention the add-on followed by the template name being modified. The \"Description\" field should contain some text to help you identify the purpose of this modification when looking down the template modifications list. Something like \"Adds auto feature checkbox to the forum_edit template\" should suffice. When you entered the template name in the \"Template\" field, you may notice that a preview of the template contents was displayed. We need to use this to identify the preferred place for our checkbox. While viewing the forum edit page, you may notice there's a series of checkboxes and this looks like a reasonable location. The simplest way to place a checkbox in this section is to do a simple replacement on the top checkbox, so in the \"Find\" field add: <xf:option name=\"allow_posting\" And in the replace field: <xf:option name=\"demo_portal_auto_feature\" selected=\"$forum.demo_portal_auto_feature\" label=\"Automatically feature threads in this forum\" hint=\"If selected, any new threads posted in this forum will be automatically featured.\" /> $0 We don't need to worry about creating phrases, yet, we can pick those up later. Notice that the name attribute matches the name of the column we created earlier, and more significantly, the checked state of the checkbox row also reads the newly added column from the forum entity. When we save the template modification later, if the contents of the find field matches any part of the template then it will be replaced with the contents of the replace field. We are not actually removing what we have matched because the $0 in the replace field is re-inserting the matched text. We can use the \"Test\" button to check the replacement is working as expected. When the test button is clicked, an overlay with the modified template will appear. If all goes well, a green area should be highlighted with the new code we want to add. Note This is a fairly simple replacement. For more advanced matching, you can also use the \"Regular expression\" type. A detailed explanation of working with regular expressions is beyond the scope for this guide, but there are lots of resources online which may help. Finally, click save to save your template modification. If all has gone well, when you return to the template modifications list, you will see the log summary is displaying 1 / 0 / 0 therefore indicating that the modification successfully applied one time. An even better indicator that it has worked as planned is to go to the \"Nodes\" page listed under \"Forums\" in the Admin CP, and edit an existing forum. Our newly added template modification should now appear.","title":"Modifying the forum edit form"},{"location":"lets-build-an-add-on/#extending-the-forum-save-process","text":"We have our column, we have a UI to pass an input to that column, now we have to handle saving data to that column. We will do this by extending the Forum controller and extending a special method which is called when a node and its data are saved. First, let's create a \"Class extension\" which can be found under the \"Development\" entry in the Admin CP. Click \"Add class extension\". Here we need to specify a \"Base class name\" which is the name of the class we are extending, which in this case will be XF\\Admin\\Controller\\Forum . And we need to specify a \"Extension class name\" which is the class which will extend the base class. Enter this as Demo\\Portal\\XF\\Admin\\Controller\\Forum . We should create that class before clicking Save. Create a new file in src/addons/Demo/Portal/XF/Admin/Controller named Forum.php . This might seem like quite a long path, but we recommend a path like this for extended classes. It enables you to more easily identify the files that represent extended classes by virtue of the fact that they are in a directory of the same name as the extended \"add-on\" ID (in this case XF ). It also makes it clear exactly which class has been extended as the directory structure follows the same path as the default class. The contents of the file should, for now, look like this: <?php namespace Demo\\Portal\\XF\\Admin\\Controller; class Forum extends XFCP_Forum { } See Extending classes and Type hinting for more information. Click save to save the Class extension. Now we can add some code. The particular method we need to extend is a protected function called saveTypeData . When extending any existing method in any class, it is important to inspect the original method for a couple of reasons. The first being we want to make sure the arguments we use in the extended method, match that of the method we're extending. The second being that we need to know what this method actually does. For example, should the method be returning something of a particular type, or a certain object? This is certainly the case in most controller actions as we mentioned in the Modifying a controller action reply (properly) section. However, although this method is within a controller, it isn't actually a controller action itself. In fact, this particular method is a \"void\" method; it isn't expected to return anything. However, we should always ensure we call the parent method in our extended method so let's just add the new method itself, without the new code we need to add: protected function saveTypeData(FormAction $form, \\XF\\Entity\\Node $node, \\XF\\Entity\\AbstractNode $data) { parent::saveTypeData($form, $node, $data); } Warning This particular method's argument list assumes that we have a use declaration which aliases the full \\XF\\Mvc\\FormAction class to simply FormAction . You will therefore need to add that use declaration yourself. Add use XF\\Mvc\\FormAction; between the namespace and class lines. So, right now, we've extended that method, and our extension should be called, but right now it isn't doing anything other than calling its parent method. We now need to get the value of the input from the forum edit page and apply that to the $data entity (which in this case is the Forum entity). protected function saveTypeData(FormAction $form, \\XF\\Entity\\Node $node, \\XF\\Entity\\AbstractNode $data) { parent::saveTypeData($form, $node, $data); $form->setup(function() use ($data) { $data->demo_portal_auto_feature = $this->filter('demo_portal_auto_feature', 'bool'); }); } Using the FormAction object allows us to have various extension points into the process that runs during the course of a typical form submission. It isn't available for all controller actions. It is much more prevalent in the Admin CP, for example, which often follow a simple CRUD model (Create, Read, Update, Delete). A lot of other processes within XF happen inside a service object, which usually has specific extension points related to the service that is running. This particular usage of the FormAction object is somewhat different to what you would usually encounter. Saving a node is a somewhat different process, because as well as working with the node entity, you'll also be working with an associated type of node, e.g. a forum entity. We do have access to the form action object in this method, though, so we should use it. We've used it here to add a specific behaviour to the \"setup\" phase of the process. Namely, when the FormAction object's run() method is called, it will run through the various phases in a specific order. It doesn't matter which order those behaviors were added to the object in, they will still run in the order setup , validate , apply , complete . The code we added above lets us set our demo_portal_auto_feature column in the forum entity to whatever value is stored for the demo_portal_auto_feature input which we added to the forum edit page. It should now be possible to test that all of this works. Simply edit a forum of your choice and check the checkbox. You should be able to observe two things. First, when you go back into edit that forum, the checkbox should now be checked. Second, if you look in the xf_forum table for the forum you just edited, the demo_portal_auto_feature field should now be set to 1. Keep this value enabled for this forum, as we will eventually be automatically featuring threads from that forum.","title":"Extending the forum save process"},{"location":"lets-build-an-add-on/#setting-a-thread-to-be-featured-automatically","text":"We've added a new column to the forum entity which will allow us to automatically feature a thread when it is newly created in this forum, so now it's time to add the code which will do this. In XF2, we make heavy use of Service objects. These typically take a \"setup and go\" type approach; you setup your configuration and then call a method to complete the action. We use a service object to setup and perform the thread creation, so this is a perfect place to add the code we need. It all starts with another class extension, so go to the \"Add class extension\" page. This time, the base class will be XF\\Service\\Thread\\Creator and the extension class will be Demo\\Portal\\XF\\Service\\Thread\\Creator and, as usual, this new class will look something like the code below. Create that code in the path src/addons/Demo/Portal/XF/Service/Thread/Creator.php then click \"Save\" to create the extension. <?php namespace Demo\\Portal\\XF\\Service\\Thread; class Creator extends XFCP_Creator { } While we're here we will also create another extension. The base will be XF\\Pub\\Controller\\Forum and the extension class will be Demo\\Portal\\XF\\Pub\\Controller\\Forum . Creating the following code in the path src/addons/Demo/Portal/XF/Pub/Controller/Forum.php and click \"Save\": <?php namespace Demo\\Portal\\XF\\Pub\\Controller; class Forum extends XFCP_Forum { } We're ultimately going to extend the _save() method in our extended thread creator object so we can feature our thread after it has been created. To fit in with the \"setup and go\" approach, we will create a method which can be used to indicate whether the thread should be created as featured, or not. For this, we need two things; a class property to store the value (it defaults to null) and a public method to allow that property to be set. protected $featureThread; public function setFeatureThread($featureThread) { $this->featureThread = $featureThread; } Going back to our newly extended forum controller, we will now extend the method that sets up the creator service, and opt in to featuring if the forum entity has the necessary value set. Remember, before extending a method, we need to know what it is expected to return (if anything), and ensure we call the parent method. If the parent method does return something, then it is this which we should return after our code has finished. The setupThreadCreate() method in this case returns the set up creator service, so we will start this off as follows: protected function setupThreadCreate(\\XF\\Entity\\Forum $forum) { /** @var \\Demo\\Portal\\XF\\Service\\Thread\\Creator $creator */ $creator = parent::setupThreadCreate($forum); return $creator; } As expected, this doesn't actually do anything; the extended code is called, but all it does is return whatever was returned by the parent call. We should now modify the $creator to set up featuring if it applies to the forum we're currently working with. In between the $creator line and the return line, add: if ($forum->demo_portal_auto_feature) { $creator->setFeatureThread(true); } We can now add the _save() method to the extended creator class: protected function _save() { $thread = parent::_save(); return $thread; } To make sure this thread gets featured, in between the $thread line and the return line we just need to add: if ($this->featureThread && $thread->discussion_state == 'visible') { /** @var \\Demo\\Portal\\Entity\\FeaturedThread $featuredThread */ $featuredThread = $thread->getRelationOrDefault('FeaturedThread'); $featuredThread->save(); $thread->fastUpdate('demo_portal_featured', true); } Because we earlier created the FeaturedThread relation on the thread entity, we can actually use that relation for creation too! There is a method named getRelationOrDefault() which we use here. This will see if that relation actually returns an existing record, and if it doesn't, it will create the entity and set it up with any default values even the thread ID! This means we actually need to do little more than to get the default relation and save it to insert it into the database. Additionally, we should set the demo_portal_featured field to true. Because the thread entity has already been saved (when the original class saved the entity) we can use the fastUpdate() method to quickly update that field. We now need to try this all out and make sure it works. Go to the forum which you enabled the demo_portal_auto_feature option on earlier, and create a new thread. The only way to tell if it is working right now is to check the xf_demo_portal_featured_thread table and in doing that we should see a new record in there!","title":"Setting a thread to be featured automatically"},{"location":"lets-build-an-add-on/#create-the-portal-page","text":"There's still a considerable amount of work to do before we're finished, but now we have the ability to feature threads, it certainly would be nice if we could display them somewhere, so let's start creating our portal page. To do this we need a new public route. Go to the Admin CP and under \"Development\" click \"Routes\" then click \"Add route: Public\". We're going to keep this quite simple, for now. The route prefix is going to be \"portal\", the section context is going to be \"home\" and the controller is going to be \"Demo\\Portal:Portal\". We should now create that controller at the path src/addons/Demo/Portal/Pub/Controller/Portal.php with the following basic contents: <?php namespace Demo\\Portal\\Pub\\Controller; class Portal extends \\XF\\Pub\\Controller\\AbstractController { } We want our portal to be displayed to people when they visit the index.php?portal page. This URL doesn't have an \"action\" part - just the route prefix we just created. With that in mind, the code we need to add to display the portal page, should be in the actionIndex() method. The basic code we will need in that is: public function actionIndex() { $viewParams = []; return $this->view('Demo\\Portal:View', 'demo_portal_view', $viewParams); } Now, this won't exactly work, yet, because we haven't created the template, yet, but this is enough, for now, to at least demonstrate our route and controller are talking to each other. So visiting index.php?portal should at the very least display a 'Template error'. As was mentioned in the View reply section, the first argument is a view class, but we don't need to actually create this class. This class could be extended by other add-ons, if necessary, even if it doesn't exist. The second argument is the template, which we need to create now in the path src/addons/Demo/Portal/_output/templates/public/demo_portal_view.html . That template, for now, should simply contain the following: <xf:title>Portal</xf:title> If we now visit the portal page, the template error will be gone, and although we will still have a fairly blank looking page, it will at least now have the title \"Portal\". Now, it's time to start adding the code which will display a list of featured threads. The first step to this is to create a repository for some of our common base finder queries. So, create a new file in the path src/addons/Demo/Portal/Repository/FeaturedThread.php and add the following code: <?php namespace Demo\\Portal\\Repository; use XF\\Mvc\\Entity\\Finder; use XF\\Mvc\\Entity\\Repository; class FeaturedThread extends Repository { /** * @return Finder */ public function findFeaturedThreadsForPortalView() { $visitor = \\XF::visitor(); $finder = $this->finder('Demo\\Portal:FeaturedThread'); $finder ->setDefaultOrder('featured_date', 'DESC') ->with('Thread', true) ->with('Thread.User') ->with('Thread.Forum', true) ->with('Thread.Forum.Node.Permissions|' . $visitor->permission_combination_id) ->with('Thread.FirstPost', true) ->with('Thread.FirstPost.User') ->where('Thread.discussion_type', '<>', 'redirect') ->where('Thread.discussion_state', 'visible'); return $finder; } } What we're doing here is using the finder to query for all featured threads, in reverse featured_date order, and joining to the xf_thread table and from that table joining to the xf_user table for the thread creator, xf_forum table, the xf_post table and from there joining to the xf_user table again for the post creator. We've asserted that the thread, forum and first post must exist by specifying true for that argument so these will be performed as INNER JOIN whereas the user queries will be performed with a LEFT JOIN . It's possible that the author of some threads and posts may not exist (for example if they were posted automatically by the RSS feeder system, or posted by guests). We also have a special join here that fetches the current visitor's permissions along with the query. This will reduce the number of queries needed to render the portal page, as we will be doing a number of things (later) to only display featured threads to users who have permission to view them. This doesn't return the results of this query. This returns the finder object itself. This enables a clear extension point in case another add-on needs to extend our code, and also allows us to make further changes before fetching that data (such as for setting a limit/offset for pagination, or setting a different order). Let's now use that in our actionIndex() method inside our portal controller. Change the existing $viewParams = []; line to the following: /** @var \\Demo\\Portal\\Repository\\FeaturedThread $repo */ $repo = $this->repository('Demo\\Portal:FeaturedThread'); $finder = $repo->findFeaturedThreadsForPortalView(); $viewParams = [ 'featuredThreads' => $finder->fetch() ]; At this stage, we're not going to worry about modifying the base finder we've retrieved from the repo. Instead, let's start to actually see some results, and update the demo_portal_view template as follows (after the <xf:title> tags): <xf:if is=\"$featuredThreads is not empty\"> <xf:foreach loop=\"$featuredThreads\" value=\"$featuredThread\"> <xf:macro name=\"thread_block\" arg-thread=\"{$featuredThread.Thread}\" arg-post=\"{$featuredThread.Thread.FirstPost}\" arg-featuredThread=\"{$featuredThread}\" /> </xf:foreach> <xf:else /> <div class=\"blockMessage\">No threads have been featured yet.</div> </xf:if> <xf:macro name=\"thread_block\" arg-thread=\"!\" arg-post=\"!\" arg-featuredThread=\"!\"> <xf:css src=\"message.less\" /> <div class=\"block\"> <div class=\"block-container\" data-xf-init=\"lightbox\"> <h4 class=\"block-header\"><a href=\"{{ link('threads', $thread) }}\">{$thread.title}</a></h4> <div class=\"block-body\"> <xf:macro name=\"message\" arg-post=\"{$post}\" arg-thread=\"{$thread}\" arg-featuredThread=\"{$featuredThread}\" /> </div> <div class=\"block-footer\"> <a href=\"{{ link('threads', $thread) }}\">Continue reading...</a> </div> </div> </div> </xf:macro> <xf:macro name=\"message\" arg-post=\"!\" arg-thread=\"!\" arg-featuredThread=\"!\"> <div class=\"message message--post message--simple\"> <div class=\"message-inner\"> <div class=\"message-cell message-cell--main\"> <div class=\"message-content js-messageContent\"> <div class=\"message-attribution\"> <div class=\"contentRow contentRow--alignMiddle\"> <div class=\"contentRow-figure\"> <xf:avatar user=\"{$post.User}\" size=\"xxs\" defaultname=\"{$post.username}\" href=\"\" /> </div> <div class=\"contentRow-main contentRow-main--close\"> <ul class=\"listInline listInline--bullet u-muted\"> <li><xf:username user=\"{$thread.User}\" /></li> <li><xf:date time=\"{$featuredThread.featured_date}\" /></li> <li><a href=\"{{ link('forums', $thread.Forum) }}\">{$thread.Forum.title}</a></li> <li>{{ phrase('replies:') }} {$thread.reply_count|number}</li> </ul> </div> </div> </div> <div class=\"message-userContent lbContainer js-lbContainer\" data-lb-id=\"post-{$post.post_id}\" data-lb-caption-desc=\"{{ $post.User ? $post.User.username : $post.username }} &middot; {{ date_time($post.post_date) }}\" > <blockquote class=\"message-body\"> {{ bb_code($post.message, 'post', $post.User, { 'attachments': $post.attach_count ? $post.Attachments : [], 'viewAttachments': $thread.canViewAttachments() }) }} </blockquote> </div> </div> </div> </div> </div> </xf:macro> Now, admittedly, there's a lot going on here. Although it may look daunting, it's mostly just markup to display our featured threads in a reasonable style. There's a few things worth paying attention to, though. We start off the template with a condition that reads <xf:if is=\"$featuredThreads is not empty\"> . This is to chceck that the object returned by the finder actually contains featured thread records. If it doesn't, then we display an appropriate message. If we do have some records, we need to loop through each to display it. For each record, we call a macro . Macros are reusable portions of template code which are self documenting (in that you see which arguments are supported) and maintain their own scope which cannot be polluted with the arguments in the template calling the macro; meaning that macros are only aware of the arguments that are explicitly passed in and the global $xf param. The thread block macro displays the basic block for the featured thread, and then that calls another macro to display each message.","title":"Create the portal page"},{"location":"lets-build-an-add-on/#implementing-the-navigation-tab","text":"You may have spotted when setting up the route that we specified the section context as \"home\", and when you visited the portal page, the home tab was selected, or alternatively you may not have seen a home tab at all if a homePageUrl is not set in options. We want to use the default home tab rather than creating one ourselves and potentially having a duplicate tab. To do this, we should use a code event listener to change the URL to our portal URL. In the Admin CP under Development click \"Code event listeners\" and click \"Add code event listener\". Listen to the event home_page_url , callback class will be Demo\\Portal\\Listener again, and this time the method will be named homePageUrl . The code for this new method should be fairly simple: public static function homePageUrl(&$homePageUrl, \\XF\\Mvc\\Router $router) { $homePageUrl = $router->buildLink('canonical:portal'); } Finally, we should consider changing the index page route to our portal page. Go to Admin CP and under Setup click Options followed by \"Basic board information\". Change the \"Index page route\" option to portal/ . While you're in the Admin CP, let's see what happens now when you click on the Board title in the header. This should take you to your index page. All being well, that index page should now be your portal! In addition to that, the Home tab should be visible, and selected. As an optional step, you may choose to add some additional navigation entries under the home tab. But, for now, let's move on.","title":"Implementing the navigation tab"},{"location":"lets-build-an-add-on/#manually-featuring-or-unfeaturing-threads","text":"So, we can automatically feature new threads. What about manually featuring existing threads? Or manually featuring threads during creation where auto featuring is not supported? This will be a good way to get our current portal page looking a bit more busy. To achieve this, we will add a template modification to a specific macro, and this macro is actually used during thread reply, thread edit and when creating a thread. This will involve extending the editor service and making changes to the existing code which handled the auto featuring. First step then is a new template modification. So go to \"Add template modification\" (make sure the \"Public\" tab is selected on the \"Template modifications\" list). This time the template we are modifying is helper_thread_options , we'll use demo_portal_helper_thread_options as the key and you can write a reasonable description. We can actually do a \"Simple replacement\" here so leave that radio selected and in the \"Find\" field add: <xf:if is=\"$thread.canLockUnlock()\"> In the \"Replace\" field add: <xf:if is=\"($thread.isInsert() AND !$thread.Forum.demo_portal_auto_feature AND $thread.canFeatureUnfeature()) OR ($thread.isUpdate() && $thread.canFeatureUnfeature())\" > <xf:option label=\"{{ phrase('demo_portal_featured') }}\" name=\"featured\" value=\"1\" selected=\"{$thread.demo_portal_featured}\"> <xf:hint>{{ phrase('demo_portal_featured_hint') }}</xf:hint> <xf:afterhtml> <xf:hiddenval name=\"_xfSet[featured]\" value=\"1\" /> </xf:afterhtml> </xf:option> </xf:if> $0 That condition is a little on the lengthy side, but it allows us to show the featured checkbox under two specific conditions: a) If the thread has not yet been created and the auto feature option is disabled for the forum and there is permission to feature or b) it's an existing thread and there is permission to feature/unfeature. A quick \"Test\" should show this additional code will be inserted just above the existing \"Open\" checkbox within the existing <xf:checkboxrow> . If that all looks good, click \"Save\". We have had to use template code directly within the modification here, because including a template (like we did before) won't work within an existing input or row tag in this way. We'll also need to create the phrases now for the label and hint, because it won't be possible to detect those later. Under \"Appearance\" go to \"Phrases\" and click \"Add phrase\". Make sure your add-on is selected. The \"Title\" of the first phrase will be \"demo_portal_featured\" and the text will be simply \"Featured\". Click \"Save and Exit\". Click \"Add phrase\" again. The \"Title\" for the second phrase will be \"demo_portal_featured_hint\" and the text will be \"Featured threads will appear on the Portal page.\" Back to the template code we just added to the modification; you may have noticed something. We have called a method on the thread entity, canFeatureUnfeature() , and this method does not exist, yet. We are going to use this eventually to do a permission check that will control whether a user can manually feature a thread or not. To add this method, we need a new class extension for the XF\\Entity\\Thread entity. So, do that now similar to how we've done it before. The extended class will be Demo\\Portal\\XF\\Entity\\Thread so create that in the path src/addons/Demo/Portal/XF/Entity/Thread.php with the contents: <?php namespace Demo\\Portal\\XF\\Entity; class Thread extends XFCP_Thread { public function canFeatureUnfeature() { return true; } } Ok, so, we haven't exactly done much here of value, yet. All the canFeatureUnfeature() method does is return true right now. Later on, we will implement some proper permissions and add them here. To test this works so far, open one of the threads you previously featured, and select \"Edit thread\" from the tools menu. We should see the \"Set thread status\" checkbox row has the \"Featured\" checkbox we added, and it should be checked, indicating that this thread is indeed featured. We can now move on to changing the thread editor service to look for this value and feature or unfeature accordingly. We are going to need two new class extensions for this. Go back to the \"Add class extensions\" page. The first one will have a base class of XF\\Pub\\Controller\\Thread and extension class of Demo\\Portal\\XF\\Pub\\Controller\\Thread . The second one will have a base class of XF\\Service\\Thread\\Editor and an extension class of Demo\\Portal\\XF\\Service\\Thread\\Editor . The editor service is actually going to be very similar to the extended creator service we created earlier, so create that in the relevant location. Here is all of the code for the extended class: <?php namespace Demo\\Portal\\XF\\Service\\Thread; class Editor extends XFCP_Editor { protected $featureThread; public function setFeatureThread($featureThread) { $this->featureThread = $featureThread; } protected function _save() { $thread = parent::_save(); if ($this->featureThread !== null && $thread->discussion_state == 'visible') { /** @var \\Demo\\Portal\\Entity\\FeaturedThread $featuredThread */ $featuredThread = $thread->getRelationOrDefault('FeaturedThread', false); if ($this->featureThread) { if (!$featuredThread->exists()) { $featuredThread->save(); $thread->fastUpdate('demo_portal_featured', true); } } else { if ($featuredThread->exists()) { $featuredThread->delete(); $thread->fastUpdate('demo_portal_featured', false); } } } return $thread; } } This is a little bit more involved than the code in the creator service. For example, there may be situations where a thread is edited, and the user has no permission to edit the thread, and therefore we don't show the checkboxes. In these cases, we do not want to automatically assume the thread should be unfeatured. As the class $featureThread property defaults to null we can use this so that essentially the property has three states. In this case null will mean \"no change\", true will mean we feature the thread and false will mean we unfeature it. In the case of unfeaturing, we actually just delete the featured thread entity by calling the delete() method. In both cases we use the fastUpdate() method again to update the cached value in the thread entity to represent the curent featured state. Before we finish the process of editing, we need to add code to our extended thread controller, and specifically extend the setupThreadEdit() method. The entire extended thread controller code will look like this: <?php namespace Demo\\Portal\\XF\\Pub\\Controller; class Thread extends XFCP_Thread { public function setupThreadEdit(\\XF\\Entity\\Thread $thread) { /** @var \\Demo\\Portal\\XF\\Service\\Thread\\Editor $editor */ $editor = parent::setupThreadEdit($thread); $canFeatureUnfeature = $thread->canFeatureUnfeature(); if ($canFeatureUnfeature) { $editor->setFeatureThread($this->filter('featured', 'bool')); } return $editor; } } This should be enough to be able to edit a thread, and set the status to featured (or unfeatured). If you try this out now, you should be able to see threads appearing and disappearing from your portal page accordingly. We need to extend another method in the thread controller to handle a situation whereby the thread status controls are shown on some thread reply forms, too. We just need to add the following code below the setupThreadEdit() method we added above: public function finalizeThreadReply(\\XF\\Service\\Thread\\Replier $replier) { parent::finalizeThreadReply($replier); $setOptions = $this->filter('_xfSet', 'array-bool'); if ($setOptions) { $thread = $replier->getThread(); if ($thread->canFeatureUnfeature() && isset($setOptions['featured'])) { $replier->setFeatureThread($this->filter('featured', 'bool')); } } } Note that we haven't actually returned anything in this method because it isn't expected to return anything. For the final step in manually featuring/unfeaturing a thread, we need to go back to the forum controller and slightly change our existing code so that if featuring isn't automatic, we can handle it manually, instead. This should be fairly straight forward. Head into your extended forum controller, and replace this: if ($forum->demo_portal_auto_feature) { $creator->setFeatureThread(true); } With this: if ($forum->demo_portal_auto_feature) { $creator->setFeatureThread(true); } else { $setOptions = $this->filter('_xfSet', 'array-bool'); if ($setOptions) { $thread = $creator->getThread(); if ($thread->canFeatureUnfeature() && isset($setOptions['featured'])) { $creator->setFeatureThread($this->filter('featured', 'bool')); } } } This is mostly the same as we already had, for example, if the forum has auto featuring enabled then we just set the thread as featured, otherwise, we check to see if the checkbox is available and as we've done for the other cases, set that to whatever the checkbox state was. We should now test creating 3 threads to ensure this is working as expected. The first in a forum with auto featuring enabled, to make sure that is still working, then in a forum without auto featuring enabled with the \"Featured\" checkbox checked, and again with it unchecked. Assuming that all works, let's move on.","title":"Manually featuring (or unfeaturing) threads"},{"location":"lets-build-an-add-on/#improving-the-portal-page","text":"So, the portal page looks reasonable, but we can do a bit better. First we should adjust our code so we only display X featured threads, and we should also add some page navigation. At this point, if you haven't already, it may be worth featuring some more threads so we can actually test the pagination! To start, we need to go back to our portal controller, and add some code to the top of the actionIndex() method: $page = $this->filterPage(); $perPage = 5; The first line here is a special helper method to get the current page number. The second is how many items we are going to load per page. This would usually come from an option, but we will hard code this to 5 for now. The next thing to do is to change this line: $finder = $repo->findFeaturedThreadsForPortalView(); To this: $finder = $repo->findFeaturedThreadsForPortalView() ->limitByPage($page, $perPage); This changes our query so that it will limit by the page / per page values we defined above. This will automatically calculate the correct limit ( $perPage ) and offset ( ($page - 1) * $perPage ) for the current page. Next, we need to pass a few more params into our view params so change: $viewParams = [ 'featuredThreads' => $finder->fetch() ]; To: $viewParams = [ 'featuredThreads' => $finder->fetch(), 'total' => $finder->total(), 'page' => $page, 'perPage' => $perPage ]; To use display our page navigation, we need to know the total number of entries, which we can get from the finder using the total() method, the current page number and how many we are displaying per page. If you head back on over to the portal, you will now see only 5 featured threads displayed. However, we need to now add the page navigation. So open up the demo_portal_view template and directly after the closing </xf:foreach> tag add the following: <xf:pagenav page=\"{$page}\" perpage=\"{$perPage}\" total=\"{$total}\" link=\"portal\" wrapperclass=\"block\" /> Reloading the portal page at this point, as long as you have more than 5 featured threads, you will now see page navigation at the bottom of the list of featured threads. Something else that may be useful to help improve how this page looks is to add a sidebar or, more accurately, a widget position that displays in the sidebar. Widget positions are added in the Admin CP under \"Development\". Go to the \"Widget positions\" page then click \"Add widget position\". Type a \"Position ID\" of demo_portal_view_sidebar , a \"Title\" of Demo portal view: Sidebar and an appropriate description. After making sure the position is enabled, and the correct add-on ID is selected, click \"Save\". To add this position to the template, simply add the following below the <xf:title> tag: <xf:widgetpos id=\"demo_portal_view_sidebar\" position=\"sidebar\" /> Of course we still won't see a sidebar until we add some widgets to it. Widgets themselves are not assigned to add-ons, so the widgets you create for this position, if you wish to ship some configured widgets by default, will need to be added to the Setup class. For the sake of simplicity, we'll just duplicate the widgets that are currently assigned to the forum_list_sidebar position (by default). So, we'll add those to a new installStep4() method into the Setup class: public function installStep4() { $this->createWidget('demo_portal_view_members_online', 'members_online', [ 'positions' => ['demo_portal_view_sidebar' => 10] ]); $this->createWidget('demo_portal_view_new_posts', 'new_posts', [ 'positions' => ['demo_portal_view_sidebar' => 20] ]); $this->createWidget('demo_portal_view_new_profile_posts', 'new_profile_posts', [ 'positions' => ['demo_portal_view_sidebar' => 30] ]); $this->createWidget('demo_portal_view_forum_statistics', 'forum_statistics', [ 'positions' => ['demo_portal_view_sidebar' => 40] ]); $this->createWidget('demo_portal_view_share_page', 'share_page', [ 'positions' => ['demo_portal_view_sidebar' => 50] ]); } And, of course, don't forget to run this setup step for yourself: Terminal $ php cmd.php xf-addon:install-step Demo/Portal 4","title":"Improving the portal page"},{"location":"lets-build-an-add-on/#implementing-permissions-optimizations","text":"Right now, we are displaying all featured threads in the portal, regardless of whether the visitor has permission to view them or not. This isn't ideal; there may be use cases where you want to feature threads from certain restricted forums, and only have those visible by the users who can normally view that forum. To do this, we need to change our code so that we \"over-fetch\" the number of records that we need to display, filter out any unviewable results, and then slice the resulting collection to the actual amount we want to display per page. This is somewhat easier than it sounds. To start, go to the Portal controller, and change this line: ->limitByPage($page, $perPage); To: ->limit($perPage * 3); And below that, add: $featuredThreads = $finder->fetch() ->filter(function(\\Demo\\Portal\\Entity\\FeaturedThread $featuredThread) { return ($featuredThread->Thread->canView()); }) ->sliceToPage($page, $perPage); Finally change: 'featuredThreads' => $finder->fetch(), To: 'featuredThreads' => $featuredThreads, You may have spotted earlier in the demo_portal_view template that each post we render also specifies its attachments: 'attachments': $post.attach_count ? $post.Attachments : [], Right now, this is going to generate an additional query for each post. So, we should instead try to do a single query for all of the posts we are displaying and add them to the posts in advance. It probably sounds more complicated than it is. Just add the below code beneath the ->slice(0, $perPage, true); line. $threads = $featuredThreads->pluckNamed('Thread'); $posts = $threads->pluckNamed('FirstPost', 'first_post_id'); /** @var \\XF\\Repository\\Attachment $attachRepo */ $attachRepo = $this->repository('XF:Attachment'); $attachRepo->addAttachmentsToContent($posts, 'post'); We use the pluckNamed() method first to get a collection of threads, then again to get a collection of the posts (keyed by the post ID) from the threads. Once we have the posts, we can just pass them into a special method in the attachment repo, which performs a single query and \"hydrates\" the Attachments relation for each post. The final permission related thing to finish up is to create a new permission to control who can feature / unfeature threads manually. To do this, in the Admin CP under \"Development\" click \"Permission definitions\" and click \"Add permission\". The \"Permission group\" will be \"forum\", \"Permission ID\" will be demoPortalFeature , \"Title\" should be Can feature / unfeature threads , set \"Interface group\" to Forum moderator permissions and after choosing an appropriate display order and ensuring your add-on is selected, click \"Save\". To actually use this permission, we need to go back to our extended thread entity to modify the canFeatureUnfeature() method. Replace return true; with: return \\XF::visitor()->hasNodePermission($this->node_id, 'demoPortalFeature'); At this point, because permissions do not have any default values, if you go to edit any thread, you should find the \"Featured\" checkbox is missing. But, if you go and give yourself that permission, the checkbox will come back. So, that should demonstrate the permission is working as expected!","title":"Implementing permissions &amp; optimizations"},{"location":"lets-build-an-add-on/#creating-some-options","text":"We currently display only 5 featured threads per page, but it would be nice to have the option to display more. Creating options is easy. Although not essential, we'll first create a new option group and then add a new option to that group. In the Admin CP under Setup then Options click the \"Add option group\" button. We'll just call the \"Group ID\" demoPortal and give it a title of \"Demo - Portal options\". Give it an appropriate \u0300\"Description\" and \"Display order\" and click \"Save\". Now click \"Add option\". Set the \"Option ID\" to demoPortalFeaturedPerPage , \"Title\" to Featured threads per page , edit format to Spin box , \"Data type\" to Positive integer and \"Default value\" to 10 . Click \"Save\". To implement that, go back to the portal controller and change: $perPage = 5; To: $perPage = $this->options()->demoPortalFeaturedPerPage; It's probably not going to hurt to add another option. Perhaps another useful option would be to be able to change the default sort order from xf_demo_portal_featured_thread.feartured_date to xf_thread.post_date . Go back to the \"Demo - Portal options\" group, and click \"Add option\". Set \"Option ID\" to demoPortalDefaultSort , \"Title\" to Default sort order and \"Edit format\" to Radio buttons . For the \"Format parameters\" set those as follows: plain featured_date={{ phrase('demo_portal_featured_date') }} post_date={{ phrase('demo_portal_post_date') }} Finally set \"Default value\" to featured_date and click \"Save\". We'll need to create the phrases used for the radio button labels, similar to how we created the phrases earlier for the template modification. Set the option value to \"Post date\". Strictly speaking, we could just update our repository method to use the new option directly, however, it might be worth looking at how custom finder methods work. Create a new file in the path src/addons/Demo/Portal/Finder/FeaturedThread.php with the contents: <?php namespace Demo\\Portal\\Finder; use XF\\Mvc\\Entity\\Finder; class FeaturedThread extends Finder { public function applyFeaturedOrder($direction = 'ASC') { $options = \\XF::options(); if ($options->demoPortalDefaultSort == 'featured_date') { $this->setDefaultOrder('featured_date', $direction); } else { $this->setDefaultOrder('Thread.post_date', $direction); } return $this; } } As you can see, all we've done here is create a fairly basic class which extends the XF Finder object and a simple method which looks at the value of our option, and applies the appropriate default order. We can now update our repository method to use this instead. Inside our featured thread repository, find: ->setDefaultOrder('featured_date', 'DESC') And change to: ->applyFeaturedOrder('DESC') Finally, it probably makes sense to update our portal view to display the appropriate time stamp - either the featured date or the post date, depending on our option value. In the demo_portal_view template change: <li><xf:date time=\"{$featuredThread.featured_date}\" /></li> To: <li> <xf:if is=\"$xf.options.demoPortalDefaultSort == 'featured_date'\"> <xf:date time=\"{$featuredThread.featured_date}\" /> <xf:else /> <xf:date time=\"{$thread.post_date}\" /> </xf:if> </li>","title":"Creating some options"},{"location":"lets-build-an-add-on/#unfeaturing-on-visibility-changes","text":"To approach this, we are going to need to modify the Thread entity again but this time we'll be doing that with the entity_post_save event. As we mentioned in The Entity life cycle , the _postSave() method is where actions can be performed as a result of an entity being inserted or updated. Initially we will be unfeaturing a thread when that thread is no longer visible. So, head back into the \"Add code event listeners\" page, and this time listen to the entity_post_save event. The event hint this time will be XF\\Entity\\Thread . For the execute callback, we will use the same class as we did before ( Demo\\Portal\\Listener ) but we will add a new method here named threadEntityPostSave . Let's add that method now so it's there when we save the listener: public static function threadEntityPostSave(\\XF\\Mvc\\Entity\\Entity $entity) { } Click \"Save\" to save the listener. The contents of this function are fairly simple, let's look at that: if ($entity->isUpdate()) { $visibilityChange = $entity->isStateChanged('discussion_state', 'visible'); if ($visibilityChange == 'leave') { $featuredThread = $entity->FeaturedThread; if ($featuredThread) { $featuredThread->delete(); $entity->fastUpdate('demo_portal_featured', false); } } } We've unfeatured threads before, but this time we want to make that conditional on the state of the thread. We can detect state changes using the isStateChanged method. This will return either enter or leave for the column name and value passed in. For example, if the discussion_state changes from visible to deleted then the method will return leave in the example above. Once we have detected that we are \"leaving\" the visible state, we can then just make sure we have a featured thread relation, and delete it, and update the cached value. This would only cover the situation whereby the thread is soft deleted or sent to the approval queue. We also need to cover the situation where the thread is permanently deleted. For this, we need another listener, this time for the entity_post_delete event. So, add that using the same callback class, and this time a method name of threadEntityPostDelete . Add the following code to the listener class: public static function threadEntityPostDelete(\\XF\\Mvc\\Entity\\Entity $entity) { $featuredThread = $entity->FeaturedThread; if ($featuredThread) { $featuredThread->delete(); } } After clicking \"Save\" to save the listener, it will be worth giving this a test. To test this, you might actually be better off keeping an eye on the xf_demo_portal_featured_thread table, as so far the code will already not display non-visible threads, but it's always important not to leave orphaned data. All being well, we're very nearly finished...","title":"Unfeaturing on visibility changes"},{"location":"lets-build-an-add-on/#some-final-loose-ends","text":"Speaking of orphaned data, we should tidy up the database whenever the add-on is uninstalled. We can do this in the Setup class we created earlier. We're going to create 3 new methods which correspond to our first 3 install steps: public function uninstallStep1() { $this->schemaManager()->alterTable('xf_forum', function(Alter $table) { $table->dropColumns('demo_portal_auto_feature'); }); } public function uninstallStep2() { $this->schemaManager()->alterTable('xf_thread', function(Alter $table) { $table->dropColumns('demo_portal_featured'); }); } public function uninstallStep3() { $this->schemaManager()->dropTable('xf_demo_portal_featured_thread'); } We don't have to create an uninstall step to remove the widgets as they will be removed automatically when the widget positions are removed. The same is true for any other data we created and associated to the add-on -- it will be removed automatically on uninstall.","title":"Some final loose ends"},{"location":"lets-build-an-add-on/#building-the-add-on","text":"The final step for any add-on, is releasing it! This involves extracting the XML files from the database (which are shipped in the package and used for installation), calculating the hash of each file and adding it to our hashes.json and packaging only the relevant files up into a ZIP file. Thankfully, this can be done with a single CLI command! Just execute the command below: Terminal $ php cmd.php xf-addon:build-release Demo/Portal Performing add-on export. Exporting data for Demo - Portal to ../src/addons/Demo/Portal/_data. 10/10 [============================] 100% Written successfully. Building release ZIP. Writing release ZIP to ../src/addons/Demo/Portal/_releases. Release written successfully. So, with that, that concludes our demo add-on! If you would like to download the source code for this add-on, built using the very commands demonstrated above, click here: Demo-Portal-1.0.0 Alpha.zip .","title":"Building the add-on"},{"location":"managing-the-schema/","text":"Managing the schema \u00b6 We've taken a look at some of the new approaches available for interacting with data. Of course there are specific circumstances where interacting with the database directly may be necessary. The database adapter \u00b6 The default database adapter in XF2 is based on MySQL and PHP's mysqli extension. The configured database adapter is accessible in any XF class using the following: $db = \\XF::db(); The adapter has a number of methods available which will execute a SQL query and then format the results into an array. For example, to access a single user record: $db = \\XF::db(); $user = $db->fetchRow('SELECT * FROM xf_user WHERE user_id = ?', 1); The $user variable will now contain an array of all values from the first row found in the query result. To get a single value from that query, such as the username, you can do the following: $username = $user['username']; Warning Database queries written directly and passed to the database adapter are not automatically \"safe\". They pose a risk of a SQL injection vulnerability if user input is not sanitised and not passed into the query without being prepared. The way to do that properly is using prepared statements, like in the example above. Parameters are represented in the query itself using the ? placeholder. These placeholders are then replaced with the values in the next argument after they have been appropriately escaped. If you have the need to use more than a single parameter, that should be passed into the fetch type method as an array. Should the need arise, you can escape or quote values directly using $db->quote($value) . You can find more information about prepared statements here . It's also possible to query for a single value from a record. For example: $db = \\XF::db(); $username = $db->fetchOne('SELECT username FROM xf_user WHERE user_id = ?', 1); If you have a query that needs to return multiple rows, you can use either fetchAll : $db = \\XF::db(); $users = $db->fetchAll('SELECT * FROM xf_user LIMIT 10'); Or fetchAllKeyed : $db = \\XF::db(); $users = $db->fetchAllKeyed('SELECT * FROM xf_user LIMIT 10', 'user_id'); Both of these methods will return an array of arrays that represent each user record. The difference between the fetchAll and fetchAllKeyed methods is that the returned array will be keyed differently. With fetchAll the array will be keyed with numerically consecutive integers. With fetchAllKeyed the array will be keyed by the name of the field named in the second argument. Note If you are using fetchAllKeyed note that the second argument is the field to key the array by, but the third argument is where you pass in the param values to match the ? placeholders. There are some other fetch type methods available including fetchAllColumn for grabbing an array of a specific column's values from all returned rows: $db = \\XF::db(); $usernames = $db->fetchAllColumn('SELECT username FROM xf_user LIMIT 10'); The above example would return an array of 10 usernames found from the resulting query. Finally, you may not actually want or need any data returned, in which case you can just do a plain query: $db = \\XF::db(); $db->query('DELETE FROM xf_user WHERE user_id = ?', 1); Schema management \u00b6 XF2 includes an all new way to manage the database schema which takes an object oriented approach to performing certain table operations. Let's first look at a traditional alter, using the database adapter like we have above: $db = \\XF::db(); $db->query(\" ALTER TABLE xf_some_existing_table ADD COLUMN new_column INT(10) UNSIGNED NOT NULL DEFAULT 0, MODIFY COLUMN some_existing_column varchar(250) NOT NULL DEFAULT '' \"); And also let's look at a typical create table query: $db = \\XF::db(); $sm = $db->getSchemaManager(); $defaultTableConfig = $sm->getTableConfigSql(); $db->query(\" CREATE TABLE xf_some_table ( some_id INT(10) UNSIGNED NOT NULL AUTO_INCREMENT, some_name VARCHAR(50) NOT NULL, PRIMARY KEY (user_id) ) {$defaultTableConfig} \"); The alternative and preferred approach in XF2 uses the new SchemaManager object. Let's look at both of these queries, as performed by the schema manager, starting with the alter: $sm = \\XF::db()->getSchemaManager(); $sm->alterTable('xf_some_existing_table', function(\\XF\\Db\\Schema\\Alter $table) { $table->addColumn('new_column', 'int')->setDefault(0); $table->changeColumn('some_existing_column')->length(250); }); And the table creation: $sm = \\XF::db()->getSchemaManager(); $sm->createTable('xf_some_table', function(\\XF\\Db\\Schema\\Create $table) { $table->addColumn('some_id', 'int')->autoIncrement(); $table->addColumn('some_name', 'varchar', 50); }); Warning When you alter the existing XenForo tables, or create your own tables, you MUST specify a default value otherwise you will encounter problems when querying the table. Both of these examples produce the exact same query as their more direct counterparts above. Though you might notice that some things are (deliberately) missing. For example, none of the examples specify a length for the int fields. This is simply because by omitting that, MySQL will provide it with a default, which is 10 for unsigned integers. Speaking of which, we also don't specify that the some_id column is unsigned. Using unsigned integers within XF is by far the most common use case, so it is automatically added. If you genuinely need the ability to support negative integers, you can reverse that with the ->unsigned(false) method. Another omission is the lack of defining NOT NULL for everything. Again, this is applied automatically, but you can reverse that with ->nullable(true) . It may not be clear from the alter example, but when changing existing fields, the existing field definition is automatically retained. This means that, rather than having to specify the full column definition, including all of the bits that haven't actually changed, you can just specify the parts you want to change. There is some other automatic inference that happens with regards to primary keys. You can explicitly define the primary key (or any other type of key) if you wish, but often auto incremented fields will usually be your primary key for the table. So in the create table example, the some_id field is automatically assigned as the primary key for that table. Finally, for the create table approach, we can automatically add the correct table config for the storage engine specified (which defaults to InnoDB but can be changed easily to other engine types).","title":"Managing the schema"},{"location":"managing-the-schema/#managing-the-schema","text":"We've taken a look at some of the new approaches available for interacting with data. Of course there are specific circumstances where interacting with the database directly may be necessary.","title":"Managing the schema"},{"location":"managing-the-schema/#the-database-adapter","text":"The default database adapter in XF2 is based on MySQL and PHP's mysqli extension. The configured database adapter is accessible in any XF class using the following: $db = \\XF::db(); The adapter has a number of methods available which will execute a SQL query and then format the results into an array. For example, to access a single user record: $db = \\XF::db(); $user = $db->fetchRow('SELECT * FROM xf_user WHERE user_id = ?', 1); The $user variable will now contain an array of all values from the first row found in the query result. To get a single value from that query, such as the username, you can do the following: $username = $user['username']; Warning Database queries written directly and passed to the database adapter are not automatically \"safe\". They pose a risk of a SQL injection vulnerability if user input is not sanitised and not passed into the query without being prepared. The way to do that properly is using prepared statements, like in the example above. Parameters are represented in the query itself using the ? placeholder. These placeholders are then replaced with the values in the next argument after they have been appropriately escaped. If you have the need to use more than a single parameter, that should be passed into the fetch type method as an array. Should the need arise, you can escape or quote values directly using $db->quote($value) . You can find more information about prepared statements here . It's also possible to query for a single value from a record. For example: $db = \\XF::db(); $username = $db->fetchOne('SELECT username FROM xf_user WHERE user_id = ?', 1); If you have a query that needs to return multiple rows, you can use either fetchAll : $db = \\XF::db(); $users = $db->fetchAll('SELECT * FROM xf_user LIMIT 10'); Or fetchAllKeyed : $db = \\XF::db(); $users = $db->fetchAllKeyed('SELECT * FROM xf_user LIMIT 10', 'user_id'); Both of these methods will return an array of arrays that represent each user record. The difference between the fetchAll and fetchAllKeyed methods is that the returned array will be keyed differently. With fetchAll the array will be keyed with numerically consecutive integers. With fetchAllKeyed the array will be keyed by the name of the field named in the second argument. Note If you are using fetchAllKeyed note that the second argument is the field to key the array by, but the third argument is where you pass in the param values to match the ? placeholders. There are some other fetch type methods available including fetchAllColumn for grabbing an array of a specific column's values from all returned rows: $db = \\XF::db(); $usernames = $db->fetchAllColumn('SELECT username FROM xf_user LIMIT 10'); The above example would return an array of 10 usernames found from the resulting query. Finally, you may not actually want or need any data returned, in which case you can just do a plain query: $db = \\XF::db(); $db->query('DELETE FROM xf_user WHERE user_id = ?', 1);","title":"The database adapter"},{"location":"managing-the-schema/#schema-management","text":"XF2 includes an all new way to manage the database schema which takes an object oriented approach to performing certain table operations. Let's first look at a traditional alter, using the database adapter like we have above: $db = \\XF::db(); $db->query(\" ALTER TABLE xf_some_existing_table ADD COLUMN new_column INT(10) UNSIGNED NOT NULL DEFAULT 0, MODIFY COLUMN some_existing_column varchar(250) NOT NULL DEFAULT '' \"); And also let's look at a typical create table query: $db = \\XF::db(); $sm = $db->getSchemaManager(); $defaultTableConfig = $sm->getTableConfigSql(); $db->query(\" CREATE TABLE xf_some_table ( some_id INT(10) UNSIGNED NOT NULL AUTO_INCREMENT, some_name VARCHAR(50) NOT NULL, PRIMARY KEY (user_id) ) {$defaultTableConfig} \"); The alternative and preferred approach in XF2 uses the new SchemaManager object. Let's look at both of these queries, as performed by the schema manager, starting with the alter: $sm = \\XF::db()->getSchemaManager(); $sm->alterTable('xf_some_existing_table', function(\\XF\\Db\\Schema\\Alter $table) { $table->addColumn('new_column', 'int')->setDefault(0); $table->changeColumn('some_existing_column')->length(250); }); And the table creation: $sm = \\XF::db()->getSchemaManager(); $sm->createTable('xf_some_table', function(\\XF\\Db\\Schema\\Create $table) { $table->addColumn('some_id', 'int')->autoIncrement(); $table->addColumn('some_name', 'varchar', 50); }); Warning When you alter the existing XenForo tables, or create your own tables, you MUST specify a default value otherwise you will encounter problems when querying the table. Both of these examples produce the exact same query as their more direct counterparts above. Though you might notice that some things are (deliberately) missing. For example, none of the examples specify a length for the int fields. This is simply because by omitting that, MySQL will provide it with a default, which is 10 for unsigned integers. Speaking of which, we also don't specify that the some_id column is unsigned. Using unsigned integers within XF is by far the most common use case, so it is automatically added. If you genuinely need the ability to support negative integers, you can reverse that with the ->unsigned(false) method. Another omission is the lack of defining NOT NULL for everything. Again, this is applied automatically, but you can reverse that with ->nullable(true) . It may not be clear from the alter example, but when changing existing fields, the existing field definition is automatically retained. This means that, rather than having to specify the full column definition, including all of the bits that haven't actually changed, you can just specify the parts you want to change. There is some other automatic inference that happens with regards to primary keys. You can explicitly define the primary key (or any other type of key) if you wish, but often auto incremented fields will usually be your primary key for the table. So in the create table example, the some_id field is automatically assigned as the primary key for that table. Finally, for the create table approach, we can automatically add the correct table config for the storage engine specified (which defaults to InnoDB but can be changed easily to other engine types).","title":"Schema management"},{"location":"rest-api/","text":"REST API \u00b6 In XenForo 2.1, a REST API was added. This allows you to programmatically interact with many areas of a XenForo installation. Accessing the API requires generating a key via the admin control panel. There is no unauthenticated access to the API and users cannot generate their own keys to access the API at this time. The API for a specific XenForo installation is accessible at <XenForo base URL>/api/ . All endpoints are prefixed by this URL. For example, if XenForo is installed at https://example.com/community/ , then the API URLs will start with https://example.com/community/api/ . In this example, accessing a list of threads would be done via https://example.com/community/api/threads/ . The API is enabled by default. If necessary, all API access can quickly be disabled by adding the following to src/config.php : $config['enableApi'] = false; API keys \u00b6 API keys are created via the admin control panel by going to Setup > API keys . As generating API keys can allow access to highly privileged data, only super administrators may access this system. All super admins will receive an email when an API key is generated to ensure that the request is valid. When a key is created, a random string will be generated and this will be used to authenticate yourself with the API. It is important that this key is kept secret. If you believe an API key has been compromised, you should immediately regenerate the key and update any code using the old key. Key types \u00b6 All API access is done in the context of a specific user. For example, if I access the API as \"John\" and I make a request that posts a thread, that thread will have been created by \"John\". In most cases, the API will also respect permissions specified for this user, so they can't access data they wouldn't see when browsing the forum normally. To allow control over this, there are three types of API keys: Guest key - this key always accesses the API as a guest user. These requests will always respect the guest permissions. For example, if guests cannot reply to threads, an API request to reply to a thread would generate a no permission error. User key - this key always accesses the API as a specified user and always respects that user's permissions, similar to a guest key. Super user key - this key can access the API as any user by passing an additional value into it. Optionally, this key can bypass the requesting user's permissions, allowing them to take actions or view content they would not normally have access to. Super user keys are very useful for integrations with other systems or applications. For example, you may integrate with a third-party CMS that creates a thread whenever you post a new article. This type of key would allow you to create a thread with a different user depending on the article author or in a forum that users normally can't post in. Key scopes \u00b6 To help limit the amount of damage a compromised key can inflict, each key can control the API scopes that it can access. Scopes limit access to areas of the API, independent of the requesting user's permissions. Each endpoint in the API will be covered by one of more scopes. If the API has not been granted any of those scopes, the request will fail. For security, we recommend you only grant a key the scopes that you require. If you require additional scopes at a later time, they can be added when needed. Accessing the API \u00b6 Once you know the URL to access the API and have a key, you can begin to make requests to it. All API responses will be returned in JSON format, except in cases where a binary file is specifically requested (such as when downloading an attachment). Errors will always return a response code in the 400 range. Successful requests will return a 200 code. While not commonly used, redirects will return a 300-range code. Requests bodies must be sent using the application/x-www-form-urlencoded encoding or, if a file is being uploaded, the multipart/form-data encoding. Parameters may also be passed via the query string. All request data must use the UTF-8 character set. Requests must pass the API key to use via the XF-Api-Key header. This must be present in all requests. If the API key selected is a super user key, you may pass the user ID of the context user via the XF-Api-User header. If no user ID is passed, the context will default to a guest. If the request is made with a super user key and you wish to bypass the context user's permissions, this may be done on a per-request basis by setting the api_bypass_permissions parameter to 1. (This can be passed via a query string or as part of the request body.) Error handling \u00b6 When an error is encountered, the response code will be in the 400 range. Occasionally, a 500-range error may occur, though this indicates that the server was unable to process the request. The API may be temporarily disabled or another server error has occurred. Error messages have a standardized format. Here is an example: { \"errors\": [ { \"code\": \"api_key_not_found\", \"message\": \"API key provided in request was not found.\", \"params\": [] } ] } The top level will be an object with an errors key. This will be an array with 1 or more entries. Each entry is an object with the following parameters: code - this is a machine readable code for the error. There are many possible error codes as they are situation dependent. message - a human readable version of the error. This may change or may be translated and should not be used to identify the type of error. params - this is a list of key-value parameters that are relevant to the error triggered. They may supplement the error code and message to give more specific details about the error. API endpoints \u00b6 The API features a number of endpoints and actions that can be taken. Additional endpoints and data may be added in the future. View the API endpoint documentation This endpoint documentation has been generated from the API data and comments in the code. It will be expanded and updated over time.","title":"REST API"},{"location":"rest-api/#rest-api","text":"In XenForo 2.1, a REST API was added. This allows you to programmatically interact with many areas of a XenForo installation. Accessing the API requires generating a key via the admin control panel. There is no unauthenticated access to the API and users cannot generate their own keys to access the API at this time. The API for a specific XenForo installation is accessible at <XenForo base URL>/api/ . All endpoints are prefixed by this URL. For example, if XenForo is installed at https://example.com/community/ , then the API URLs will start with https://example.com/community/api/ . In this example, accessing a list of threads would be done via https://example.com/community/api/threads/ . The API is enabled by default. If necessary, all API access can quickly be disabled by adding the following to src/config.php : $config['enableApi'] = false;","title":"REST API"},{"location":"rest-api/#api-keys","text":"API keys are created via the admin control panel by going to Setup > API keys . As generating API keys can allow access to highly privileged data, only super administrators may access this system. All super admins will receive an email when an API key is generated to ensure that the request is valid. When a key is created, a random string will be generated and this will be used to authenticate yourself with the API. It is important that this key is kept secret. If you believe an API key has been compromised, you should immediately regenerate the key and update any code using the old key.","title":"API keys"},{"location":"rest-api/#key-types","text":"All API access is done in the context of a specific user. For example, if I access the API as \"John\" and I make a request that posts a thread, that thread will have been created by \"John\". In most cases, the API will also respect permissions specified for this user, so they can't access data they wouldn't see when browsing the forum normally. To allow control over this, there are three types of API keys: Guest key - this key always accesses the API as a guest user. These requests will always respect the guest permissions. For example, if guests cannot reply to threads, an API request to reply to a thread would generate a no permission error. User key - this key always accesses the API as a specified user and always respects that user's permissions, similar to a guest key. Super user key - this key can access the API as any user by passing an additional value into it. Optionally, this key can bypass the requesting user's permissions, allowing them to take actions or view content they would not normally have access to. Super user keys are very useful for integrations with other systems or applications. For example, you may integrate with a third-party CMS that creates a thread whenever you post a new article. This type of key would allow you to create a thread with a different user depending on the article author or in a forum that users normally can't post in.","title":"Key types"},{"location":"rest-api/#key-scopes","text":"To help limit the amount of damage a compromised key can inflict, each key can control the API scopes that it can access. Scopes limit access to areas of the API, independent of the requesting user's permissions. Each endpoint in the API will be covered by one of more scopes. If the API has not been granted any of those scopes, the request will fail. For security, we recommend you only grant a key the scopes that you require. If you require additional scopes at a later time, they can be added when needed.","title":"Key scopes"},{"location":"rest-api/#accessing-the-api","text":"Once you know the URL to access the API and have a key, you can begin to make requests to it. All API responses will be returned in JSON format, except in cases where a binary file is specifically requested (such as when downloading an attachment). Errors will always return a response code in the 400 range. Successful requests will return a 200 code. While not commonly used, redirects will return a 300-range code. Requests bodies must be sent using the application/x-www-form-urlencoded encoding or, if a file is being uploaded, the multipart/form-data encoding. Parameters may also be passed via the query string. All request data must use the UTF-8 character set. Requests must pass the API key to use via the XF-Api-Key header. This must be present in all requests. If the API key selected is a super user key, you may pass the user ID of the context user via the XF-Api-User header. If no user ID is passed, the context will default to a guest. If the request is made with a super user key and you wish to bypass the context user's permissions, this may be done on a per-request basis by setting the api_bypass_permissions parameter to 1. (This can be passed via a query string or as part of the request body.)","title":"Accessing the API"},{"location":"rest-api/#error-handling","text":"When an error is encountered, the response code will be in the 400 range. Occasionally, a 500-range error may occur, though this indicates that the server was unable to process the request. The API may be temporarily disabled or another server error has occurred. Error messages have a standardized format. Here is an example: { \"errors\": [ { \"code\": \"api_key_not_found\", \"message\": \"API key provided in request was not found.\", \"params\": [] } ] } The top level will be an object with an errors key. This will be an array with 1 or more entries. Each entry is an object with the following parameters: code - this is a machine readable code for the error. There are many possible error codes as they are situation dependent. message - a human readable version of the error. This may change or may be translated and should not be used to identify the type of error. params - this is a list of key-value parameters that are relevant to the error triggered. They may supplement the error code and message to give more specific details about the error.","title":"Error handling"},{"location":"rest-api/#api-endpoints","text":"The API features a number of endpoints and actions that can be taken. Additional endpoints and data may be added in the future. View the API endpoint documentation This endpoint documentation has been generated from the API data and comments in the code. It will be expanded and updated over time.","title":"API endpoints"},{"location":"routing-basics/","text":"Routing basics \u00b6 Within a PHP application, like XF2, we need a way of being able to take a user request for a specific URL, understand which controller, action and what data that URL represents, so that can present the appropriate response to the user. The concept of converting a URL to a location within the code is known as \"Routing\". In XF2, routing is almost entirely managed from one location within the Admin CP. That location is Admin CP > Development > Routes . Routes are grouped by one of two types, Public and Admin types and they provide the routing of requests within the Public and Admin apps respectively. A simple example \u00b6 On the Routes page (see above) you should see an entry listed for account/ . This is a public route and provides the routing for requests to the URL index.php?account/ . This particular route is pretty simple; it only consists of a small amount of configuration. Notably, it consists of a \"Route prefix\", a section context and a controller class. Let's understand those bits in more detail: Route prefix \u00b6 The route prefix is essentially the bit after index.php? and before the first / . It is the first step in identifying which controller to route the request to. Section context \u00b6 The section context tells the navigation systems within XF which navigation item should be selected when a visitor is viewing a page routed to by this route. For public routes, the section context should be the ID of the top level navigation entry. For admin routes, this should refer to the ID of the most specific admin navigation entry (regardless of depth). In the case of the account route, the section context doesn't necessarily apply by default, because we do not have an \"account\" navigation tab. But, to see this in action, just change the \"Section context\" value here to \"forums\", save changes and go to your account on the front end. You should now see that the \"Forums\" navigation tab is selected! Controller \u00b6 This is the class name of the Controller that should be called when a request matches this route. In the case of the \"account/\" route, we have XF:Account specified. This will load the Account controller. (See Short class names for more information). The code for this is located in the following location src/XF/Pub/Controller/Account.php . Notice how short class names are able to resolve to an \"infix\" as well as a prefix (XF) and a suffix (Account). In this case, the infix for this controller (Pub) is inferred from the Account route type (public). Controller actions \u00b6 Above we explained how a route is matched to a specific controller, but we don't yet know how a specific action within that controller is called. Controllers are essentially classes that contain a number of action methods and it is the part of the URL after the route prefix which indicates the controller action. Given a URL of index.php?account/account-details , you should be routed to the class XF\\Pub\\Controller\\Account and the method named actionAccountDetails() . If a route does not specify an action, then the method called is simply actionIndex() . You can read more about controllers in the Controller basics section. A more advanced example (route formats) \u00b6 Let's look at the members/ route. This route is still pretty simple, like the account/ route, but it has an additional field populated; the \"Route format\". To understand how that works, look at your own user profile on the front end. The URL of that profile will look something like this index.php?members/your-name.1 . Specifically, take note of the your-name.1 part. This is the part we're attempting to match using the \"Route format\". The \"Route format\" allows us to extract data from a request URL, so we can pass that information into the controller action so that the action can load specific information; in this case it loads the details for the requested user profile. It also helps us build links from data passed in. Here's the syntax: :int<user_id,username>/:page It's interesting to note at this point that the important part of a profile URL for finding the profile is not actually the your-name bit, but it is actually the user ID ( 1 ). To demonstrate this, change the URL and replace your-name with not-your-name . You will see that the correct profile is found, and a redirect is performed to the correct URL. The above format indicates that it's an integer based parameter. For building an outgoing link, we pull the integer from the user_id key of the data passed in. If a username key is passed into the data, it will be \"slugified\" and prepended to the integer ID like you see in the URL to your profile. For matching an incoming URL, this gets turned into a regular expression that matches the integer parameter format. :page is a shortcut for generating the page-123 part of a link. In this case, it looks for the page in the link parameters. If found, it's put in the URL and then removed from the params. For incoming parsing, if matched (it can be empty), it will add the page number to the parameters passed to a controller. Route parameters \u00b6 When a route is matched to a specific controller and action, any parameters in the URL are wrapped up into a special object we call the ParameterBag . This object is specifically designed to separate normal URL parameters with those which come from the route match. The ParameterBag object is passed into every controller action, and is used as follows: $userId = $params->user_id; Sub-names \u00b6 It is also possible to split routes into further sub-names. You can see this in action by looking at the members/following route. In this example, following is the sub-name to the route members . Ordinarily, a URL which looks like index.php?members/following , the following part would indicate the action, and simply match against the normal members/ route. However, if there's a route that matches the prefix \"members\" and the \"sub-name\" following, it will be used instead. This is true here, so it builds a link like the following: members/:int<user_id,username>/following/:page For incoming route matching, this route will be tested before the basic members route; if it matches, it will be used. This sub-name system allows behavior changes, such as changing the position of parameters or sub-grouping routes into different controllers or with different params. You can see an example of the latter in the Resource Manager and Media Gallery add-ons.","title":"Routing basics"},{"location":"routing-basics/#routing-basics","text":"Within a PHP application, like XF2, we need a way of being able to take a user request for a specific URL, understand which controller, action and what data that URL represents, so that can present the appropriate response to the user. The concept of converting a URL to a location within the code is known as \"Routing\". In XF2, routing is almost entirely managed from one location within the Admin CP. That location is Admin CP > Development > Routes . Routes are grouped by one of two types, Public and Admin types and they provide the routing of requests within the Public and Admin apps respectively.","title":"Routing basics"},{"location":"routing-basics/#a-simple-example","text":"On the Routes page (see above) you should see an entry listed for account/ . This is a public route and provides the routing for requests to the URL index.php?account/ . This particular route is pretty simple; it only consists of a small amount of configuration. Notably, it consists of a \"Route prefix\", a section context and a controller class. Let's understand those bits in more detail:","title":"A simple example"},{"location":"routing-basics/#route-prefix","text":"The route prefix is essentially the bit after index.php? and before the first / . It is the first step in identifying which controller to route the request to.","title":"Route prefix"},{"location":"routing-basics/#section-context","text":"The section context tells the navigation systems within XF which navigation item should be selected when a visitor is viewing a page routed to by this route. For public routes, the section context should be the ID of the top level navigation entry. For admin routes, this should refer to the ID of the most specific admin navigation entry (regardless of depth). In the case of the account route, the section context doesn't necessarily apply by default, because we do not have an \"account\" navigation tab. But, to see this in action, just change the \"Section context\" value here to \"forums\", save changes and go to your account on the front end. You should now see that the \"Forums\" navigation tab is selected!","title":"Section context"},{"location":"routing-basics/#controller","text":"This is the class name of the Controller that should be called when a request matches this route. In the case of the \"account/\" route, we have XF:Account specified. This will load the Account controller. (See Short class names for more information). The code for this is located in the following location src/XF/Pub/Controller/Account.php . Notice how short class names are able to resolve to an \"infix\" as well as a prefix (XF) and a suffix (Account). In this case, the infix for this controller (Pub) is inferred from the Account route type (public).","title":"Controller"},{"location":"routing-basics/#controller-actions","text":"Above we explained how a route is matched to a specific controller, but we don't yet know how a specific action within that controller is called. Controllers are essentially classes that contain a number of action methods and it is the part of the URL after the route prefix which indicates the controller action. Given a URL of index.php?account/account-details , you should be routed to the class XF\\Pub\\Controller\\Account and the method named actionAccountDetails() . If a route does not specify an action, then the method called is simply actionIndex() . You can read more about controllers in the Controller basics section.","title":"Controller actions"},{"location":"routing-basics/#a-more-advanced-example-route-formats","text":"Let's look at the members/ route. This route is still pretty simple, like the account/ route, but it has an additional field populated; the \"Route format\". To understand how that works, look at your own user profile on the front end. The URL of that profile will look something like this index.php?members/your-name.1 . Specifically, take note of the your-name.1 part. This is the part we're attempting to match using the \"Route format\". The \"Route format\" allows us to extract data from a request URL, so we can pass that information into the controller action so that the action can load specific information; in this case it loads the details for the requested user profile. It also helps us build links from data passed in. Here's the syntax: :int<user_id,username>/:page It's interesting to note at this point that the important part of a profile URL for finding the profile is not actually the your-name bit, but it is actually the user ID ( 1 ). To demonstrate this, change the URL and replace your-name with not-your-name . You will see that the correct profile is found, and a redirect is performed to the correct URL. The above format indicates that it's an integer based parameter. For building an outgoing link, we pull the integer from the user_id key of the data passed in. If a username key is passed into the data, it will be \"slugified\" and prepended to the integer ID like you see in the URL to your profile. For matching an incoming URL, this gets turned into a regular expression that matches the integer parameter format. :page is a shortcut for generating the page-123 part of a link. In this case, it looks for the page in the link parameters. If found, it's put in the URL and then removed from the params. For incoming parsing, if matched (it can be empty), it will add the page number to the parameters passed to a controller.","title":"A more advanced example (route formats)"},{"location":"routing-basics/#route-parameters","text":"When a route is matched to a specific controller and action, any parameters in the URL are wrapped up into a special object we call the ParameterBag . This object is specifically designed to separate normal URL parameters with those which come from the route match. The ParameterBag object is passed into every controller action, and is used as follows: $userId = $params->user_id;","title":"Route parameters"},{"location":"routing-basics/#sub-names","text":"It is also possible to split routes into further sub-names. You can see this in action by looking at the members/following route. In this example, following is the sub-name to the route members . Ordinarily, a URL which looks like index.php?members/following , the following part would indicate the action, and simply match against the normal members/ route. However, if there's a route that matches the prefix \"members\" and the \"sub-name\" following, it will be used instead. This is true here, so it builds a link like the following: members/:int<user_id,username>/following/:page For incoming route matching, this route will be tested before the basic members route; if it matches, it will be used. This sub-name system allows behavior changes, such as changing the position of parameters or sub-grouping routes into different controllers or with different params. You can see an example of the latter in the Resource Manager and Media Gallery add-ons.","title":"Sub-names"},{"location":"scotchbox/","text":"Appendix: Scotch Box \u00b6 The following is a description of how to install the excellent Scotch Box onto your own computer, in order to have a fully operational development environment for XenForo in just a few minutes with a handful of simple commands. XenForo has a custom Scotch Box config, which provides everything you need to run XenForo, including a debugger and a performance-enhancing data cache. Scotch Box runs within a VirtualBox / Vagrant environment. Installing Scotch Box \u00b6 Start by deciding where on your computer you want your virtual web server to keep its files. It is recommended that you choose a location within your own user home directory. In the following example locations, we will be using a directory called MyServer , located in the root of your own user directory, identified by your name {username} : /Users/{username}/MyServer (Mac) C:\\Users\\{username}\\MyServer (Windows) /home/{username}/MyServer (some Linux distributions) /users/{username}/MyServer (other Linux distributions) Once you have chosen a location, follow these steps: Install VirtualBox on your computer Install Vagrant on your computer Using a git client, clone https://github.com/scotch-io/scotch-box into your MyServer directory. Using the command line client with the Mac example location above, the command would be: git clone https://github.com/scotch-io/scotch-box /Users/{username}/MyServer Once the clone process is complete, download this custom Vagrantfile and overwrite the Vagrantfile that has been created at */Users/{username}/MyServer/Vagrantfile: Download custom Vagrantfile . When the custom Vagrantfile is in place, run the following commands: cd /Users/{username}/MyServer vagrant up Your Scotch Box virtual machine is now created and ready to use. Note Scotch Box also provides a ' Scotch Box Pro ' version of their virtual machine for a reasonable purchase price. If you prefer to run Scotch Box Pro, refer to the section below describing the differences between configuring and running Scotch Box and Scotch Box Pro . Where do the files go? \u00b6 Once your Scotch Box is up and running, you can keep your XenForo PHP and JS files on your host machine, allowing you to use your text editor or IDE of choice, while the virtual machine is responsible for compiling and serving those files through its web server. You will be able to visit your new web server in your web browser at the following address: http://192.168.33.10 The web server will pull the files to be served from /Users/{username}/MyServer/public If you want your XenForo to be installed at http://192.168.33.10/xenforo , you should place the contents of the upload folder from the XenForo package into /Users/{username}/MyServer/public/xenforo . Stopping and restarting the server \u00b6 You can stop the Scotch Box server at any time by running cd /Users/{username}/MyServer vagrant halt ... and you can restart it by running cd /Users/{username}/MyServer vagrant up Note Although Vagrant / Scotch Box will automatically shut down when you reboot your computer, it will not automatically start up again. Whenever you reboot, you will need to run the vagrant up command again in order to use the server. Offical documentation \u00b6 This guide is derived from the official Scotch Box documentation, which is located at https://box.scotch.io Scotch Box Pro \u00b6 While the basic Scotch Box requires some additional configuration (which is handed through the custom Vagrantfile) in order to run XenForo 2, Scotch Box Pro requires no additional configuration, and is ready to run XenForo 2 without downloading extra packages. To run Scotch Box Pro, purchase it from the Scotch Box Pro website, then run the git clone command provided as part of the instructions you will receive post-purchase. You can now install using the same instructions as above, with the single exception that you should download this custom Vagrantfile instead of the one listed in the instructions for Scotch Box.","title":"Appendix: Scotch Box"},{"location":"scotchbox/#appendix-scotch-box","text":"The following is a description of how to install the excellent Scotch Box onto your own computer, in order to have a fully operational development environment for XenForo in just a few minutes with a handful of simple commands. XenForo has a custom Scotch Box config, which provides everything you need to run XenForo, including a debugger and a performance-enhancing data cache. Scotch Box runs within a VirtualBox / Vagrant environment.","title":"Appendix: Scotch Box"},{"location":"scotchbox/#installing-scotch-box","text":"Start by deciding where on your computer you want your virtual web server to keep its files. It is recommended that you choose a location within your own user home directory. In the following example locations, we will be using a directory called MyServer , located in the root of your own user directory, identified by your name {username} : /Users/{username}/MyServer (Mac) C:\\Users\\{username}\\MyServer (Windows) /home/{username}/MyServer (some Linux distributions) /users/{username}/MyServer (other Linux distributions) Once you have chosen a location, follow these steps: Install VirtualBox on your computer Install Vagrant on your computer Using a git client, clone https://github.com/scotch-io/scotch-box into your MyServer directory. Using the command line client with the Mac example location above, the command would be: git clone https://github.com/scotch-io/scotch-box /Users/{username}/MyServer Once the clone process is complete, download this custom Vagrantfile and overwrite the Vagrantfile that has been created at */Users/{username}/MyServer/Vagrantfile: Download custom Vagrantfile . When the custom Vagrantfile is in place, run the following commands: cd /Users/{username}/MyServer vagrant up Your Scotch Box virtual machine is now created and ready to use. Note Scotch Box also provides a ' Scotch Box Pro ' version of their virtual machine for a reasonable purchase price. If you prefer to run Scotch Box Pro, refer to the section below describing the differences between configuring and running Scotch Box and Scotch Box Pro .","title":"Installing Scotch Box"},{"location":"scotchbox/#where-do-the-files-go","text":"Once your Scotch Box is up and running, you can keep your XenForo PHP and JS files on your host machine, allowing you to use your text editor or IDE of choice, while the virtual machine is responsible for compiling and serving those files through its web server. You will be able to visit your new web server in your web browser at the following address: http://192.168.33.10 The web server will pull the files to be served from /Users/{username}/MyServer/public If you want your XenForo to be installed at http://192.168.33.10/xenforo , you should place the contents of the upload folder from the XenForo package into /Users/{username}/MyServer/public/xenforo .","title":"Where do the files go?"},{"location":"scotchbox/#stopping-and-restarting-the-server","text":"You can stop the Scotch Box server at any time by running cd /Users/{username}/MyServer vagrant halt ... and you can restart it by running cd /Users/{username}/MyServer vagrant up Note Although Vagrant / Scotch Box will automatically shut down when you reboot your computer, it will not automatically start up again. Whenever you reboot, you will need to run the vagrant up command again in order to use the server.","title":"Stopping and restarting the server"},{"location":"scotchbox/#offical-documentation","text":"This guide is derived from the official Scotch Box documentation, which is located at https://box.scotch.io","title":"Offical documentation"},{"location":"scotchbox/#scotch-box-pro","text":"While the basic Scotch Box requires some additional configuration (which is handed through the custom Vagrantfile) in order to run XenForo 2, Scotch Box Pro requires no additional configuration, and is ready to run XenForo 2 without downloading extra packages. To run Scotch Box Pro, purchase it from the Scotch Box Pro website, then run the git clone command provided as part of the instructions you will receive post-purchase. You can now install using the same instructions as above, with the single exception that you should download this custom Vagrantfile instead of the one listed in the instructions for Scotch Box.","title":"Scotch Box Pro"},{"location":"template-syntax/","text":"Template syntax \u00b6 The XenForo 2 template syntax is a powerful tool for both developers and forum administrators, giving you complete control over the layout of your XenForo pages. Best practices \u00b6 XenForo tags, by convention, are lowercase . All XenForo tags are prefixed with the xf: namespace. Useful information \u00b6 Commenting up your templates \u00b6 If you want to comment out some template code (or an inspirational message) that you don't want viewable in the final page source, you can use the xf:comment tag. <xf:comment> If you stop seeing the world in terms of what you like and what you dislike and saw things for what they truly are in themselves, you will find a great deal more peace in your life. </xf:comment> Including another template in a template \u00b6 The xf:include tag allows you to include a different template in your current template. <xf:include template=\"my_template\" /> Simply set the template attribute to the name of the template you want to include. Template macros \u00b6 Template macros are a very powerful aspect of the XenForo template syntax. You should generally use a macro any place you would use a function or subroutine in a programming language. For non-programmers, I'd summarize this as: either use a macro any place you want to produce the same thing multiple times in multiple different files or to produce something different under different circumstances (this would probably make more sense if you check the guide on defining a macro). Warning For readability reasons, you should not use a macro tag as a variable. You should instead use the Set tag and treat the variable as you would any template variable. Defining a macro \u00b6 <xf:macro name=\"my_macro_name\"> <!-- Your macro content --> </xf:macro> At its simplest, a macro can be defined with a name attribute and the content you want repeated inside the macro tag. Note When you're using a macro in multiple files, it's best practice to put the macro in it's own template. Macro arguments \u00b6 <xf:macro name=\"my_macro_name\" arg-message=\"My amazing macro message!\"> <h1>Message</h1> <p>{$message}</p> </xf:macro> In this example, a macro is defined with a default value for arg-message ( My amazing macro message! ). This value would be overridden if the macro was called with the message argument. Sometimes it's necessary to mark an argument as required. This can be done by setting the argument value to ! in the macro definition. Including & using macros \u00b6 <xf:macro template=\"my_macro_template\" name=\"my_macro_name\" /> At it's simplest, you include a macro by setting the name attribute and leaving the tag empty. Note When using a macro tag, you should use the self-closing form of the tag to allow someone to more easily distinguish the difference between a definition and usage of a macro. Macro arguments \u00b6 You can also provide arguments to the macro: <xf:macro template=\"my_macro_template\" name=\"my_macro_name\" arg-argName=\"argValue\" /> Where argName is the name of the macro argument. Note You should use lowerCamelCase for your macro argument names. Template control structures \u00b6 The XenForo 2 template syntax supports certain control structures to make certain tasks easier to achieve. If tag \u00b6 The if template tag can be used to conditionally display some HTML or a part of a template. <!-- Shows content only if a user is signed in... --> <xf:if is=\"$xf.visitor.user_id\"> <!-- Do something... --> </xf:if> The if tag takes the following attributes: is - The condition which, when met, the tags contents should be shown. Conditions \u00b6 The is attribute supports a few logical operators: OR - Used to link alternative conditions. (Alternatives: || ) AND - Used to link additional conditions. (Alternatives: && ) ! - Place before a condition to invert it. (Known as: 'not') XOR - Returns true if only one of two conditions is true. (Known as: Exclusive OR) Else/Else-If tag \u00b6 The else and else-if tags are used in conjunction with the if tag to conditionally display HTML in the way that the name suggests. Example usage of else: <xf:if is=\"$xf.visitor.is_admin\"> <!-- Content here will only be shown to Administrators... --> <xf:else /> <!-- Content here will be shown to anyone who is not an Administrator! --> </xf:if> Example usage of else-if: <xf:if is=\"$xf.visitor.is_admin\"> <!-- Content here will only be shown to Administrators... --> <xf:elseif is=\"$xf.visitor.is_moderator\" /> <!-- Content here will only be shown to Moderators (excluding users who are also Administrators). --> <xf:else /> <!-- Content here will be shown to anyone who is not an Administrator, or a Moderator. --> </xf:if> As you can see, once a condition has been met, the rest of the if statement is ignored. (So, in this case, if the user is an Administrator, the top xf:if section is run but then the rest of the if statement is ignored.) For-each tag \u00b6 The for-each tag allows you to loop over an array of items, printing a block of HTML for each item. <xf:set var=\"$names\" value=\"{{ ['Patrick', 'Theresa', 'Kimball', 'Wayne', 'Grace'] }}\" /> <xf:foreach loop=\"$names\" key=\"$key\" value=\"$name\" i=\"$i\"> <p>Hello there, {$name}. This is name number {$i}. Array key of this element: {$key}</p> </xf:foreach> The for-each tag takes the following attributes: loop - The array to loop over. key - A variable name to use in the loop to get current element's array key. Can be integer (ordinary array) or string (associative array). value - A variable name to use within the loop, containing the current array item. i - A variable name to use in the loop for the current index. Example Output \u00b6 Hello there, Patrick. This is name number 1. Hello there, Theresa. This is name number 2. Hello there, Kimball. This is name number 3. Hello there, Wayne. This is name number 4. Hello there, Grace. This is name number 5. Template tags \u00b6 Avatar tag \u00b6 Inserts a user's avatar in the page. <xf:avatar user=\"{$xf.visitor}\" size=\"o\" canonical=\"true\" /> The avatar tag takes the following attributes: user - The XenForo User object to generate the avatar for. size - The size of the image to generate. (See image sizes) canonical - Whether to use the full SEO-friendly URL. This value is only respected for custom avatars. notooltip - Whether the tool-tip displayed when hovering over the avatar should be disabled. forcetype - Can be used to force getting the gravatar or custom avatars by setting the value to either of those. defaultname - The username to use if the user attribute contains an invalid user. Image sizes \u00b6 If an avatar of invalid size is provided, the code will fallback to size ' s '. o - 384px h - 384px l - 192px m - 96px s - 48px Breadcrumb tag \u00b6 Modifies the page breadcrumb. <xf:breadcrumb href=\"{{ link('my_page') }}\">{{ phrase('my_page_name') }}</xf:breadcrumb> The breadcrumb tag takes the following attributes: href - The link to set for the final element in the breadcrumb. The value of the tag can be used to set the name of the final element in the breadcrumb. Alternative uses \u00b6 <xf:breadcrumb source=\"$category.getBreadcrumbs(false)\" /> You can also define your own breadcrumb programmatically by calling your function in the source attribute of the breadcrumb tag. The source parameter essentially takes an array of objects with href and value attributes (multidimensional array), where each object is a breadcrumb element. Note If you want to change the root breadcrumb, you can change the \"Root breadcrumb\" option in the \"Basic board information\" options section. Button tag \u00b6 Adds a button element with the appropriate classes and optionally an icon. <xf:button icon=\"save\"></xf:button> The button tag takes the following attributes: icon - The icon class to apply to the button. (See button icons) Button icons \u00b6 By default, XenForo buttons support the following icons (created with CSS): add confirm write import export download disable edit save reply quote purchase payment convert search sort upload attach login rate config refresh translate vote result history cancel preview conversation bolt list prev next markRead notificationsOn notificationsOff merge move copy approve unapprove delete undelete stick unstick lock unlock Callback tag \u00b6 Executes a PHP Callback method. <xf:callback class=\"Vendor\\Addon\\Class\" method=\"getX\" params=\"['abc']\"></xf:callback> The callback tag takes the following attributes: class - The class (from the root namespace) containing the method to run. method - The method to run. (See callback methods) params - An array of parameters to provide to the method. Callback methods \u00b6 For a method to be considered a callback method, it must be named appropriately or it will throw an error ' callback_method_x_does_not_appear_to_indicate_read_only '. For it to be considered read-only, the method name must begin with one of the following prefixes: are can count data display does exists fetch filter find get has is pluck print render return show total validate verify view CSS tag \u00b6 Includes a CSS or LESS template file. <xf:css src=\"mycss_file.css\" /> The CSS tag takes the following attributes: src - The CSS or LESS template file to include. Alternative uses \u00b6 <xf:css> html, body { font-family: \"Roboto\", sans-serif; } </xf:css> If the CSS tag is not empty, anything in the tag will be converted into inline CSS. Further notes \u00b6 For [CSS], forget about calling them as files. Copy and paste them into new templates. Chris D, XenForo developer Source : https://xenforo.com/community/threads/including-external-library-js-and-css.136153/post-1185631 JS tag \u00b6 Includes a JavaScript file. <xf:js src=\"myaddon/vendor/scripts/myjs_file.js\" /> The JS tag takes the following attributes: src - The JS file to include in the template. prod - The JS file to include in the template, only for production mode. dev - The JS file to include in the template, only for development mode. min - Whether or not to include the minified version of the file. (Replaces .js with .min.js ) - Respected only in production mode. addon - Whether or not the development JS URL should be used. - Respected only in development mode. Warning The src tag cannot be used in conjunction with either the prod or dev tags. Alternative uses \u00b6 <xf:js> alert(\"The truth hurts, I know. It's biologically based actually.\"); </xf:js> If the JS tag is not empty, anything in the tag will be converted to inline JS. Further notes \u00b6 JavaScript files are served relative to the /js directory. Although not recommended, you can also include external resources with this tag. A good example of this tag is in the editor template. Set tag \u00b6 The set tag allows you to create a reference to another variable or create a new variable. You should use the set tag anywhere you would use a variable in a programming language. <xf:set var=\"$visitor\" value=\"{$xf.visitor}\" /> Warning Do not use the Set tag for a group of elements you wish to use in multiple templates, you should instead use the Macro Tag. Warning The variable name ( var attribute) must begin with a $ . The set tag takes the following attributes: var - The name of the variable you wish to define (essentially, the alias). value - A variable to reference to or a variable value. Alternative uses \u00b6 <xf:set var=\"$myVariableName\"> My Variable Value! This could be a callback, or simply a group of phrases. </xf:set> When the value attribute is not provided, and the tag is not empty, the variable value will be set to the contents of the tag. Warning When you use the Set tag in this form, the value will be escaped and the resulting value will be a string. The value attribute, whilst not supporting HTML or HTML-like tags does not have this limitation. Likes tag \u00b6 Displays the number of likes on a post and a few of the users who've liked the post. <xf:likes content=\"{$post}\" url=\"\" /> The likes tag takes the following attributes: content - The XF\\Entity\\Post or XF\\Entity\\ProfilePost entity to display the 'likes' text for. url - The URL to display when the 'likes' text is clicked. Format \u00b6 You, tlisbon, kcho and 2 others The format is [\ud83d\udc4d abc and x others] (where the \ud83d\udc4d 'thumbs up' emoji represents the 'likes' icon and abc represents the usernames of the last three users who liked the post.) Sidebar tag \u00b6 See Sectioned Tags . SideNav tag \u00b6 See Sectioned Tags . Title tag \u00b6 Sets the page's title, both on the page in the h1 tag and in the browser tab. <xf:title>{{ phrase('my_page_title') }}</xf:title> Further notes \u00b6 Whilst the title can, of course, be hardcoded, it is highly recommended that you use a phrase, both for internationalization and for the added customizability on the site administrator's end. Widget tag \u00b6 Includes a widget in the page, or adds a widget to a widget position. <xf:widget key=\"widget_name\" /> The widget tag takes the following attributes: key - The widget key, as defined in the widget settings. position - If set, changes the position that the widget will be rendered. class - Not to be confused with HTML class, this is the PHP class containing the widget definition. title - When the class attribute is used, you can use the title attribute to set the widget title. You can also provide widget-specific options as attributes when the class attribute is used. Warning The class tag cannot be used in conjunction with the key tag. UserActivity tag \u00b6 Displays the status of a user, in terms of their last action and when that action occurred. <xf:useractivity user=\"{$xf.visitor}\" /> The UserActivity tag takes the following attributes: user - The user to display the status of. Format \u00b6 Viewing page Latest Case Files \u00b7 4 minutes ago The format is [Activity Name] \u00b7 [Time] UserBanners tag \u00b6 Displays the user's banners in a horizontal list. <xf:userbanners user=\"{$xf.visitor}\" /> The UserBanners tag takes the following attributes: user - The user to display the user banners of. Example \u00b6 An example result of the UserBanners tag. UserBlurb tag \u00b6 Displays a one-line summary of a user's profile. <xf:userblurb user=\"${xf.visitor}\" /> The UserBlurb tag takes the following attributes: user - The XenForo User Object to display the blurb of. Format \u00b6 FBI Consultant \u00b7 43 \u00b7 From United States of America The format is [Role / Custom Title] \u00b7 Age \u00b7 Location Username tag \u00b6 Displays the user's username, optionally with a tool-tip. <xf:username user=\"{$xf.visitor.username}\" notooltip=\"true\" /> The Username tag takes the following attributes: user - The XenForo User Object to display the name of. notooltip - Whether or not the tool-tip should be disabled. href - The link to navigate to when the username is clicked. Warning The tool-tip will not be displayed if an href is set, as it won't work and might be misleading to users. UserTitle tag \u00b6 Displays the user's title. <xf:usertitle user=\"{$xf.visitor}\" /> The UserTitle tag takes the following attributes: user - The XenForo User Object to display the user title of. Sectioned tags \u00b6 Sectioned Tags all call the function modifySectionedHtml . The HTML element that they change is simply the tag name. So the sidebar tag will modify the sidebar HTML, etc. Example \u00b6 <xf:sidebar> <h1>My Magical Sidebar!</h1> </xf:sidebar> Common attributes \u00b6 mode - The mode of the modification. (See Modification modes) Modification modes \u00b6 By default, the modification mode is replace . (i.e. if the attribute is not specified.) prepend - Places the contents of the tag at the beginning of the element's HTML. append - Places the contents of the tag at the end of the element's HTML. replace - Replaces the element's HTML with the contents of the tag.","title":"Template syntax"},{"location":"template-syntax/#template-syntax","text":"The XenForo 2 template syntax is a powerful tool for both developers and forum administrators, giving you complete control over the layout of your XenForo pages.","title":"Template syntax"},{"location":"template-syntax/#best-practices","text":"XenForo tags, by convention, are lowercase . All XenForo tags are prefixed with the xf: namespace.","title":"Best practices"},{"location":"template-syntax/#useful-information","text":"","title":"Useful information"},{"location":"template-syntax/#commenting-up-your-templates","text":"If you want to comment out some template code (or an inspirational message) that you don't want viewable in the final page source, you can use the xf:comment tag. <xf:comment> If you stop seeing the world in terms of what you like and what you dislike and saw things for what they truly are in themselves, you will find a great deal more peace in your life. </xf:comment>","title":"Commenting up your templates"},{"location":"template-syntax/#including-another-template-in-a-template","text":"The xf:include tag allows you to include a different template in your current template. <xf:include template=\"my_template\" /> Simply set the template attribute to the name of the template you want to include.","title":"Including another template in a template"},{"location":"template-syntax/#template-macros","text":"Template macros are a very powerful aspect of the XenForo template syntax. You should generally use a macro any place you would use a function or subroutine in a programming language. For non-programmers, I'd summarize this as: either use a macro any place you want to produce the same thing multiple times in multiple different files or to produce something different under different circumstances (this would probably make more sense if you check the guide on defining a macro). Warning For readability reasons, you should not use a macro tag as a variable. You should instead use the Set tag and treat the variable as you would any template variable.","title":"Template macros"},{"location":"template-syntax/#defining-a-macro","text":"<xf:macro name=\"my_macro_name\"> <!-- Your macro content --> </xf:macro> At its simplest, a macro can be defined with a name attribute and the content you want repeated inside the macro tag. Note When you're using a macro in multiple files, it's best practice to put the macro in it's own template.","title":"Defining a macro"},{"location":"template-syntax/#macro-arguments","text":"<xf:macro name=\"my_macro_name\" arg-message=\"My amazing macro message!\"> <h1>Message</h1> <p>{$message}</p> </xf:macro> In this example, a macro is defined with a default value for arg-message ( My amazing macro message! ). This value would be overridden if the macro was called with the message argument. Sometimes it's necessary to mark an argument as required. This can be done by setting the argument value to ! in the macro definition.","title":"Macro arguments"},{"location":"template-syntax/#including-using-macros","text":"<xf:macro template=\"my_macro_template\" name=\"my_macro_name\" /> At it's simplest, you include a macro by setting the name attribute and leaving the tag empty. Note When using a macro tag, you should use the self-closing form of the tag to allow someone to more easily distinguish the difference between a definition and usage of a macro.","title":"Including &amp; using macros"},{"location":"template-syntax/#macro-arguments_1","text":"You can also provide arguments to the macro: <xf:macro template=\"my_macro_template\" name=\"my_macro_name\" arg-argName=\"argValue\" /> Where argName is the name of the macro argument. Note You should use lowerCamelCase for your macro argument names.","title":"Macro arguments"},{"location":"template-syntax/#template-control-structures","text":"The XenForo 2 template syntax supports certain control structures to make certain tasks easier to achieve.","title":"Template control structures"},{"location":"template-syntax/#if-tag","text":"The if template tag can be used to conditionally display some HTML or a part of a template. <!-- Shows content only if a user is signed in... --> <xf:if is=\"$xf.visitor.user_id\"> <!-- Do something... --> </xf:if> The if tag takes the following attributes: is - The condition which, when met, the tags contents should be shown.","title":"If tag"},{"location":"template-syntax/#conditions","text":"The is attribute supports a few logical operators: OR - Used to link alternative conditions. (Alternatives: || ) AND - Used to link additional conditions. (Alternatives: && ) ! - Place before a condition to invert it. (Known as: 'not') XOR - Returns true if only one of two conditions is true. (Known as: Exclusive OR)","title":"Conditions"},{"location":"template-syntax/#elseelse-if-tag","text":"The else and else-if tags are used in conjunction with the if tag to conditionally display HTML in the way that the name suggests. Example usage of else: <xf:if is=\"$xf.visitor.is_admin\"> <!-- Content here will only be shown to Administrators... --> <xf:else /> <!-- Content here will be shown to anyone who is not an Administrator! --> </xf:if> Example usage of else-if: <xf:if is=\"$xf.visitor.is_admin\"> <!-- Content here will only be shown to Administrators... --> <xf:elseif is=\"$xf.visitor.is_moderator\" /> <!-- Content here will only be shown to Moderators (excluding users who are also Administrators). --> <xf:else /> <!-- Content here will be shown to anyone who is not an Administrator, or a Moderator. --> </xf:if> As you can see, once a condition has been met, the rest of the if statement is ignored. (So, in this case, if the user is an Administrator, the top xf:if section is run but then the rest of the if statement is ignored.)","title":"Else/Else-If tag"},{"location":"template-syntax/#for-each-tag","text":"The for-each tag allows you to loop over an array of items, printing a block of HTML for each item. <xf:set var=\"$names\" value=\"{{ ['Patrick', 'Theresa', 'Kimball', 'Wayne', 'Grace'] }}\" /> <xf:foreach loop=\"$names\" key=\"$key\" value=\"$name\" i=\"$i\"> <p>Hello there, {$name}. This is name number {$i}. Array key of this element: {$key}</p> </xf:foreach> The for-each tag takes the following attributes: loop - The array to loop over. key - A variable name to use in the loop to get current element's array key. Can be integer (ordinary array) or string (associative array). value - A variable name to use within the loop, containing the current array item. i - A variable name to use in the loop for the current index.","title":"For-each tag"},{"location":"template-syntax/#example-output","text":"Hello there, Patrick. This is name number 1. Hello there, Theresa. This is name number 2. Hello there, Kimball. This is name number 3. Hello there, Wayne. This is name number 4. Hello there, Grace. This is name number 5.","title":"Example Output"},{"location":"template-syntax/#template-tags","text":"","title":"Template tags"},{"location":"template-syntax/#avatar-tag","text":"Inserts a user's avatar in the page. <xf:avatar user=\"{$xf.visitor}\" size=\"o\" canonical=\"true\" /> The avatar tag takes the following attributes: user - The XenForo User object to generate the avatar for. size - The size of the image to generate. (See image sizes) canonical - Whether to use the full SEO-friendly URL. This value is only respected for custom avatars. notooltip - Whether the tool-tip displayed when hovering over the avatar should be disabled. forcetype - Can be used to force getting the gravatar or custom avatars by setting the value to either of those. defaultname - The username to use if the user attribute contains an invalid user.","title":"Avatar tag"},{"location":"template-syntax/#image-sizes","text":"If an avatar of invalid size is provided, the code will fallback to size ' s '. o - 384px h - 384px l - 192px m - 96px s - 48px","title":"Image sizes"},{"location":"template-syntax/#breadcrumb-tag","text":"Modifies the page breadcrumb. <xf:breadcrumb href=\"{{ link('my_page') }}\">{{ phrase('my_page_name') }}</xf:breadcrumb> The breadcrumb tag takes the following attributes: href - The link to set for the final element in the breadcrumb. The value of the tag can be used to set the name of the final element in the breadcrumb.","title":"Breadcrumb tag"},{"location":"template-syntax/#alternative-uses","text":"<xf:breadcrumb source=\"$category.getBreadcrumbs(false)\" /> You can also define your own breadcrumb programmatically by calling your function in the source attribute of the breadcrumb tag. The source parameter essentially takes an array of objects with href and value attributes (multidimensional array), where each object is a breadcrumb element. Note If you want to change the root breadcrumb, you can change the \"Root breadcrumb\" option in the \"Basic board information\" options section.","title":"Alternative uses"},{"location":"template-syntax/#button-tag","text":"Adds a button element with the appropriate classes and optionally an icon. <xf:button icon=\"save\"></xf:button> The button tag takes the following attributes: icon - The icon class to apply to the button. (See button icons)","title":"Button tag"},{"location":"template-syntax/#button-icons","text":"By default, XenForo buttons support the following icons (created with CSS): add confirm write import export download disable edit save reply quote purchase payment convert search sort upload attach login rate config refresh translate vote result history cancel preview conversation bolt list prev next markRead notificationsOn notificationsOff merge move copy approve unapprove delete undelete stick unstick lock unlock","title":"Button icons"},{"location":"template-syntax/#callback-tag","text":"Executes a PHP Callback method. <xf:callback class=\"Vendor\\Addon\\Class\" method=\"getX\" params=\"['abc']\"></xf:callback> The callback tag takes the following attributes: class - The class (from the root namespace) containing the method to run. method - The method to run. (See callback methods) params - An array of parameters to provide to the method.","title":"Callback tag"},{"location":"template-syntax/#callback-methods","text":"For a method to be considered a callback method, it must be named appropriately or it will throw an error ' callback_method_x_does_not_appear_to_indicate_read_only '. For it to be considered read-only, the method name must begin with one of the following prefixes: are can count data display does exists fetch filter find get has is pluck print render return show total validate verify view","title":"Callback methods"},{"location":"template-syntax/#css-tag","text":"Includes a CSS or LESS template file. <xf:css src=\"mycss_file.css\" /> The CSS tag takes the following attributes: src - The CSS or LESS template file to include.","title":"CSS tag"},{"location":"template-syntax/#alternative-uses_1","text":"<xf:css> html, body { font-family: \"Roboto\", sans-serif; } </xf:css> If the CSS tag is not empty, anything in the tag will be converted into inline CSS.","title":"Alternative uses"},{"location":"template-syntax/#further-notes","text":"For [CSS], forget about calling them as files. Copy and paste them into new templates. Chris D, XenForo developer Source : https://xenforo.com/community/threads/including-external-library-js-and-css.136153/post-1185631","title":"Further notes"},{"location":"template-syntax/#js-tag","text":"Includes a JavaScript file. <xf:js src=\"myaddon/vendor/scripts/myjs_file.js\" /> The JS tag takes the following attributes: src - The JS file to include in the template. prod - The JS file to include in the template, only for production mode. dev - The JS file to include in the template, only for development mode. min - Whether or not to include the minified version of the file. (Replaces .js with .min.js ) - Respected only in production mode. addon - Whether or not the development JS URL should be used. - Respected only in development mode. Warning The src tag cannot be used in conjunction with either the prod or dev tags.","title":"JS tag"},{"location":"template-syntax/#alternative-uses_2","text":"<xf:js> alert(\"The truth hurts, I know. It's biologically based actually.\"); </xf:js> If the JS tag is not empty, anything in the tag will be converted to inline JS.","title":"Alternative uses"},{"location":"template-syntax/#further-notes_1","text":"JavaScript files are served relative to the /js directory. Although not recommended, you can also include external resources with this tag. A good example of this tag is in the editor template.","title":"Further notes"},{"location":"template-syntax/#set-tag","text":"The set tag allows you to create a reference to another variable or create a new variable. You should use the set tag anywhere you would use a variable in a programming language. <xf:set var=\"$visitor\" value=\"{$xf.visitor}\" /> Warning Do not use the Set tag for a group of elements you wish to use in multiple templates, you should instead use the Macro Tag. Warning The variable name ( var attribute) must begin with a $ . The set tag takes the following attributes: var - The name of the variable you wish to define (essentially, the alias). value - A variable to reference to or a variable value.","title":"Set tag"},{"location":"template-syntax/#alternative-uses_3","text":"<xf:set var=\"$myVariableName\"> My Variable Value! This could be a callback, or simply a group of phrases. </xf:set> When the value attribute is not provided, and the tag is not empty, the variable value will be set to the contents of the tag. Warning When you use the Set tag in this form, the value will be escaped and the resulting value will be a string. The value attribute, whilst not supporting HTML or HTML-like tags does not have this limitation.","title":"Alternative uses"},{"location":"template-syntax/#likes-tag","text":"Displays the number of likes on a post and a few of the users who've liked the post. <xf:likes content=\"{$post}\" url=\"\" /> The likes tag takes the following attributes: content - The XF\\Entity\\Post or XF\\Entity\\ProfilePost entity to display the 'likes' text for. url - The URL to display when the 'likes' text is clicked.","title":"Likes tag"},{"location":"template-syntax/#format","text":"You, tlisbon, kcho and 2 others The format is [\ud83d\udc4d abc and x others] (where the \ud83d\udc4d 'thumbs up' emoji represents the 'likes' icon and abc represents the usernames of the last three users who liked the post.)","title":"Format"},{"location":"template-syntax/#sidebar-tag","text":"See Sectioned Tags .","title":"Sidebar tag"},{"location":"template-syntax/#sidenav-tag","text":"See Sectioned Tags .","title":"SideNav tag"},{"location":"template-syntax/#title-tag","text":"Sets the page's title, both on the page in the h1 tag and in the browser tab. <xf:title>{{ phrase('my_page_title') }}</xf:title>","title":"Title tag"},{"location":"template-syntax/#further-notes_2","text":"Whilst the title can, of course, be hardcoded, it is highly recommended that you use a phrase, both for internationalization and for the added customizability on the site administrator's end.","title":"Further notes"},{"location":"template-syntax/#widget-tag","text":"Includes a widget in the page, or adds a widget to a widget position. <xf:widget key=\"widget_name\" /> The widget tag takes the following attributes: key - The widget key, as defined in the widget settings. position - If set, changes the position that the widget will be rendered. class - Not to be confused with HTML class, this is the PHP class containing the widget definition. title - When the class attribute is used, you can use the title attribute to set the widget title. You can also provide widget-specific options as attributes when the class attribute is used. Warning The class tag cannot be used in conjunction with the key tag.","title":"Widget tag"},{"location":"template-syntax/#useractivity-tag","text":"Displays the status of a user, in terms of their last action and when that action occurred. <xf:useractivity user=\"{$xf.visitor}\" /> The UserActivity tag takes the following attributes: user - The user to display the status of.","title":"UserActivity tag"},{"location":"template-syntax/#format_1","text":"Viewing page Latest Case Files \u00b7 4 minutes ago The format is [Activity Name] \u00b7 [Time]","title":"Format"},{"location":"template-syntax/#userbanners-tag","text":"Displays the user's banners in a horizontal list. <xf:userbanners user=\"{$xf.visitor}\" /> The UserBanners tag takes the following attributes: user - The user to display the user banners of.","title":"UserBanners tag"},{"location":"template-syntax/#example","text":"An example result of the UserBanners tag.","title":"Example"},{"location":"template-syntax/#userblurb-tag","text":"Displays a one-line summary of a user's profile. <xf:userblurb user=\"${xf.visitor}\" /> The UserBlurb tag takes the following attributes: user - The XenForo User Object to display the blurb of.","title":"UserBlurb tag"},{"location":"template-syntax/#format_2","text":"FBI Consultant \u00b7 43 \u00b7 From United States of America The format is [Role / Custom Title] \u00b7 Age \u00b7 Location","title":"Format"},{"location":"template-syntax/#username-tag","text":"Displays the user's username, optionally with a tool-tip. <xf:username user=\"{$xf.visitor.username}\" notooltip=\"true\" /> The Username tag takes the following attributes: user - The XenForo User Object to display the name of. notooltip - Whether or not the tool-tip should be disabled. href - The link to navigate to when the username is clicked. Warning The tool-tip will not be displayed if an href is set, as it won't work and might be misleading to users.","title":"Username tag"},{"location":"template-syntax/#usertitle-tag","text":"Displays the user's title. <xf:usertitle user=\"{$xf.visitor}\" /> The UserTitle tag takes the following attributes: user - The XenForo User Object to display the user title of.","title":"UserTitle tag"},{"location":"template-syntax/#sectioned-tags","text":"Sectioned Tags all call the function modifySectionedHtml . The HTML element that they change is simply the tag name. So the sidebar tag will modify the sidebar HTML, etc.","title":"Sectioned tags"},{"location":"template-syntax/#example_1","text":"<xf:sidebar> <h1>My Magical Sidebar!</h1> </xf:sidebar>","title":"Example"},{"location":"template-syntax/#common-attributes","text":"mode - The mode of the modification. (See Modification modes)","title":"Common attributes"},{"location":"template-syntax/#modification-modes","text":"By default, the modification mode is replace . (i.e. if the attribute is not specified.) prepend - Places the contents of the tag at the beginning of the element's HTML. append - Places the contents of the tag at the end of the element's HTML. replace - Replaces the element's HTML with the contents of the tag.","title":"Modification modes"}]}